% \iffalse meta-comment
%/GitFileInfo=tudscr-manual.dtx
%
%  TUD-Script -- Corporate Design of Technische Universität Dresden
% ----------------------------------------------------------------------------
%
%  Copyright (C) Falk Hanisch <hanisch.latex@outlook.com>, 2012-2021
%
% ----------------------------------------------------------------------------
%
%  This work may be distributed and/or modified under the conditions of the
%  LaTeX Project Public License, either version 1.3c of this license or
%  any later version. The latest version of this license is in
%    http://www.latex-project.org/lppl.txt
%  and version 1.3c or later is part of all distributions of
%  LaTeX version 2008-05-04 or later.
%
%  This work has the LPPL maintenance status "maintained".
%
%  The current maintainer and author of this work is Falk Hanisch.
%
% ----------------------------------------------------------------------------
%
% \fi
%
% \iffalse ins:batch + dtx:driver
%<*ins>
\ifx\documentclass\undefined
  \input docstrip.tex
  \ifToplevel{\batchinput{tudscr.ins}}
\else
  \let\endbatchfile\relax
\fi
\endbatchfile
%</ins>
%<*dtx>
\ProvidesFile{tudscr-manual.dtx}[2020/11/11]
\RequirePackage{tudscr-gitinfo}
\documentclass[english,ngerman,xindy]{tudscrdoc}
\iftutex
  \usepackage{fontspec}
\else
  \usepackage[T1]{fontenc}
  \usepackage[ngerman=ngerman-x-latest]{hyphsubst}
\fi
\usepackage{babel}
\usepackage{tudscrfonts}
\usepackage[babel]{microtype}

\GitHubBase{\TUDScriptRepository}
\begin{document}
  \maketitle
  \tableofcontents
  \DocInput{\filename}
\end{document}
%</dtx>
% \fi
%
% \selectlanguage{ngerman}
%
% \changes{v2.02}{2014/12/17}{Erstellung der \app{texindy}-Stildatei während
%   der Kompilierung}^^A
% \changes{v2.02}{2014/11/18}{\pkg{tudscrtutorial}: Index für Tutorials}^^A
% \changes{v2.05}{2015/08/04}{Geteilte Deklarationen für Klasse und Paket}^^A
%
%
%
% \section{Anwenderdokumentation und Leitfäden zu \TUDScript}
%
% Es werden die Klasse \cls{tudscrmanual} (auf Basis von \cls{tudscrreprt}) für 
% die Anwenderdokumentation sowie das Paket \pkg{tudscrtutorial} für das Setzen
% von einigen Anwenderleitfäden bzw. Tutorials erzeugt. Da es zwischen der
% Klasse und dem Paket es eine große Menge an Überschneidungen gibt, basieren
% diese auf der gleichen Quelldatei.
% \ToDo{guards überarbeiten, korrelierenden Quelltext zusammenhalten}[v2.07]
% \ToDo{Paket tudscrtutorial in tudscrmanual umbenennen}[v2.07]
%    \begin{macrocode}
%<*package&identify>
\ProvidesPackage{tudscrtutorial}[%
%!TUD@Version
  package (tudscr tutorials)%
]
\TUD@Class@Check{tudscrtutorial}
%</package&identify>
%    \end{macrocode}
%
% \iffalse
%<*body>
% \fi
%
% \subsection{Kleine Helferlein}
% \subsubsection{Verarbeitung von Versionsangaben}
%
% Mit diesen Befehlen können Versionsangaben zu \TUDScript verarbeitet und 
% validiert werden.
%
% \begin{macro}{\tud@v@to@number}
% \changes{v2.07}{2021/06/16}{neu}^^A
% Das zweite obligatorischen Argument wird expandiert und eine Versionsangabe 
% im gebräuchlichen \LaTeX"~Format (|[v]?\d.\d\d?[a-z]?\s.*|) in einen
% Integer-Wert gewandelt. Dieser wird in das Makro im ersten obligatorischen
% Argument zurückgeschrieben, welches anschließend für Vergleiche verwendet
% werden kann. Die Sternversion schreibt die normalisierte Versionsangabe in
% das Makro im zweiten Argument zurück.
%    \begin{macrocode}
\NewDocumentCommand\tud@v@to@number{s m m}{%
  \begingroup%
    \edef\tud@res@a{%
      \unexpanded{\tud@v@get\tud@res@a}{#3}%
    }%
    \tud@res@a%
    \def\tud@res@c##1 ##2~##3\@nil{%
      \IfArgIsEmpty{##2}{%
        \let\tud@res@b\@empty%
      }{%
        \def\tud@res@a{##1}%
        \def\tud@res@b{\space##2}%
      }%
    }%
    \expandafter\tud@res@c\tud@res@a~ ~\@nil%
    \protected@expandtwoargs\in@{.}{\tud@res@a}%
    \ifin@%
      \def\tud@res@c##1.##2##3##4\@nil{%
        \let\tud@res@a\relax%
        \Ifnumber{##1}{%
          \Ifnumber{##2}{%
            \Ifnumber{##3}{%
              \edef\tud@res@a{##1.##2##3##4}%
            }{%
              \edef\tud@res@a{##1.\two@digits{##2}##3##4}%
            }%
          }{}%
        }{}%
      }%
      \expandafter\tud@res@c\tud@res@a\@empty\@nil%
      \ifx\tud@res@a\relax\else%
        \def\tud@res@c##1.##2##3##4##5\@nil{%
          \tud@if@strblank{##5}{%
            \edef\tud@res@a{v##1.##2##3##4\tud@res@b}%
            \edef\tud@res@b{##1.##2##3##4}%
          }{%
            \let\tud@res@a\relax%
          }%
        }%
        \expandafter\tud@res@c\tud@res@a\@empty\@nil%
      \fi%
    \else%
      \let\tud@res@a\relax%
    \fi%
    \ifx\tud@res@a\relax%
      \ClassWarning{tudscrmanual}{Wrong formatted version number}%
    \else%
      \def\tud@res@c##1.##2##3##4\@nil{%
        ##1##2##3%
        \IfArgIsEmpty{##4}{000}{\ifnum\number`##4<100 0\fi\number`##4}%
      }%
      \edef\tud@res@b{\expandafter\tud@res@c\tud@res@b\@nil}%
    \fi%
    \edef\tud@res@c{%
      \endgroup%
      \ifx\tud@res@a\relax%
        \unexpanded{\let#2\relax}%
      \else%
        \unexpanded{\def#2}{\tud@res@b}%
        \IfBooleanT{#1}{\unexpanded{\def#3}{\tud@res@a}}%
      \fi%
    }%
  \tud@res@c%
}
%    \end{macrocode}
% \end{macro}^^A \tud@v@to@number
%
% \begin{macro}{\tud@v@validate}
% \changes{v2.07}{2021/06/16}{neu}^^A
% Normalisiert die Versionsangabe im übergebenen Makro und erzeugt einen 
% Fehler, falls diese nicht ausgewertet werden kann.
%    \begin{macrocode}
\newcommand*\tud@v@validate[1]{%
  \begingroup%
    \protected@edef\tud@res@a{#1}%
    \trim@spaces@in\tud@res@a%
    \tud@v@to@number*\tud@res@b{\tud@res@a}%
    \edef\tud@res@a{%
      \endgroup%
      \ifx\tud@res@b\relax%
        \unexpanded{%
          \ClassError{tudscrmanual}{Invalid version number}{%
            The given version number `#1' is invalid as it\MessageBreak%
            should be `[v][0-9]+.[0-9]+[a-z]*' (regex).%
          }%
          \let#1\relax%
        }%
      \else%
        \unexpanded{\def#1}{\tud@res@a}%
      \fi%
    }%
  \tud@res@a%
}
%    \end{macrocode}
% \end{macro}^^A \tud@v@validate
%
% \subsubsection{Abschneiden von Werten}
%
% \begin{macro}{\tud@truncate@value}
% \changes{v2.07}{2021/06/15}{neu}^^A
% Der expandierte Inhalt des zweiten Argumentes \meta{key}|=|\meta{value}
% wird an |=| getrennt und \meta{key} in das Makro des ersten Argumentes 
% zurück geschrieben.
%    \begin{macrocode}
\newcommand*\tud@truncate@value[2]{%
  \begingroup%
    \protected@edef\tud@res@a{#2}%
    \def\tud@res@b##1=##2\@nil{%
      \endgroup%
      \def#1{##1}%
    }%
  \expandafter\tud@res@b\tud@res@a=\@nil%
}
%    \end{macrocode}
% \end{macro}^^A \tud@truncate@value
%
%
% \subsection{Patches für den Kernel}
%
% Sowohl für die Ausgaberoutine als auch für das Inhaltsverzeichnis sind im 
% weiteren Verlauf Anpassungen notwendig, weshalb hierfür entsprechende Hooks 
% bereitgestellt werden.
% Spezielles für Inhaltsverzeichnis und Fußzeile
% \ToDo{Das muss dokumentiert werden!}[v2.07]
% \begin{macro}{\tud@outputpage@hook}
% \changes{v2.07}{2021/06/15}{neu}^^A
% \begin{macro}{\tud@outputpage@special}
% \changes{v2.07}{2021/06/15}{neu}^^A
% \begin{macro}{\@outputpage}
% Die Patches für die Ausgaberoutine.
%    \begin{macrocode}
\newcommand*\tud@outputpage@hook{}
\let\tud@outputpage@hook\relax
\newcommand*\tud@outputpage@special[1]{\appto\tud@outputpage@hook{#1}}
\@onlypreamble\tud@outputpage@special
\patchcmd\@outputpage{%
  \let\index\@gobble\let\glossary\@gobble%
}{%
  \let\index\@gobble\let\glossary\@gobble%
  \tud@outputpage@hook%
}{}{\tud@patch@wrn{@outputpage}}
%    \end{macrocode}
% \end{macro}^^A \@outputpage
% \end{macro}^^A \tud@outputpage@special
% \end{macro}^^A \tud@outputpage@hook
% \begin{macro}{\tud@addtocontents@hook}
% \changes{v2.07}{2021/06/15}{neu}^^A
% \begin{macro}{\tud@addtocontents@special}
% \changes{v2.07}{2021/06/15}{neu}^^A
% \begin{macro}{\addtocontents}
% Die Patches für die Inhaltsverzeichnis und Outline-Einträge. Letztere werden 
% nur geändert, falls die Sternversion genutzt wurde.
%    \begin{macrocode}
\newcommand*\tud@addtocontents@hook{}
\let\tud@addtocontents@hook\relax
\NewDocumentCommand\tud@addtocontents@special{s m}{%
  \appto\tud@addtocontents@hook{#2}%
  \IfBooleanT{#1}{%
    \AfterPackage*{hyperref}{\pdfstringdefDisableCommands{#2}}%
    \AfterPackage*{nameref}{\GetTitleStringDisableCommands{#2}}%
  }%
}
\@onlypreamble\tud@addtocontents@special
\patchcmd\addtocontents{%
  \let\index\@gobble\let\glossary\@gobble%
}{%
  \let\index\@gobble\let\glossary\@gobble%
  \tud@addtocontents@hook%
}{}{\tud@patch@wrn{addtocontents}}
%    \end{macrocode}
% \end{macro}^^A \addtocontents
% \end{macro}^^A \tud@addtocontents@special
% \end{macro}^^A \tud@addtocontents@hook
%
%
%
% \subsection{Notwendige Pakete, Einstellungen und abgeleitete Befehle}
%
% Mit dem Paket \pkg{morewrites} lassen sich Probleme mit zu wenig verfügbaren 
% Streams für das Schreiben externer Datein beheben. Hintergrund ist die
% Verwendung des Paketes \pkg{glossaries} in einem der Tutorials, welches eine
% Vielzahl solcher Streams benötigt.
% \ToDo{noch notwendig?}[v2.07]
%    \begin{macrocode}
%<*package>
\RequirePackage{morewrites}[2018/12/29]
%</package>
%    \end{macrocode}
%
% \subsubsection{Makro- und Microtypografie}
% Für den zweispaltigen Satz im Index.
%    \begin{macrocode}
\RequirePackage{multicol}[2019/12/09]
%    \end{macrocode}
% Vergrößerung des Durchschusses.
%    \begin{macrocode}
\RequirePackage{setspace}[2011/12/19]
\setstretch{1.1}
%    \end{macrocode}
%
% \iffalse
%</body>
% \fi
%
% Das Paket \pkg{microtype} wird für den optischen Randausgleich verwendet. Es 
% sollte erst nach \pkg{hyperref} geladen werden. Wurde \pkg{hyperref} nicht
% geladen, dann soll auf \pkg{microtype} trotzdem nicht verzichtet werden.
%    \begin{macrocode}
%<option>\PassOptionsToPackage{babel}{microtype}
%<body>\TUD@UnwindPackage*{hyperref}{\RequirePackage{microtype}[2021/03/14]}
%    \end{macrocode}
% Zitate mit Beachtung der Absatzeinstellungen.
%    \begin{macrocode}
%<option>\PassOptionsToPackage{vskip=\smallskipamount}{quoting}
%<body>\RequirePackage{quoting}[2014/01/28]
%    \end{macrocode}
%
% \iffalse
%<*body>
% \fi
%
% Automatisierte Datumsformatierung.
%    \begin{macrocode}
\RequirePackage{isodate}[2010/01/03]
%    \end{macrocode}
% Mit dem Paket \pkg{ragged2e} wird~-- falls benötigt~-- die Silbentrennung im 
% Flattersatz aktiviert. 
%    \begin{macrocode}
\RequirePackage{ragged2e}[2021/02/05]
%    \end{macrocode}
% Die Fußnoten werden nicht mit jedem Kapitel zurückgesetzt\dots
%    \begin{macrocode}
\@removefromreset{footnote}{chapter}
%    \end{macrocode}
% \dots und im Flattersatz ausgegeben.
%    \begin{macrocode}
\renewcommand*\raggedfootnote{\tud@RaggedRight}%
%    \end{macrocode}
% Unterdrücken von Absatzeinzügen nach bestimmten Umgebungen.
%    \begin{macrocode}
\RequirePackage{noindentafter}[2021/05/14]
%    \end{macrocode}
% Typographisch saubere Einheiten.
%    \begin{macrocode}
\RequirePackage{units}[1998/08/04]
%    \end{macrocode}
% Das Paket \pkg{ellipsis} sorgt für korrekte Auslassungpunkte.
%    \begin{macrocode}
\AtEndPreamble{%
  \RequirePackage{ellipsis}[2020/05/22]%
  \let\ellipsispunctuation\relax%
}
%    \end{macrocode}
%
%
%
% \subsubsection{Tabellen, Listen und Auflistungen}
%
% Mit Hilfe von \pkg{tabularx} können Tabellen bestimmter Breite und
% automatisch berechneten Spaltenbreiten gesetzt werden.
%    \begin{macrocode}
\RequirePackage{tabularx}[2020/01/15]
%    \end{macrocode}
% Das Paket wird für die Erstellung von Tabellen verwendet.
%    \begin{macrocode}
\RequirePackage{booktabs}[2020/01/12]
%    \end{macrocode}
% \begin{macro}{\dossvlist}
% \changes{v2.05}{2015/11/17}{neu}^^A
% \begin{macro}{\forssvlist}
% \changes{v2.05}{2015/11/17}{neu}^^A
% Makros aus \pkg{etoolbox} für das Verarbeiten von semikolongetrennten Listen.
%    \begin{macrocode}
\DeclareListParser{\dossvlist}{;}
\DeclareListParser*{\forssvlist}{;}
%    \end{macrocode}
% \end{macro}^^A \forssvlist
% \end{macro}^^A \dossvlist
% Das Paket \pkg{enumitem} erlaubt das Beeinflussen der Standardlisten und die 
% Ableitung neuer Listen aus diesen. Mit \cs{setlist\{noitemsep\}} werden die 
% zusätzlichen Zwischenräume innerhalb der Listen beseitigt. Weiterhin wird 
% linksbündiger Flattersatz für die Standardlisten aktiviert.
%    \begin{macrocode}
\RequirePackage{enumitem}[2019/06/20]
\setlist{%
  before*={\endgraf\tud@RaggedRight},%
  partopsep=0pt,noitemsep%
}
%    \end{macrocode}
% \begin{macro}{\tud@list@create}
% \changes{v2.07}{2021/06/09}{neu}^^A
% Dieses Makro dient dem Erstellen zusätzlicher Listenumgebungen mit 
% vordefinierten Einstellungen.
%    \begin{macrocode}
\newcommand*\tud@list@create[4][]{%
  \newlist{#2}{#3}{#4}%
  \setlist[{#2}]{%
    font=\normalfont,%
    labelindent=.75em,labelwidth=\dimexpr\linewidth-.75em\relax,labelsep=0pt,%
    topsep=\smallskipamount,parsep=\parskip,listparindent=\parindent,%
    #1%
  }%
}
%    \end{macrocode}
% \end{macro}^^A \tud@list@create
%
%
%
% \subsubsection{Grafiken \& Co.}
%
%    \begin{macrocode}
\RequirePackage{tikz}[2021/05/15]
%    \end{macrocode}
% Einbinden von ganzseitigen PDF"~Dokumenten als Beispiel im Handbuch.
%    \begin{macrocode}
\RequirePackage{pdfpages}[2021/03/06]
%    \end{macrocode}%
%
%
% \subsubsection{Formatierung von Gleitobjekten}
%
%    \begin{macrocode}
\RequirePackage{caption}[2020/10/26]
\RequirePackage{floatrow}[2008/08/02]
\DeclareCaptionSubType[alph]{figure}
\DeclareCaptionSubType[alph]{table}
\captionsetup{font=sf,labelfont=bf,labelsep=space}
\captionsetup{singlelinecheck=off,format=hang,justification=raggedright}
\captionsetup[subfloat]{labelformat=brace,list=off}
\KOMAoption{captions}{tableheading,figuresignature}
\floatsetup[table]{style=plaintop}
%    \end{macrocode}
%
%
% \subsubsection{Kompilieren externer Quelldateien}
%
% \ToDo{shell-Kram raus, Tutorials/Examples über \app{make} erstellen}[v2.07]
% Das Paket \pkg{filemod} wird genutzt, um externer Dateien nur zu kompilieren,
% wenn dies aufgrund einer Änderung auch notwendig ist.
%    \begin{macrocode}
\RequirePackage{filemod}[2011/09/19]
%    \end{macrocode}
% Um \cs{ShellEscape} sowohl für Windows als auch für unixoide Betriebssysteme 
% nutzen zu können, wird das Paket \pkg{ifplatform} geladen.
%    \begin{macrocode}
\RequirePackage{ifplatform}[2017/10/13]
%    \end{macrocode}
% \begin{macro}{\tud@shellescape@wrn}
% \changes{v2.02}{2014/10/14}{neu}^^A
% Dieses Makro wird verwendet, wenn eine gesuchte Datei nicht gefunden wurde, 
% weil das Dokument noch nicht mit dem Parameter \file{-{}-shell-escape} 
% kompiliert wurde.
%    \begin{macrocode}
\newcommand*\tud@shellescape@wrn[1]{%
%<*class>
  \ClassWarning{tudscrmanual}%
%</class>
%<*package>
  \PackageWarning{tudscrtutorial}%
%</package>
  {%
    File `#1' is missing!\MessageBreak%
    You have to recompile this document with\MessageBreak%
    activated shell escape option%
  }%
}
%    \end{macrocode}
% \end{macro}^^A \tud@shellescape@wrn
% \begin{macro}{\tud@latex@ext}
% \changes{v2.06}{2019/06/21}{neu}^^A
% Für das verschachtelte Aufrufen von \app{pdflatex} bzw. \app{lualatex}.
%    \begin{macrocode}
\newcommand*\tud@latex@ext{pdflatex\space}
\iftutex
  \ifxetex
    \renewcommand*\tud@latex@ext{xelatex\space}
  \else
    \renewcommand*\tud@latex@ext{lualatex\space}
  \fi
\fi
\appto\tud@latex@ext{-synctex=1\space}
%    \end{macrocode}
% \end{macro}^^A \tud@latex@ext
%
%
%
% \subsubsection{Einbinden von Quelltexten}
%
% Sowohl im Handbuch als auch in den Tutorials werden Quelltextauszüge für das 
% bessere Verständnis des Anwenders angegeben. Um diese darzustellen wird das 
% Paket \pkg{listings} verwendet.
%    \begin{macrocode}
\RequirePackage{listings}[2020/03/24]
\lstdefinestyle{tudscr}{%
  basicstyle=\ttfamily\ifundef{\setstretch}{}{\setstretch{1}},%
  keywordstyle=,%
  columns=fullflexible,keepspaces,%
  aboveskip=\smallskipamount,%
  belowskip=\smallskipamount,%
  language=[LaTeX]TeX,%
  texcl,%
}
%    \end{macrocode}
%
% \begin{environment}{Code}
% Folgend werden Befehle und Umgebungen für die Darstellung von Quelltexten im 
% Handbuch definiert. Mit dieser Umgebung können kurze Quelltextbeispiele 
% ausgegeben werden. Sicherlich sinnvoll ist, die \env{Code}-Umgebung innerhalb
% von \env{Example} oder \env{quoting} zu verwenden, um den Quelltext etwas
% abzuheben.
%    \begin{macrocode}
\lstnewenvironment{Code}[1][]{\lstset{style=tudscr,#1}}{}
\NoIndentAfterEnv{Code}
%    \end{macrocode}
% Innerhalb der Umgebung \env{Code} wird \cs{@currentHref} unerwünschter Weise
% geändert. Um dies zu vermeiden, wird dieser Befehl gesichert und anschließend
% zurückgesetzt.
%    \begin{macrocode}
\BeforeBeginEnvironment{Code}{\global\let\tud@currentHref\@currentHref}
\AfterEndEnvironment{Code}{\global\let\@currentHref\tud@currentHref}
%    \end{macrocode}
% \end{environment}^^A Code
%
% \iffalse
%</body>
% \fi
%
% \subsubsection{Querverweise und Anpassungen für das Paket \pkg{hyperref}}
%
% Das Paket \pkg{hyperref} wird für alle möglichen Links und Querverweise 
% geladen, \pkg{bookmark} verbessert das Erstellen der Outline-Einträge.
%    \begin{macrocode}
%<*option>
\PassOptionsToPackage{hyperindex=false}{hyperref}
\AfterPackage*{bookmark}{\bookmarksetup{open,openlevel=1}}
\AfterAtEndOfPackage*{hyperref}{%
  \@ifpackageloaded{bookmark}{}{\RequirePackage{bookmark}}%
  \hypersetup{%
    colorlinks,%
    linkcolor=HKS44,%
    urlcolor=HKS33,%
    citecolor=HKS57,%
    filecolor=HKS65,%
    destlabel=true,%pdfview=FitH,%
  }
}
%</option>
%    \end{macrocode}
% Verbesserte Referenzierungen auf Seiten.
%    \begin{macrocode}
%<option>\PassOptionsToPackage{nospace}{varioref}
%<body>\RequirePackage{varioref}[2020/08/11]
%    \end{macrocode}
%
% \iffalse
%<*body>
% \fi
%
% \begin{macro}{\fullref}
% Ein Makro zur vollständigen Referenzierungen inklusive der relevanten Seite.
%    \begin{macrocode}
\renewrobustcmd*\fullref[1]{\hyperref[{#1}]{\autoref*{#1}\space\vpageref{#1}}}
%    \end{macrocode}
% \end{macro}^^A \fullref
% Um ungewünschten vertikalen Leerraum vor und nach Überschriften zu vermeiden, 
% werden die Befehle \cs{label} und \cs{index} innerhalb des obligatorischen 
% Argumentes von Gliederungsbefehlen genutzt (\GitHubRepo(latex3/latex2e)<307>).
% Damit diese nicht im durch \cs{newlabel} erzeugten Label auftauchen, muss 
% durch \pkg{nameref} explizit \cs{GetTitleStringExpand} verwendet werden.
%    \begin{macrocode}
\RequirePackage{nameref}[2021/04/02]
\AfterPackage*{nameref}{%
  \patchcmd\NR@gettitle{%
    \GetTitleString%
  }{%
    \GetTitleStringExpand%
  }{}{\tud@patch@wrn{NR@gettitle}}%
}
%    \end{macrocode}
%
% Es folgen einige Befehle, die an das Paket \pkg{hyperref} gekoppelt sind. 
% Sobald das Paket geladen wurde, werden die Makros mit der jeweiligen
% Funktionalität definiert.
% \begin{macro}{\tud@currentHref}
% Einige Befehle und Umgebungen von Drittpaketen ändern bei deren Aufruf die 
% Definition von \cs{currentHref}, was bei Querverweisen gegebenenfalls zu 
% falschen Einträgen führt. Hierfür wird \cs{tud@currentHref} definiert, um die 
% jeweils aktuelle Definition von \cs{currentHref} zu sichern und nach den 
% fraglichen Befehlen und Umgebungen zurückzusetzen.
%    \begin{macrocode}
\newcommand*\tud@currentHref{}
%    \end{macrocode}
% \end{macro}^^A \tud@currentHref
%    \begin{macrocode}
\AfterPackage*{hyperref}{%
%    \end{macrocode}
% \begin{macro}{\autorefname}
% \begin{macro}{\auto@refname}
% \begin{macro}{\auto@@refname}
% Der Befehl \cs{autorefname} dient dazu, den Verweistyp beziehungsweise den 
% Bezeichner des aktuellen~-- oder optional eines speziellen~-- Labels ohne die 
% dazugehörige Nummerierung zu erhalten. Das zugrunde liegende Funktionsprinzip 
% wurde bei \hrfn{http://tex.stackexchange.com/q/33776}{LaTeX Stack Exchange} 
% vorgestellt und hier übernommen.
%    \begin{macrocode}
  \newcommand*\autorefname[1][current]{%
    \Ifstr{#1}{current}{%
      \expandafter\HyPsd@@autorefname\@currentHref\@nil%
    }{%
      \auto@refname\HyPsd@@autorefname{#1}%
    }%
    \unskip\xspace%
  }%
  \newcommand*\auto@refname[2]{%
    \ifcsundef{r@#2}{%
      ??%
    }{%
      \expandafter\expandafter\expandafter\auto@@refname%
          \csname r@#2\endcsname{}{}{}{}\@nil#1\@nil%
    }%
  }%
  \newcommand*\auto@@refname{}%
  \def\auto@@refname#1#2#3#4#5\@nil#6\@nil{#6#4.\@nil}%
%    \end{macrocode}
% \end{macro}^^A \auto@@refname
% \end{macro}^^A \auto@refname
% \end{macro}^^A \autorefname
% Die Bezeichner für die Abschnittsebenen werden umbenannt.
%    \begin{macrocode}
  \renewcaptionname{ngerman}{\sectionautorefname}{Unterkapitel}%
  \renewcaptionname{ngerman}{\subsectionautorefname}{Abschnitt}%
  \renewcaptionname{ngerman}{\subsubsectionautorefname}{Unterabschnitt}%
}
%    \end{macrocode}
% Sollte das Paket \pkg{hyperref} nicht geladen werden, wird eine Rückfallebene 
% definiert, wodurch die Klasse dennoch verwendet werden kann.
%    \begin{macrocode}
\TUD@UnwindPackage{hyperref}{%
%    \end{macrocode}
% Zunächst die direkt innerhalb der Dokumentation verwendeten Befehle nebst 
% dazugehöriger Warnung.
%    \begin{macrocode}
%<*class>
  \ClassWarningNoLine{tudscrmanual}%
%</class>
%<*package>
  \PackageWarningNoLine{tudscrtutorial}%
%</package>
  {%
    Loading the package `hyperref' is strongly\MessageBreak%
    recommended. At the very least, some essential\MessageBreak%
    commands are defined as stubs%
  }%
%    \end{macrocode}
% \begin{macro}{\hypersetup}
% \begin{macro}{\pdfbookmark}
% \begin{macro}{\currentpdfbookmark}
% \begin{macro}{\subpdfbookmark}
% \begin{macro}{\belowpdfbookmark}
% \begin{macro}{\HyperDestRename}
% Einige vom Paket \pkg{hyperref} definierten Befehle werden vorgehalten.
%    \begin{macrocode}
  \providecommand*\hypersetup[1]{}%
  \providecommand*\pdfbookmark[3][]{}%
  \providecommand*\currentpdfbookmark[2]{}%
  \providecommand*\subpdfbookmark[2]{}%
  \providecommand*\belowpdfbookmark[2]{}%
  \providecommand*\HyperDestRename[2]{}%
%    \end{macrocode}
% \end{macro}^^A \HyperDestRename
% \end{macro}^^A \belowpdfbookmark
% \end{macro}^^A \subpdfbookmark
% \end{macro}^^A \currentpdfbookmark
% \end{macro}^^A \pdfbookmark
% \end{macro}^^A \hypersetup
%
% \begin{macro}{\hyperref}
% \begin{macro}{\tud@x@hyperref@a}
% \begin{macro}{\tud@x@hyperref@b}
% \begin{macro}{\hypertarget}
% \begin{macro}{\hyperlink}
% \begin{macro}{\Hy@raisedlink}
% Der Befehl \cs{hyperref} existiert in zwei Varianten. Entweder mit einem 
% optionalen und einem obligatorischen Argument oder mit vier Argumenten.
%    \begin{macrocode}
  \providerobustcmd*\hyperref{%
    \kernel@ifnextchar[%]
      {\tud@x@hyperref@a}%
      {\tud@x@hyperref@b}%
  }%
  \newcommand*\tud@x@hyperref@a[2][]{#2}%
  \newcommand*\tud@x@hyperref@b[4]{#4}%
  \providecommand*\hypertarget[2]{#2}%
  \providecommand*\hyperlink[2]{#2}%
  \providecommand*\Hy@raisedlink[1]{#1}%
%    \end{macrocode}
% \end{macro}^^A \Hy@raisedlink
% \end{macro}^^A \hyperlink
% \end{macro}^^A \hypertarget
% \end{macro}^^A \tud@x@hyperref@b
% \end{macro}^^A \tud@x@hyperref@a
% \end{macro}^^A \hyperref
% \begin{macro}{\hyperpage}
% \begin{macro}{\autoref}
% Der Befehl \cs{autoref} wird auch in der Sternversion genutzt.
%    \begin{macrocode}
  \providecommand*\hyperpage[1]{#1}%
  \providerobustcmd*\autoref{??\xspace\kernel@ifstar{\ref}{\ref}}%
  \providerobustcmd*\autorefname[1][]{??\xspace}%
%    \end{macrocode}
% \end{macro}^^A \autoref
% \end{macro}^^A \hyperpage
% \begin{macro}{\partautorefname}
% \begin{macro}{\chapterautorefname}
% \begin{macro}{\sectionautorefname}
% \begin{macro}{\subsectionautorefname}
% \begin{macro}{\subsubsectionautorefname}
% Die notwendigen, lokalen Bezeichner der Gliederungsebenen.
%    \begin{macrocode}
  \tud@localization@german{\partautorefname}{Teil}%
  \tud@localization@german{\chapterautorefname}{Kapitel}%
  \tud@localization@german{\sectionautorefname}{Unterkapitel}%
  \tud@localization@german{\subsectionautorefname}{Abschnitt}%
  \tud@localization@german{\subsubsectionautorefname}{Unterabschnitt}%
  \tud@localization@english{\partautorefname}{Part}%
  \tud@localization@english{\chapterautorefname}{chapter}%
  \tud@localization@english{\sectionautorefname}{section}%
  \tud@localization@english{\subsectionautorefname}{subsection}%
  \tud@localization@english{\subsubsectionautorefname}{subsubsection}%
%    \end{macrocode}
% \end{macro}^^A \subsubsectionautorefname
% \end{macro}^^A \subsectionautorefname
% \end{macro}^^A \sectionautorefname
% \end{macro}^^A \chapterautorefname
% \end{macro}^^A \partautorefname
%
% Damit ist die Rückfallebene ohne \pkg{hyperref} vollständig.
%    \begin{macrocode}
}
%    \end{macrocode}
%
% \begin{macro}{\tudhyperdef}
% \changes{v2.02}{2014/10/27}{neu}^^A
% \begin{macro}{\tud@hyperdef}
% \changes{v2.07}{2019/10/29}{neu}^^A
% \begin{macro}{\tud@hyperdefvskip@dim}
% \changes{v2.07}{2019/11/07}{neu}^^A
% \begin{macro}{\tudhyperref}
% \changes{v2.02}{2014/10/27}{neu}^^A
% \begin{macro}{\tud@manualname}
% \changes{v2.05}{2015/11/19}{neu}^^A
% Diese Befehle dienen sowohl zum Definieren von Textankern im Handbuch als 
% auch zum Referenzieren auf diese. Bei der Erstellung des Ankers mit 
% \cs{tudhyperdef} wird zusätzlich auch noch ein Label (\cs{label}) erzeugt.
% Der Anker wird mit \cs{Hy@raisedlink}~-- wie es auch bei pkg{hyperref}-Labels 
% geschieht~-- über die Grundlinie gehoben. Die Sternversion sollte nach
% Überschriften verwendet werden und verschiebt die vertikale Position des
% Ankers noch weiter nach oben.
%    \begin{macrocode}
\newcommand*\tud@manualname{tudscr}%
\newcommand*\tud@hyperdefvskip@dim{\dimexpr1\baselineskip*3\relax}
\patchcmd\set@@@@preamble{%
  \let\phantomsection\relax%
}{%
  \let\phantomsection\relax%
  \renewcommand*\tud@hyperdefvskip@dim{\dimexpr1\baselineskip*15\relax}%
}{}{\tud@patch@wrn{set@@@@preamble}}
%<*class>
%    \end{macrocode}
% Die Verwendung von \cs{detokenize} ist notwendig, damit mögliche Unterschiede 
% bei den catcodes von Labeln ignoriert und nur die Strings selbst verglichen
% werden.
%    \begin{macrocode}
\tud@auxlist@register{tud@lbl@alias}[\detokenize\expandafter]%
\NewDocumentCommand\tudhyperdef{s m !d==}{%
  \begingroup%
    \IfBooleanTF{#1}{%
      \raisebox{\tud@hyperdefvskip@dim}[0pt][0pt]{\tud@hyperdef{#2}}%
      \par\nobreak\vskip\glueexpr-\parskip-\baselineskip\relax%
      \@afterindentfalse\@afterheading%
    }{%
      \Hy@raisedlink{\tud@hyperdef{#2}}\ignorespaces%
    }%
    \label{#2}%
    \tud@trace@lbl@add{created}{#2}%
%    \end{macrocode}
% Nach der Definition des eigentlichen Labels werden noch mögliche Aliaslabel 
% definiert. Das aktuell erstellte Label ist definitiv kein Alias und wird 
% dementsprechend aus der Liste zu erstellender Aliaslabel entfernt. Danach 
% wird das Basislabel aus dem aktuellen in \cs{tud@res@a} extrahiert. In 
% \cs{tud@res@b} werden alle nachfolgend erstellten Aliaswerte gesichert, um 
% diese ganz zum Schluss noch zu validieren.
%    \begin{macrocode}
    \tud@auxlist@remove{tud@lbl@alias}{#2}%
    \edef\tud@res@a{#2}%
    \def\tud@res@c##1=##2\@nil{\def\tud@res@a{##1}}%
    \expandafter\tud@res@c\tud@res@a==\@nil%
    \let\tud@res@b\@empty%
%    \end{macrocode}
% Für die während der Deklaration in \cs{tud@alias@values} abgelegten Werte 
% werden Aliaslabel erzeugt.
%    \begin{macrocode}
    \expandafter\tud@if@nil\expandafter{\tud@alias@values}{}{%
      \@for\tud@res@c:=\tud@alias@values\do{%
        \trim@spaces@in\tud@res@c%
        \ifx\tud@res@c\@empty\else%
          \listeadd\tud@res@b{\tud@res@c}%
          \tudhyper@alias@values{\tud@res@a=\tud@res@c}%
        \fi%
      }%
    }%
%    \end{macrocode}
% Dies gilt auch für die Deklaration als boolscher Schalter.
%    \begin{macrocode}
    \IfValueT{#3}{%
      \listadd\tud@res@b{#3}%
      \ifstrequal{\PBoolean}{#3}{%
        \tudhyper@alias@values{\tud@res@a=true}%
        \tudhyper@alias@values{\tud@res@a=false}%
      }{}%
    }%
%    \end{macrocode}
% Zum Schluss wird noch geprüft, ob ein boolscher Werte auch in der gewünschten 
% Notation angegeben wurden.
%    \begin{macrocode}
    \def\tud@res@c##1{%
      \ifstrbool{##1}{\@tud@res@swatrue}{\@tud@res@swatrue}{\@tud@res@swafalse}%
      \if@tud@res@swa%
        \ifboolexpr{%
          (test {\ifstrequal{##1}{true}} or test {\ifstrequal{##1}{false}})%
        }{\@tud@res@swafalse}{\@tud@res@swatrue}%
        \if@tud@res@swa%
          \ClassWarning{tudscrmanual}{%
            Boolean values should only be referred with\MessageBreak%
            'true/false' but '##1' was used%
          }%
        \fi%
      \fi%
    }%
    \expandafter\forlistloop\expandafter\tud@res@c\expandafter{\tud@res@b}%
  \endgroup%
}
\newcommand*\tud@hyperdef[1]{%
  \begingroup%
    \edef\tud@res@a{%
      \endgroup%
      \noexpand\hyperdef{\tud@manualname}{#1}{}%
    }%
  \tud@res@a%
}
%    \end{macrocode}
% Nicht verwirren lassen! Das Aliaslabel wird zunächst der Exportliste 
% hinzugefügt. Anschließend wird geprüft, ob es in der importierten Liste 
% enthalten ist.
%    \begin{macrocode}
\newcommand*\tudhyper@alias@values[1]{%
  \tud@auxlist@add{tud@lbl@alias}{#1}%
  \tud@auxlist@ifin{#1}{tud@lbl@alias}{%
    \Hy@raisedlink{\tud@hyperdef{#1}}\ignorespaces%
    \label{#1}%
    \tud@trace@lbl@add{created}{#1\space(alias)}%
  }{}%
}
%    \end{macrocode}
% Und schließlich der Befehl zum Referenzieren auf die definierten Anker.
%    \begin{macrocode}
\AfterPackage*{hyperref}{\robustify\hyperref}
\newrobustcmd*\tudhyperref[2]{\hyperref{}{\tud@manualname}{#1}{#2}}%
\NewDocumentCommand\tudmarkuplabel{o m}{\IfValueT{#1}{\label{#1}}}
%</class>
%    \end{macrocode}
% Aus einem Tutorial erfolgen alle Querverweise mit \cs{tudhyperref} auf das 
% Anwenderhandbuch \enquote*{tudscr} im übergeordneten Ordner.
%    \begin{macrocode}
%<*package>
\newrobustcmd*\tudhyperref[2]{%
  \hyperref{../\tud@manualname.pdf}{\tud@manualname}{#1}{#2}%
}%
%</package>
%    \end{macrocode}
% \end{macro}^^A \tud@manualname
% \end{macro}^^A \tudhyperref
% \end{macro}^^A \tud@hyperdefvskip@dim
% \end{macro}^^A \tud@hyperdef
% \end{macro}^^A \tudhyperdef
%
% \iffalse
%</body>
%<*option>
% \fi
%
% \subsubsection{ToDo-Liste}
%
% Für Klasse und Paket besteht die Möglichkeit, ToDo-Notizen zu nutzen, wofür
% das Paket \pkg{todonotes} geladen wird.
%    \begin{macrocode}
\PassOptionsToPackage{obeyFinal}{todonotes}
%    \end{macrocode}
% Für den Druck wird die farbige Ausgabe der ToDo-Notizen deaktiviert.
%    \begin{macrocode}
\ifdef{\tudprintflag}{%
  \PassOptionsToPackage{color=white}{todonotes}%
}{%
  \PassOptionsToPackage{colorinlistoftodos}{todonotes}%
}
%    \end{macrocode}
%
% \begin{option}{ToDo}
% \changes{v2.02}{2014/07/10}{neu}^^A
% \changes{v2.05}{2015/10/27}{Nutzung von Positiv- und Negativ-Liste}^^A
% \begin{macro}{\tud@todo@num}
% \changes{v2.07}{2021/06/09}{neu}^^A
% \begin{macro}{\tud@todo@type@use}
% \changes{v2.06}{2018/08/02}{neu}^^A
% \begin{macro}{\tud@todo@type@default}
% \changes{v2.07}{2021/06/09}{neu}^^A
% \begin{macro}{\tud@todo@type@set}
% \changes{v2.07}{2021/06/09}{neu}^^A
% Mit dieser Option wird gesteuert, ob und welche ToDo-Notizen ausgegeben 
% werden sollen.
%    \begin{macrocode}
\tud@newcount\tud@todo@num
\newcommand*\tud@todo@type@use{}
\newcommand*\tud@todo@type@default{}
\forcsvlist{\listadd\tud@todo@type@default}{rls,imp,doc,default}
\TUD@key{ToDo}[true]{%
  \TUD@set@numkey{ToDo}{@tempa}{%
    \TUD@bool@numkey,{inline}{1},{noinline}{2}%
  }{#1}%
%    \end{macrocode}
% Wird der Option ein gültiger Wert übergeben, werden alle definerten Typen der 
% ToDo-Notizen ausgegeben.
%    \begin{macrocode}
  \ifx\FamilyKeyState\FamilyKeyStateProcessed%
    \tud@todo@num=\@tempa\relax%
    \let\tud@todo@type@use\tud@todo@type@default%
  \else%
%    \end{macrocode}
% Außerdem kann für einen spezifischen Typen einer ToDo-Notiz bestimmt werden, 
% ob dieser ausschließlich ausgegeben (\opt{ToDo=\{only=\meta{Typ}\}}) oder 
% unterdrückt (\opt{ToDo=\{not=\meta{Typ}\}}) wird.
%    \begin{macrocode}
    \begingroup%
      \tud@lowerstring\tud@res@a{#1}%
      \protected@expandtwoargs\in@{=}{\tud@res@a}%
      \ifin@%
        \def\tud@res@b##1=##2\@nil{%
          \IfArgIsEmpty{##2}{\def\tud@res@a{default}}{\def\tud@res@a{##2}}%
          \tud@if@strequal{only}{##1}{\let\tud@res@c\z@}{%
          \tud@if@strequal{not}{##1}{\let\tud@res@c\@ne}{%
            \let\tud@res@c\m@ne%
          }}%
        }%
        \expandafter\tud@res@b\tud@res@a\@nil%
        \let\tud@res@b\relax%
        \ifcase\tud@res@c\relax% only
          \tud@todo@type@set[\tud@res@b]{\tud@res@a}%
        \or% not
          \tud@todo@type@set*[\tud@res@b]{\tud@res@a}%
        \fi%
        \ifx\tud@res@b\relax\else%
          \ifx\tud@res@b\@empty%
            \FamilyKeyStateProcessed%
          \else%
            \ClassError{tudscrmanual}{Wrong ToDo type(s) `\tud@res@b'}{%
              The given type(s) %
              `ToDo={\ifcase\tud@res@c only\or not\fi=\tud@res@b}' %
              are invalid.%
            }%
          \fi%
        \fi%
      \else%
        \let\tud@res@b\@empty%
        \let\tud@res@c\@empty%
        \@for\tud@res@a:=\tud@res@a\do{%
          \trim@spaces@in\tud@res@a%
          \ifx\tud@res@a\@empty\else%
            \xifinlist{\tud@res@a}{\tud@todo@type@default}{%
              \protected@eappto\tud@res@b{,\tud@res@a}%
            }{%
              \protected@eappto\tud@res@c{,\tud@res@a}%
            }%
          \fi%
        }%
        \ifx\tud@res@b\@empty\else%
          \FamilyKeyStateProcessed%
          \edef\tud@res@a{%
            \noexpand\TUDoption{ToDo}{{{{only=\expandonce\tud@res@b}}}}%
            \ifx\tud@res@c\@empty\else%
              \noexpand\AtEndOfFamilyOptions*{%
                \noexpand\TUDoption{ToDo}{\expandonce\tud@res@c}%
              }%
            \fi%
          }%
          \tud@res@a%
        \fi%
      \fi%
      \edef\tud@res@a{%
        \endgroup%
        \unexpanded{\def\tud@todo@type@use}{\expandonce\tud@todo@type@use}%
        \ifx\FamilyKeyState\FamilyKeyStateProcessed%
          \noexpand\FamilyKeyStateProcessed%
        \else%
          \tud@todo@num=\z@\relax%
        \fi%
      }%
    \tud@res@a%
  \fi%
}
\NewDocumentCommand\tud@todo@type@set{s o m}{%
  \begingroup%
    \protected@edef\tud@res@a{#3}%
    \IfBooleanTF{#1}{%
      \let\tud@todo@type@use\tud@todo@type@default%
      \def\tud@res@b{\listeremove\tud@todo@type@use}%
    }{%
      \let\tud@todo@type@use\@empty%
      \def\tud@res@b{\tud@unique@eadd\tud@todo@type@use}%
    }%
    \let\tud@res@c\@empty%
    \@for\tud@res@a:=\tud@res@a\do{%
      \trim@spaces@in\tud@res@a%
      \ifx\tud@res@a\@empty\else%
        \TUD@set@numkey{ToDo}{@tempa}{%
          {rls}{0},{imp}{1},{doc}{2},{default}{3}%
        }{\tud@res@a}%
        \ifx\FamilyKeyState\FamilyKeyStateProcessed%
          \tud@res@b{\tud@res@a}%
        \else%
          \protected@eappto\tud@res@c{\ifx\tud@res@c\@empty\else,\fi\tud@res@a}%
        \fi%
      \fi%
    }%
    \edef\tud@res@a{%
      \endgroup%
      \unexpanded{\def\tud@todo@type@use}{\expandonce\tud@todo@type@use}%
      \IfValueT{#2}{\unexpanded{\def#2}}{\expandonce\tud@res@c}%
    }%
  \tud@res@a%
}
\TUDExecuteOptions{ToDo=true}
%    \end{macrocode}
% \end{macro}^^A \tud@todo@type@set
% \end{macro}^^A \tud@todo@type@default
% \end{macro}^^A \tud@todo@type@use
% \end{macro}^^A \tud@todo@num
% \end{option}^^A ToDo
%
% \iffalse
%</option>
%<*body>
% \fi
%
% Laden des Paketes und minimale Breite der Randnotiz.
%    \begin{macrocode}
\RequirePackage{todonotes}[2021/06/04]
\AtEndPreamble{%
  \ifdim\marginparwidth<2cm\relax%
    \tud@setdim\marginparwidth{2cm}%
  \fi%
}
%    \end{macrocode}
% Sollte das Paket \pkg{todonotes} nicht geladen werden, erfolgt die Definition 
% der beiden nachfolgend implemtierten Befehle als Dummy.
%    \begin{macrocode}
\TUD@UnwindPackage{todonotes}{%
  \RenewDocumentCommand\ToDo{s o m !o}{}%
  \renewcommand*\ListOfToDo{}%
}
%    \end{macrocode}
%
% \begin{macro}{\ToDo}
% \changes{v2.02}{2014/07/10}{Verwendung von \pkg{todonotes}}^^A
% \changes{v2.03}{2015/01/25}{Ausgabe auf bestimmten Typ beschränkbar}^^A
% \changes{v2.05}{2015/11/02}{Farbkodierung durch optionale Versionsnummer}^^A
% \changes{v2.06}{2018/08/02}{farbige Ausgabe abhängig von Versionsnummer}^^A
% \begin{macro}{\@ToDo}
% \changes{v2.07}{2021/06/09}{neu}^^A
% \begin{macro}{\ListOfToDo}
% \changes{v2.02}{2014/07/10}{neu}^^A
% Mit dem Befehl \cs{ToDo}\oarg{Option}\marg{ToDo-Notiz}\oarg{Versionsnummer}
% kann bei aktivierter Option \opt{ToDo} eine Notiz mit einer offenen Aufgabe
% erstellt werden. Das erste optionale Argument kann die Kategorisierungstypen
% \val{doc}, \val{imp} und \val{rls} beinhalten, welche für eine spezifische
% farbliche Kodierung sorgen, um die Aufgaben zu kategorisieren.
%
% Nun folgt die Definition des eigentlichen Befehls. Dabei wird zu Beginn
% \cs{@currentHref} gesichert und am Ende wiederhergestellt.
% \ToDo{\texttt{s o D()\{default\} m}; auch für \cls{tudscrdoc}}[v2.07]
%    \begin{macrocode}
\NewDocumentCommand\ToDo{s O{default} m !o}{%
  \ifnum\tud@todo@num>\z@\relax%
    \global\let\tud@currentHref\@currentHref%
    \begingroup%
%    \end{macrocode}
% Die Ausgabe erfolgt entweder für die per Option in \cs{tud@todo@type@use} 
% festgelegten Eintragstypen oder speziell für die im optionalen Argument 
% angegebenen. Hierfür wird \opt{ToDo=\{only=\meta{\dots}\}} für das optionale
% Argument lokal ausgeführt und anschließend mit der zuvor gesicherten globalen
% Liste eine Schnittmenge gebildet.
%    \begin{macrocode}
      \begingroup%
        \let\tud@res@a\tud@todo@type@use%
        \let\tud@res@b\@empty%
        \def\tud@res@c##1{%
          \ifinlist{##1}{\tud@res@a}{\listadd\tud@res@b{##1}}{}%
        }%
        \TUDoptions{ToDo={only={#2}}}%
        \forlistloop\tud@res@c{\tud@todo@type@use}%
        \edef\tud@res@c{%
          \endgroup%
          \unexpanded{\def\tud@todo@type@use}{\expandonce\tud@res@b}%
        }%
      \tud@res@c%
      \ifx\tud@todo@type@use\@empty\else%
%    \end{macrocode}
% Wenn mindestens ein aktiver Kategorisierungstyp gefunden wurde, werden in 
% temporären Makros die Versionsangabe (\cs{tud@res@a}) sowie die Einstellungen 
% zur farbige Ausprägung der ToDo-Notiz (\cs{tud@res@b}) gespeichert.
%    \begin{macrocode}
        \edef\tud@res@a{\TUDScriptVersionNumber}%
%    \end{macrocode}
% Der Kategorisierungstyp für Releases \val{rls} ist quasi vorkonfiguriert. 
% Sind weitere Kategorisierungstypen angegeben, werden diese ignoriert. Der Typ 
% für Implemtierung \val{imp} wird vorangig zur Dokumentation \val{doc} 
% behandelt.
%    \begin{macrocode}
        \ifinlist{rls}{\tud@todo@type@use}{%
          \IfValueT{#4}{%
            \ClassWarning{tudscrmanual}{`rls' implies current version}%
          }%
          \def\tud@res@c{HKS44}%
        }{%
          \IfValueT{#4}{\protected@edef\tud@res@a{#4}}%
          \ifinlist{imp}{\tud@todo@type@use}{%
            \def\tud@res@c{HKS57}%
          }{%
            \ifinlist{doc}{\tud@todo@type@use}{%
              \def\tud@res@c{HKS33}%
            }{%
              \def\tud@res@c{HKS92}%
            }%
          }%
        }%
%    \end{macrocode}
% Das optionale Argument erzeugt zusätzlich eine Notiz am Rand, in welcher
% vorzugsweise die angedachte Version eingetragen werden kann. Sollte 
% dieses angegeben sein, wird auf eine gültige Versionsnummer geprüft.
%    \begin{macrocode}
        \begingroup%
          \tud@v@to@number*\tud@res@b{\tud@res@a}%
%    \end{macrocode}
% Die Ausprägung der ToDo-Notiz wird in Abhängigkeit von der gefundenen 
% Versionsnummer im Vergleich zur gerade aktuellen Version gestaltet.
%    \begin{macrocode}
          \ifx\tud@res@b\relax%
            \tud@res@cnt=1%
          \else%
            \tud@v@to@number\tud@res@c{\TUDScriptVersionNumber}%
            \ifnum\tud@res@b<\tud@res@c\relax%
              \tud@res@cnt=0%
            \else%
              \ifnum\tud@res@b>\tud@res@c\relax%
                \tud@res@cnt=3%
              \else%
                \tud@res@cnt=2%
              \fi%
            \fi%
          \fi%
%    \end{macrocode}
% Die~-- gegebenfalls korrigerte~-- Randnotiz (\cs{tud@res@a}) sowie die 
% farbliche Ausprägung (\cs{tud@res@b}) werden expandiert. Die zu verwendende 
% Farbe selbst ist nach der Gruppe weiterhin in \cs{tud@res@c} abgelegt.
%    \begin{macrocode}
          \edef\tud@res@c{%
            \endgroup%
            \unexpanded{\def\tud@res@a}{\tud@res@a}%
            \unexpanded{\edef\tud@res@b}{%
              \ifcase\tud@res@cnt% < current version
                color=\noexpand\tud@res@c,%
                bordercolor=HKS07!80,%
                textcolor=white,%
                inlinewidth=\linewidth - 2pt%
              \or% no version
                color=\noexpand\tud@res@c!15,%
                bordercolor=HKS07!50%
              \or% = current version
                color=\noexpand\tud@res@c!60,%
                bordercolor=\noexpand\tud@res@c%
              \or% > current version
                color=\noexpand\tud@res@c!30,%
                bordercolor=\noexpand\tud@res@c%
              \else% undefined state
                color=HKS07!80,%
                textcolor=\noexpand\tud@res@c%
              \fi%
            }%
%    \end{macrocode}
% Die Inhalte werden zentriert gesetzt. Für überfällige ToDo-Notizen wird 
% zusätzlich die Linienstärke erhöht.
%    \begin{macrocode}
            \unexpanded{\tikzset{notestyleraw/.append style={align=center}}}%
            \ifcase\tud@res@cnt\relax%
              \unexpanded{%
                \tikzset{notestyleraw/.append style={%
                  line width = 2pt,%
                  text width = \@todonotes@textwidth - 1.6ex - 2pt,%
                  inner sep  = 0.8ex%
                }}%
              }%
            \fi%
          }%
        \tud@res@c%
%    \end{macrocode}
% Vor der Ausgabe wird ggf. ein kleiner vertikaler Abstand eingefügt.
%    \begin{macrocode}
        \ifnum\tud@todo@num=\tw@\relax%
          \let\@todonotes@drawInlineNote\relax%
        \else%
          \ifhmode\strut\par\fi%
          \let\par\relax%
          \vskip\glueexpr\smallskipamount/2\relax%
          \noindent%
        \fi%
%    \end{macrocode}
% Dann erfolgt die Ausgabe der eigentlichen ToDo-Notiz im Textbereich. Die 
% Sternversion von \cs{ToDo} unterdrückt dabei die Aufnahme in die ToDo-Liste.
%    \begin{macrocode}
        \edef\tud@res@c{\tud@res@b,inline\IfBooleanT{#1}{,nolist}}%
        \sbox\z@{\@ToDo{\tud@res@c}{#3}}\usebox\z@%
%    \end{macrocode}
% Es folgt die dazugehörige Randnotiz. Damit diese nicht verrutscht, wird
% \cs{marginnote} anstelle von \cs{marginpar} verwendet. Wurde das angestellte
% optionale Argument verwendet, wird dieses für die Randnotiz genutzt.
% Andernfalls erscheint im Rand die Anmerkung \emph{ToDo}.
%    \begin{macrocode}
        \renewcommand*\marginpar[2][]{%
          \marginnote[{##1}]{##2}[\dimexpr\ht\strutbox-\ht\z@-\dp\z@\relax]%
        }%
        \edef\tud@res@c{\tud@res@b,noline,nolist}%
        \@ToDo{\tud@res@c}{\tud@res@a}%
        \ifnum\tud@todo@num=\tw@\relax\else%
          \aftergroup\par\aftergroup\noindent%
        \fi%
      \fi%
    \endgroup%
    \global\let\@currentHref\tud@currentHref%
  \fi%
  \ignorespaces%
}
%    \end{macrocode}
% Hilfmakro zur Ausführung des Befehle \cs{todo} aus dem Paket \pkg{todonotes}.
%    \begin{macrocode}
\newcommand*\@ToDo[2]{%
  \expandafter\todo\expandafter[\expandafter{#1}]{\trim@spaces{#2}\strut}%
}
%    \end{macrocode}
% Zum Schluss wird der Befehl \cs{ListOfToDo} definiert, der die Liste der noch 
% zu erledigenden Punkte ausgibt.
%    \begin{macrocode}
\newcommand*\ListOfToDo{%
  \ifnum\tud@todo@num>\z@\relax\cleardoublepage\listoftodos\fi%
}
%    \end{macrocode}
% \end{macro}^^A \ListOfToDo
% \end{macro}^^A \@ToDo
% \end{macro}^^A \ToDo
%
%
% \subsection{Erstellung und Validierung von Labeln}
%
% \begin{macro}{\tud@lbl@tmp}
% \changes{v2.05}{2015/11/03}{neu}^^A
% \begin{macro}{\tud@lbl@fmt}
% \changes{v2.05}{2015/11/03}{neu}^^A
% In \cs{tud@lbl@tmp} werden nachfolgend die durch \cs{tud@lbl@get} oder 
% \cs{tud@attr@get} erzeugten (Sub-)Label gespeichert. Mit dem Hilfsmakro 
% \cs{tud@lbl@fmt} wird innerhalb der beiden Befehle \cs{Processor@CreateLabel} 
% und \cs{tud@lbl@get@@curr} dafür gesorgt, dass geschützte Leerzeichen sowie
% eingabekodierungsabhängige Zeichen korrekt für ein Label umgesetzt werden.
% Auch durch \cs{NoCaseChange} in Überschriften geschützte Inhalte werden 
% direkt übernommen.
%    \begin{macrocode}
\newcommand*\tud@lbl@tmp{}
\newcommand*\tud@lbl@fmt{%
  \def~{-}%
  \let\IeC\@firstofone%
  \def\"##1{##1e}%
  \def\ss{ss}%
  \def\dots{...}%
  \let\NoCaseChange\@firstofone%
}
%    \end{macrocode}
% \end{macro}^^A \tud@lbl@fmt
% \end{macro}^^A \tud@lbl@tmp
% \begin{macro}{\Processor@CreateLabel}
% \changes{v2.05}{2015/11/03}{neu}^^A
% \begin{macro}{\Processor@@CreateLabel}
% \changes{v2.05}{2015/11/03}{neu}^^A
% Mit dem Argumentprozessor \cs{Processor@CreateLabel} wird es ermöglicht, an 
% die Befehle \cs{tud@lbl@get} und \cs{tud@if@lbl@exists} sowohl ein bereits 
% formatiertes Label als auch einen Markup-Befehl mit einem Entitätpräfix zu
% übergeben. In beiden Fällen wird aus dem Argument ein eindeutiges Label in
% der Form \meta{Entitätpräfix}|:|\meta{Labelpräfix}|:|\meta{Element} generiert
% und als resultierendes Argument an das aufrufenden Makro übergeben.
%
% Es gibt zwei verschiedene Varianten der Übergabe eines Argumentes an den
% Argumentprozessor \cs{Processor@CreateLabel}.
% \begin{description}\let\itshape\slshape
%   \item[\cs{Processor@CreateLabel}]
%   |{\Class/\Package/\Bundle|\marg{\dots}|:\Markup|\marg{Element}|}|\newline^^A
%     Das Label soll für ein Markupelement generiert werden. 
%     Dabei wurde explizit ein Paket, eine Klasse oder ein Bundle angegeben 
%     respektive implizit das Makro \cs{tud@bdl@curr} als Argument verwendet,
%     welches innerhalb der Umgebungen \env{Entity} und \env{DeclareEntity}
%     auf die aktuell beschriebene Entität gesetzt wurde.
%   \item[\cs{Processor@CreateLabel}]
%   |{|\meta{Entitätpräfix}|:|\meta{Labelpräfix}|:|\meta{Element}|}|\newline^^A
%     Das Label ist bereits vollständig bestimmt und die Argumente werden 
%     entweder als String oder als Markup übergeben. Auch Mischformen sind 
%     möglich. In diesem Fall wird es einfach wieder zusammengesetzt. Diese
%     Variante tritt auch durch rekursiven Aufruf des Argumentprozessors auf.
% \end{description}
%    \begin{macrocode}
\newcommand*\Processor@CreateLabel[1]{%
%^^A  \in@{:}{#1}%
%^^A  \ifin@\else%
%^^A%<*class>
%^^A    \ClassError{tudscrmanual}%
%^^A%</class>
%^^A%<*package>
%^^A    \PackageError{tudscrtutorial}%
%^^A%</package>
%^^A    {Wrong formatted label}{%
%^^A      A label must be given at least with '<bundle>:<markup>'\MessageBreak%
%^^A      but \detokenize{#1} was used.%
%^^A    }%
%^^A  \fi%
  \SplitArgument{2}{:}{#1}%
  \expandafter\Processor@@CreateLabel\ProcessedArgument%
}
\newcommand*\Processor@@CreateLabel[3]{%
  \begingroup%
%    \end{macrocode}
% Zu Beginn werden die Markup-Befehle auf ihre expandierbaren Varianten gesetzt 
% und die zusätzlichen Redefinitionen für die Labelgenerierung aktiviert.
%    \begin{macrocode}
    \Markup@Expandable%
    \tud@lbl@fmt%
%    \end{macrocode}
% Sind alle drei Bestandteile bereits vorhanden, wird das Label einfach wieder
% zusammengesetzt.
%    \begin{macrocode}
    \IfValueTF{#3}{%
      \protected@edef\@tempa{#1:#2:#3}%
    }{%
%    \end{macrocode}
% Hier geschieht die eigentliche Erzeugung der Labels. Dabei wird mit 
% \cs{tud@attr@get} der für den jeweiligen Markup-Befehl aus dem zweiten
% obligatorischen Argument spezifische Labelpräfix generiert. Abhängig davon,
% ob im ersten obligatorischen Argument ein spezieller Entitätpräfix angegeben
% wurde, wird dieser entweder verwendet oder aber implizit auf den Inhalt aus
% \cs{tud@bdl@dflt} zurückgegriffen.
%    \begin{macrocode}
      \IfValueTF{#2}{%
        \tud@attr@get\@tempb{#2}%
        \IfValueTF{#1}{%
          \ifxblank{#1}{%
            \protected@edef\@tempa{\tud@bdl@dflt:\@tempb:#2}%
          }{%
            \protected@edef\@tempa{#1:\@tempb:#2}%
          }%
        }{%
          \protected@edef\@tempa{\tud@bdl@curr:\@tempb:#2}%
        }%
      }{%
%    \end{macrocode}
% Wurde lediglich ein Makro angegeben, wird dieses einfach expandiert.
%    \begin{macrocode}
        \protected@edef\@tempa{#1}%
      }%
    }%
%    \end{macrocode}
% Das Ergebnis der Labelgenrierung wurde für alle der behandelten Fälle in 
% \cs{@tempa} geschrieben. Abschließnd wird \cs{ProcessedArgument} nach der 
% Gruppe mit dessen Inhalt definiert. Dabei werden bei der Expansion die 
% catcodes aller Zeichen in Tokens der Klasse \val{other} gewandelt, um diese 
% später sicher vergleichen zu können.
%    \begin{macrocode}
    \protected@edef\@tempc{%
      \noexpand\endgroup%
      \def\noexpand\ProcessedArgument{%
        \expandafter\detokenize\expandafter{\@tempa}%
      }%
    }%
  \@tempc%
}
%    \end{macrocode}
% \end{macro}^^A \Processor@@CreateLabel
% \end{macro}^^A \Processor@CreateLabel
% \begin{macro}{\tud@lbl@get}
% \changes{v2.05}{2015/11/03}{neu}^^A
% \begin{macro}{\tud@lbl@get@@curr}
% \changes{v2.05}{2015/11/03}{neu}^^A
% Für \cs{tud@lbl@get} wird das zweite obligatorische Argument für gewöhnlich
% in der Form |\Class/\Package/\Bundle|\marg{\dots}|:\Markup|\marg{Element}
% gegeben und mit dem Argumentprozessor \cs{Processor@CreateLabel} in die Form
% \meta{Entitätpräfix}|:|\meta{Labelpräfix}|:|\meta{Element} gewandelt.
%    \begin{macrocode}
\NewDocumentCommand\tud@lbl@get{s m >{\Processor@CreateLabel}m d==}{%
%    \end{macrocode}
% Mit \cs{tud@lbl@get@@curr} wird das im zweiten obligatorischen Argument 
% (|#3|) generierte Label in das im ersten obligatorischen Argument |#2|
% angegebenen Makro gespeichert und ggf. diesem das letzte optionale Argument
% für einen speziellen Wert zu einem Schlüssel angehangen.
%    \begin{macrocode}
  \tud@lbl@get@@curr#2{#3}=#4=%
%    \end{macrocode}
% Die Sternversion von \cs{tud@lbl@get} wird für das Definieren von Labeln bei
% Deklarationen etc. genutzt. Sollte diese verwendet worden sein, ist die 
% Generierung beendet.
%    \begin{macrocode}
%<*class>
  \IfBooleanF{#1}{%
%    \end{macrocode}
% Andernfalls wird geprüft, ob das erstellte Label überhaupt existiert. Sollte 
% das nicht der Fall sein, wird ein passendes Label für den gegebenen Schlüssel 
% ohne speziellen Wert gesucht.
%    \begin{macrocode}
    \@tempswafalse%
    \tud@if@lbl@exists{#2}{%
      \@tempswatrue%
    }{%
      \IfValueT{#4}{%
        \tud@lbl@get@@curr\tud@reserved{#3}%
        \tud@if@lbl@exists{\tud@reserved}{%
          \let#2\tud@reserved%
          \@tempswatrue%
        }{}%
      }%
    }%
%    \end{macrocode}
% Wurde auch danach noch kein passendes Label gefunden, gibt es u.\,U. eine 
% letzte Möglichkeit, ein passendes Label zu finden. Wird in der Dokumentation 
% gerade ein/e Bundle, Paket oder Klasse respektive eine sich von den 
% Hauptklassen unterscheidende Klasse oder ein Paket aus dem \TUDScript-Bundle
% erläutert (Umgebungen \env{Entity}, \env{DeclareEntity}), so wird
% eventuell auf ein Element aus ebendiesen Hauptklassen referenziert. In diesem
% Fall wird \cs{tud@lbl@get@dflt} aufgerufen, um den Entitätpräfix für das 
% Label entsprechend zu setzen.
%    \begin{macrocode}
    \if@tempswa\else%
      \tud@if@bdl{\tud@lbl@get@dflt#2{#3}=#4=}{}%
    \fi%
  }%
%</class>
}
%    \end{macrocode}
% Mit \cs{tud@lbl@get@@curr} wird das generierte Label in Makro gespeichert, 
% welches beim Aufruf von \cs{tud@lbl@get} angegebenen wurde.
%    \begin{macrocode}
\NewDocumentCommand\tud@lbl@get@@curr{m m d==}{%
  \def#1{#2}%
%    \end{macrocode}
% Sollte optional mit \cs{PValue} bzw. \cs{PValueName} ein spezieller Wert für
% einen Schlüssel übergeben worden sein, wird dieser ggf. angehängt.
%    \begin{macrocode}
  \tud@doifPValue[\tud@lbl@fmt]{#3}{\noexpand\appto\noexpand#1{=#3}}%
}
%    \end{macrocode}
% \end{macro}^^A \tud@lbl@get@@curr
% \end{macro}^^A \tud@lbl@get
% \begin{macro}{\tud@lbl@get@dflt}
% \changes{v2.05}{2015/11/04}{neu}^^A
% \begin{macro}{\tud@lbl@get@@dflt}
% \changes{v2.05}{2015/11/04}{neu}^^A
% Diese beiden Makros werden genutzt, um mit \cs{tud@lbl@get} innerhalb der
% Umgebungen \env{Entity} und \env{DeclareEntity} für den Fall, dass ein
% gesuchtes Label für die aktuelle Entität nicht existiert, nach diesem
% Element in den existierenden Labels der Hauptklassen zu suchen.
%
% Dabei wird das bereits generierte Label durch \cs{tud@lbl@get@dflt} in 
% seine drei Hauptbestandteile zur Weiterverarbeitung zerlegt.
%    \begin{macrocode}
\NewDocumentCommand\tud@lbl@get@dflt{m >{\SplitArgument{2}{:}}m r==}{%
  \tud@lbl@get@@dflt{#1}#2=#3=%
}
%    \end{macrocode}
% Durch \cs{tud@lbl@get@@dflt} wird als erstes geprüft, ob der Entitätpräfix 
% bereits dem Standardpräfix für die Hauptklassen entspricht. Nur wenn dies 
% nicht der Fall ist, wird die Labelgenerierung abermals ausgeführt.
%    \begin{macrocode}
\NewDocumentCommand\tud@lbl@get@@dflt{m m m m r==}{%
  \edef\tud@reserved{\expandafter\detokenize\expandafter{\tud@bdl@dflt}}%
  \Ifstr{\tud@reserved}{#2}{}{%
%    \end{macrocode}
% Dabei erfolgt der Aufruf logischerweise mit dem richtigen Entitätpräfix. 
%    \begin{macrocode}
    \tud@lbl@get\tud@reserved{\tud@bdl@dflt:#3:#4}=#5=%
    \tud@if@lbl@exists{\tud@reserved}{\let#1\tud@reserved}{}%
  }%
}
%    \end{macrocode}
% \end{macro}^^A \tud@lbl@get@@dflt
% \end{macro}^^A \tud@lbl@get@dflt
% \begin{macro}{\tud@if@lbl@exists}
% \changes{v2.05}{2015/11/05}{neu}^^A
% Mit dem Befehl \cs{tud@if@lbl@exists} wird die Existenz eines Labels in der 
% Form \meta{Entitätpräfix}|:|\meta{Labelpräfix}|:|\meta{Element} geprüft. 
% Je nachdem, ob ein existierendes Label gefunden wird oder nicht, wird das
% zweite oder das dritte obligatorische Argument ausgeführt.
%    \begin{macrocode}
\newcommand*\tud@if@lbl@exists[3]{%
  \begingroup%
    \protected@edef\tud@res@a{%
      \endgroup%
      \noexpand\ifcsundef{r@#1}%
    }%
  \tud@res@a{#3}{#2}%
}
%    \end{macrocode}
% \end{macro}^^A \tud@if@lbl@exists
%
% \subsection{Namensraum für unterschiedliche Entitäten}
%
% Um eventuell identisch benannte Befehle und die dazu passenden Indexeinträge 
% für unterschiedliche Bundle, Pakete oder Klassen zu ermöglichen, wird ein
% Namensraum für diese eingeführt.
%
% \begin{environment}{Entity}
% \changes{v2.05}{2015/11/01}{neu}^^A
% \begin{macro}{\tud@bdl@curr}
% \changes{v2.05}{2015/08/04}{neu}^^A
% \begin{macro}{\tud@bdl@dflt}
% \changes{v2.05}{2015/11/01}{neu}^^A
% \begin{macro}{\tud@if@bdl}
% \changes{v2.05}{2015/08/04}{neu}^^A
% Diese Makros werden für das Definieren eines Entitätelements und ggf. das 
% Prüfen des selbigen benötigt.
% \ToDo{Suffixe wie Klasse, Paket etc. lokalisieren (locale)}[v2.??]
%    \begin{macrocode}
\newcommand*\tud@bdl@dflt{tudscr}
\newcommand*\tud@bdl@curr{}
\let\tud@bdl@curr\tud@bdl@dflt
\newcommand*\tud@if@bdl[2]{\Ifstr{\tud@bdl@curr}{\tud@bdl@dflt}{#2}{#1}}
%    \end{macrocode}
% Die Umgebung \env{Entity} kann nicht verschachtelt werden und prüft zuerst 
% dementsprechend die Verwendung. Anschließend wird lediglich das Makro 
% \cs{tud@bdl@curr} auf das übergebene Argument gesetzt, um innerhalb der 
% Umgebung erstellte Label und Indexeinträge zu beeinflussen.
%    \begin{macrocode}
\newenvironment{Entity}[1]{%
  \tud@if@bdl{%
%<*class>
    \ClassError{tudscrmanual}%
%</class>
%<*package>
    \PackageError{tudscrtutorial}%
%</package>
      {Nested environment `Entity'}{%
      It is not possible to nest this environment, when\MessageBreak%
      a cross-label was given before.%
    }%
  }{%
    \in@{,}{#1}%
    \ifin@%
%<*class>
      \ClassError{tudscrmanual}%
%</class>
%<*package>
      \PackageError{tudscrtutorial}%
%</package>
      {Multiple values for environment `Entity'}{%
        Multiple elements are prohibited within the argument.%
      }%
    \else%
      \gdef\tud@bdl@curr{#1}%
    \fi%
  }%
  \ignorespaces%
}{%
  \global\let\tud@bdl@curr\tud@bdl@dflt%
  \aftergroup\ignorespaces%
}
%    \end{macrocode}
% \end{macro}^^A \tud@if@bdl
% \end{macro}^^A \tud@bdl@dflt
% \end{macro}^^A \tud@bdl@curr
% \end{environment}^^A Entity
%
% \iffalse
%<*class>
% \fi
%
% \subsection{Deklarationsumgebungen für die Klasse \cls{tudscrmanual}}
%
% Die Umgebungen \env{Declaration} und \env{Declaration*} sowie \env{Obsolete}
% und \env{Entity} werden für die Beschreibung von Optionen, Umgebungen,
% Befehlen etc. verwendet, welche von \TUDScript oder einer anderen Entität dem
% Anwender zur Verfügung gestellt werden.
%
% \begin{macro}{\if@tud@declare}
% \begin{macro}{\tud@declare@num}
% \changes{v2.05}{2015/11/01}{neu}^^A
% \begin{macro}{\if@tud@openindex}
% Dies sin ein paar Hilfsmakros zur Steuerung des Markup sowie der Ausgabe von
% Deklarationen, Index und Änderungsliste, welche bei den nächsten Befehlen und 
% Umgebungen genutzt werden. Mit \cs{if@tud@declare} wird festgelegt, ob die
% Befehle für das Markup in der Ausgabe als Deklaration oder anderweitig
% erfolgt. Zusätzlich wird mit \cs{tud@declare@num} definiert, wie genau das 
% Markup sich darstellen soll. Die möglichen Werte sind bei der Beschreibung
% von \cs{Process@@MarkupDeclare} zu finden. Der Schalter \cs{if@tud@openindex} 
% wird zu Beginn einer Deklaration auf \val{true} gesetzt und vor dem Beenden
% auf \val{false}. Damit wird bestimmt, ob ein öffnender oder ein schließender
% Indexeintrag erzeugt werden soll.
%    \begin{macrocode}
\tud@newif\if@tud@declare
\tud@newcount\tud@declare@num
\tud@newif\if@tud@openindex
%    \end{macrocode}
% \end{macro}^^A \if@tud@openindex
% \end{macro}^^A \tud@declare@num
% \end{macro}^^A \if@tud@declare
% \begin{environment}{Declaration}
% \begin{environment}{Obsolete}
% \changes{v2.05}{2015/11/01}{neu}^^A
% \begin{macro}{\tud@alias@values}
% \changes{v2.07}{2019/11/08}{neu}^^A
% \begin{macro}{\tud@declaration@list}
% \begin{macro}{\if@tud@obsolete}
% \changes{v2.05}{2015/11/01}{neu}^^A
% Es werden einige Hilfsmakros für die Ausgabe einer Deklaration sowie der 
% dazugehörigen Änderungsliste initialisiert.
%    \begin{macrocode}
\newcommand*\tud@declaration@list{}
\let\tud@declaration@list\relax
%    \end{macrocode}
% Die \env{Declaration}-Umgebung dient zur Deklaration von Optionen, Umgebungen,
% Befehlen, Parametern, Bezeichnern, Längen, Schriftelementen und Farben. Diese 
% werden mit den entsprechenden Auszeichnungsbefehlen als obligatorisches 
% Argument übergeben. Zuvor kann noch vorher im ersten optionalen Argument eine
% Beschreibung für die Änderungsliste in der Form \oarg{Verison!Beschreibung}
% angegeben werden. Danach kann im dritten Argument~-- das zweite optionale~-- 
% die Voreinstellung für eine Option oder dergleichen angegeben werden. Das
% nächste optionale Argument erlaubt die Angabe einer bedingten Voreinstellung, 
% also einer anderen Voreinstellung als der zuerst angegeben unter bestimmten
% Voraussetzungen. Diese wird in der Form \oarg{Bedingung:Voreinstellung}
% angegeben. Das letzte Argument ist ebenfalls optional, wird aber in der Form
% \marg{Zusatz} angegeben und enthält ggf. zusätzliche Informationen.
%
% Die Umgebung \env{Obsolete} hat eine ganz ähnliche Funktion, wird allerdings
% für die Deklaration veralteter Befehle, Umgebungen, Optionen etc. verwendet.
% Da sich beide Umgebungen stark ähneln, werden zum Start bzw. zum Abschluss
% die Makros \cs{tud@declare@start} bzw. \cs{tud@declare@end} aufgerufen. Zu 
% Beginn wird nichts weiter ausgegeben sondern lediglich alle übergebenen
% Argumente in jeweiligen Listen gesammelt. Die eigentliche Ausgabe der 
% Deklaration erfolgt mit dem Befehl \cs{printdeclarationlist} bezieungsweise 
% \cs{printobsoletelist}. 
%    \begin{macrocode}
\newcommand*\tud@alias@values{\@nil}
\NewDocumentEnvironment{Declaration}{o m o o d() D<>{\noexpand\@nil}}{%
  \listeadd\tud@declaration@list{%
    \def\noexpand\tud@alias@values{#6}%
    \unexpanded{#2}%
  }%
  \tud@declare@start[{#1}]{#2}[{#3}][{#4}](#5)%
}{%
  \tud@declare@end{#2}{\printdeclarationlist}%
}
%    \end{macrocode}
% Für die Umgebung \env{Obsolete} sieht die Eingabe etwas anders aus. Das erste 
% obligatorische Argument sollte eine Versionsnummer enthalten, ab wann die 
% Deklaration veraltet ist. Das erste optionale Argument wird genutzt, wenn 
% für eine weiterhin gültige Deklaration lediglich ein bestimmter Wert 
% entfällt. Wird das erste Argument leer gelassen, erfolgt lediglich die 
% Ausgabe der Deklaration ohne einen Eintrag in die Änderungsliste. Dies ist 
% für Umgebungen und Befehle gedacht, bei denen lediglich ein oder mehrere 
% Parameter geändert wurden bzw. entfallen.
%    \begin{macrocode}
\tud@newif\if@tud@obsolete
\NewDocumentEnvironment{Obsolete}{m o m o o d()}{%
  \@tud@obsoletetrue%
  \ifxblank{#1}{%
%    \end{macrocode}
% Ohne Versionsnummer erfolgt die Ausgabe ohne Label. Für den Eintrag wird auch 
% keine Änderungsnotiz erzeugt.
%    \begin{macrocode}
    \listadd\tud@declaration@list{%
      \tud@declare@num=\@ne\relax%
      #3%
      \tud@declare@num=\z@\relax%
    }%
    \tud@declare@start{#3}[{#4}][{#5}](#6)%
  }{%
    \listadd\tud@declaration@list{#3}%
%    \end{macrocode}
% Wurde ein optionales Argument angegeben, bezieht sich der Änderungseintrag 
% auf ebendieses Argument, die eigentliche, obsolete Deklaration wird als 
% Untereintrag genutzt.
%    \begin{macrocode}
    \IfValueTF{#2}{%
      \Changed@At@CreateList{#1!#3}[{#2}]%
    }{%
      \Changed@At@CreateList{#1}[{#3}]%
    }%
    \IfValueTF{#6}{%
      \tud@declare@start{#3}[{#4}][{#5}](#6)%
%    \end{macrocode}
% Ohne eine zusätzliche Angabe imletzten optionalen Argument wird standardmäßig
% der Entfall der Deklaration angegeben. Alternativ dazu kann im ersten 
% Argument der Versionsangabe mit einem Dopppelpunkt von dieser getrennt eine 
% neue bzw. aktuell gültige Deklaration als Querverweis angegeben werden.
%    \begin{macrocode}
    }{%
      \toks@{\tud@declare@start{#3}[{#4}][{#5}]}%
      \def\@tempa{\emph{entf\"allt}}%
      \in@{:}{#1}%
      \ifin@%
        \def\@tempb##1:##2\@nil{%
          \IfArgIsEmpty{##2}{}{%
            \def\@tempa{\seeref{##2'page'}}%
          }%
        }%
        \@tempb#1\@nil%
      \fi%
      \addto@hook@expandafter\toks@{\expandafter(\@tempa)}%
      \the\toks@%
    }%
  }%
  \@tud@obsoletefalse%
}{%
  \tud@declare@end{\@tud@obsoletetrue#3\@tud@obsoletefalse}{\printobsoletelist}%
}
%    \end{macrocode}
% \end{macro}^^A \if@tud@obsolete
% \end{macro}^^A \tud@declaration@list
% \end{macro}^^A \tud@alias@values
% \end{environment}^^A Obsolete
% \end{environment}^^A Declaration
% \begin{macro}{\tud@preset@list}
% \begin{macro}{\if@tud@preset@list}
% \begin{macro}{\tud@additional@list}
% \begin{macro}{\if@tud@additional@list}
% Dies sind die temporären listen, die für alle Deklarationen verwendet werden.
%    \begin{macrocode}
\newcommand*\tud@preset@list{}
\let\tud@preset@list\relax
\tud@newif\if@tud@preset@list
\newcommand*\tud@additional@list{}
\let\tud@additional@list\relax
\tud@newif\if@tud@additional@list
%    \end{macrocode}
% \end{macro}^^A \if@tud@additional@list
% \end{macro}^^A \tud@additional@list
% \end{macro}^^A \if@tud@preset@list
% \end{macro}^^A \tud@preset@list
% \begin{macro}{\tud@declare@start}
% \changes{v2.05}{2015/11/01}{neu}^^A
% \begin{macro}{\tud@declare@end}
% \changes{v2.05}{2015/11/01}{neu}^^A
% Dies sind die Makros für die eigentliche Abarbeitung der Deklarationsbefehle 
% zu Beginn und Ende der Umgebungen \env{Declaration} und \env{Obsolete}.
%    \begin{macrocode}
\NewDocumentCommand\tud@declare@start{o m r[] r[] r()}{%
%    \end{macrocode}
% Die optional angegebenen Änderungen werden mit \cs{Changed@At@CreateList} in 
% der Liste \cs{tud@changedat@list} gesichert und später sowohl für die
% Randnotiz als auch die Änderungsliste verarbeitet.
%    \begin{macrocode}
  \Changed@At@CreateList{#1}[{#2}]%
%    \end{macrocode}
% Hier noch die Listen für Voreinstellungen\dots
%    \begin{macrocode}
  \IfValueTF{#3}{%
    \@tud@preset@listtrue%
    \def\@tempa{Voreinstellung\IfArgIsEmpty{#3}{}{: \PValue{#3}}}%
    \IfValueT{#4}{%
      \def\@tempb[##1:##2]{##1: \PValue{##2}}%
      \eappto\@tempa{ | \expandonce{\@tempb[#4]}}%
    }%
    \listeadd\tud@preset@list{\expandonce\@tempa}%
  }{%
    \listadd\tud@preset@list{\relax}%
  }%
%    \end{macrocode}
% \dots sowie zusätliche Informationen.
%    \begin{macrocode}
  \IfValueTF{#5}{%
    \@tud@additional@listtrue%
    \listadd\tud@additional@list{(#5)}%
    \in@{\Environment}{#2}%
    \ifin@\listadd\tud@additional@list{\tabularnewline}\fi%
  }{%
    \listadd\tud@additional@list{\relax}%
    \in@{\Environment}{#2}%
    \ifin@%
      \listadd\tud@additional@list{\relax}%
      \listadd\tud@additional@list{\relax}%
    \fi%
  }%
}
%    \end{macrocode}
% Am Ende der Umgebungen wird das übergebenen Hauptargument erneut ausgeführt,
% was zum Beenden der Indexeinträge für die jeweilige Deklaration führt
% (\cs{@tud@openindexfalse}, siehe \cs{Process@Index}). Dafür werden die Makros 
% für die Angabe obligatorischer und optionaler Parameter lokal umdefiniert.
%    \begin{macrocode}
\newcommand*\tud@declare@end[2]{%
  \ifx\tud@declaration@list\relax\else%
    \ClassError{tudscrmanual}{\string#2\space is missing}{%
      \string\tud@declaration@list\space is not empty. Did you\MessageBreak%
      forget to print this list with\MessageBreak%
      \string#2?%
    }%
  \fi%
  \vskip-\lastskip%
  \@tud@declaretrue\@tud@openindexfalse#1\@tud@declarefalse%
  \pagebreak[1]%
}
%    \end{macrocode}
% \end{macro}^^A \tud@declare@end
% \end{macro}^^A \tud@declare@start
% \begin{macro}{\InlineDeclaration}
% \changes{v2.07}{2019/09/22}{neu}^^A
% \begin{macro}{\Inline@Declaration}
% \changes{v2.07}{2019/09/22}{neu}^^A
% Mit dem Befehl \cs{InlineDeclaration} kann eine Deklaration auch im Fließtext 
% erfolgen, ohne das hierfür die tabellarische Darstellung gewählt wird. 
% Vielmehr erscheint der Markup-Befehl in seiner gewöhnlichen Fließtextform, 
% allerdings werden zusätzlich ein Anker und ein Deklarationsindexeintrag 
% erstellt. Die Sternform erzeugt hierbei einen untergeordneten Indexeintrag. 
% Das optionale Argument kann für Änderungsnotizen genutzt werden.
%    \begin{macrocode}
\NewDocumentCommand\InlineDeclaration{s o m}{%
  \Inline@Declaration[{#2}]{#3}[\IfBooleanTF{#1}{-2}{-1}]%
}
\NewDocumentCommand\Inline@Declaration{o m !O{-1}}{%
  \tud@declare@special@start[{#1}]{#2}{#3}%
  \printchangedatlist%
  \tud@declare@special@end{#2}{#3}%
}
%    \end{macrocode}
% \end{macro}^^A \Inline@Declaration
% \end{macro}^^A \InlineDeclaration
% \begin{environment}{DeclareEntity*}
% \changes{v2.02}{2014/10/09}{neu}^^A
% \changes{v2.05}{2015/08/04}{Indexaufteilung/-markup für Klassen und Pakete}^^A
% Die Sternversion der Umgebung \env{DeclareEntity*} ist für die vereinfachte 
% Deklaration von Klassen, Paketen etc. gedacht, bei denen keine Ausgabe 
% sondern lediglich Hyperlink, Indexeintrag und Änderungsnotiz erzeugt werden 
% sollen. Hierbei werden die beiden Befehle \cs{tud@declare@special@start} und 
% \cs{tud@declare@special@end} genutzt, wobei der Anker des erzeugten Labels
% nicht erhöht sondern auf der aktuellen Grundlinie erzeugt wird.
%    \begin{macrocode}
\NewDocumentEnvironment{DeclareEntity*}{o m}{%
  \tud@declare@special@start[{#1}]{#2}{2}%
}{%
  \tud@declare@special@end{#2}{2}%
}
%    \end{macrocode}
% \end{environment}^^A DeclareEntity*
% \begin{environment}{DeclareEntity}
% \changes{v2.05}{2015/11/01}{neu}^^A
% Die Umgebung \env{DeclareEntity} wird verwendet, wenn ein zusätzliches 
% Paket oder eine weitere Klasse in Ergänzung zu den Hauptklassen dokumentiert
% wird. Hierfür wird die Umgebung \env{Entity} erst geöffnet, nachdem mit dem
% Makro \cs{tud@declare@special@start} das obligatorische Argument~-- sprich
% die Klasse oder das Paket~-- deklariert wird. Die hier definierte Umgebung 
% \env{DeclareEntity} sollte dabei direkt nach einer Gliederungsüberschrift
% genutzt werden, in welcher das zu deklarierende Element (Klasse, Paket etc.)
% genannt wird, da der Anker des erzeugten Labels weiter nach oben auf die Höhe
% der Überschirft verschoben wird. Zum Abschluss der Deklaration wird 
%\cs{tud@declare@special@end} nach dem Schließen der Umgebung \env{Entity} 
% genutzt. 
%    \begin{macrocode}
\NewDocumentEnvironment{DeclareEntity}{o m}{%
  \tud@declare@special@start*[{#1}]{#2}{3}%
  \printchangedatlist*%
  \begin{Entity}{#2}%
}{%
  \end{Entity}%
  \tud@declare@special@end{#2}{3}%
}
%    \end{macrocode}
% \end{environment}^^A DeclareEntity
% \begin{macro}{\tud@declare@special@start}
% \changes{v2.05}{2015/11/01}{neu}^^A
% \begin{macro}{\tud@declare@special@end}
% \changes{v2.05}{2015/11/01}{neu}^^A
% Die beiden Befehle dienen zur vereinfachten Deklaration. Sollte eine Ausgabe 
% erfolgen, so erfolgt diese im Fließtext und nicht tabelarisch. In jedem Fall 
% werden Hyperlink, Indexeintrag und Änderungsnotiz erzeugt. Das optionale
% Argument dient einem Änderungseintrag, das erste obligaotrische gilt der
% eigentlichen Deklaration, das zweite zur Anpassung von \cs{tud@declare@num}, 
% mit welchem das Verhalten für das Erzeugen von Ausgabe und Label gesteuert 
% wird. Die Sternvariante wird von der Umgebung \env{DeclareEntity} 
% genutzt, um Einträge in der Änderungsliste in den allgemeinen Teil zu
% schreiben.
%    \begin{macrocode}
\NewDocumentCommand\tud@declare@special@start{s r[] m m}{%
  \tud@declare@num=#4\relax%
  \@tud@declaretrue%
  \IfBooleanTF{#1}{%
    \Changed@At@CreateList{#2}(#3)%
  }{%
    \Changed@At@CreateList{#2}[{#3}]%
  }%
  \@tud@openindextrue#3%
  \@tud@declarefalse%
  \tud@declare@num=\z@\relax%
}
\newcommand*\tud@declare@special@end[2]{%
  \ifx\tud@changedat@list\relax\else%
    \ClassError{tudscrmanual}{\string\printchangedatlist\space is missing}{%
      \string\tud@changedat@list\space is not empty. Did you\MessageBreak%
      forget to print this list with \string\printchangedatlist?%
    }%
  \fi%
  \tud@declare@num=#2\relax%
  \@tud@declaretrue\@tud@openindexfalse#1\@tud@declarefalse%
  \tud@declare@num=\z@\relax%
}
%    \end{macrocode}
% \end{macro}^^A \tud@declare@special@end
% \end{macro}^^A \tud@declare@special@start
% \begin{macro}{\printdeclarationlist}
% Mit dem Befehl \cs{printdeclarationlist} erfolgt die eingentliche Ausgabe 
% aller Deklarationen. Zweck ist es, mehrere \env{Declaration}-Umgebungen 
% ineinander verschachteln zu können und eine Ausgabe aller auf einmal zu 
% erzeugen. Die durch die ggf. nacheinander folgenden Deklarationen wurden in 
% entsprechenden Listen gesammelt und werden hier jetzt formatiert ausgegben.
%    \begin{macrocode}
\NewDocumentCommand\printdeclarationlist{!s !o !d()}{%
  \ifx\tud@declaration@list\relax\else%
    \ifhmode%
      \vskip\medskipamount%
    \else%
      \addpenalty{\@beginparpenalty}%
      \addvspace{\medskipamount}%
    \fi%
    \@afterindentfalse\@afterheading%
    \@tud@declaretrue\@tud@openindextrue%
%    \end{macrocode}
% Die deklarierten Optionen, Umgebungen, Befehle etc. werden umrahmt. Dabei
% erfolgt die Ausgabe mithilfe einer Box, um die Größe des Deklarationsrahmens
% zu speichern und die Änderungsmarkierung am Seitenrand auf die richtige Höhe
% zu platzieren. Da innerhalb von Tabellen der Wert von \cs{baselineskip} auf
% \val{0pt}~gesetzt wird, muss für einen richtig platzierten Link dieser in 
% \cs{HyperRaiseLinkDefault} gesichert werden. Die Größe der Tabelle wird 
% später noch benötigt, deshalb wird diese in einer Box gesetzt.
% \ToDo{Größe der Box direkt annschließend in tud@res@... sichern}[v2.06]
%    \begin{macrocode}
    \def\@tempa##1{\ignorespaces##1\tabularnewline}%
    \edef\HyperRaiseLinkDefault{\the\dimexpr1\baselineskip\relax}%
    \sbox\z@{%
      \begin{tabular}{|l|}%
        \hline%
        \forlistloop\@tempa{\tud@declaration@list}%
        \hline%
      \end{tabular}%
      \IfValueT{#2}{\zap@space#2 \@empty}%
    }\usebox\z@%
    \@tud@declarefalse%
%    \end{macrocode}
% Danach werden ggf. die Voreinstellungen und Zusatzinformationen in etwas 
% kleinerer Schrift gesetzt.
%    \begin{macrocode}
    \ifboolexpr{bool {@tud@preset@list} or bool {@tud@additional@list}}{%
      \def\@tempa##1{\small\ignorespaces##1\tabularnewline}%
      \hskip1.2em%
      \if@tud@preset@list%
        \begin{tabular}{@{}l@{}}%
          \forlistloop\@tempa{\tud@preset@list}%
        \end{tabular}%
        \hspace{\tabcolsep}%
      \fi%
      \if@tud@additional@list%
        \begin{tabular}{@{}l@{}}%
          \forlistloop\@tempa{\tud@additional@list}%
        \end{tabular}%
      \fi%
    }{}%
%    \end{macrocode}
% Alle für die Deklaration verwendeten Listen werden nach ihrer Abarbeitung 
% zurückgesetzt.
%    \begin{macrocode}
    \global\let\tud@declaration@list\relax%
    \global\let\tud@preset@list\relax%
    \global\let\tud@additional@list\relax%
    \global\@tud@preset@listfalse%
    \global\@tud@additional@listfalse%
%    \end{macrocode}
% Die Einträge in der Änderungsliste sowie die dazugehörige Randnotiz werden
% innerhalb der Deklaration mit \cs{printchangedatlist} erzeugt. Das optionale 
% Argument sorgt für die Verschiebung der Randnotiz auf die richtige Höhe, um 
% den Höhenversatz zwischen Randnotiz und Deklarationsrahmen auszugleichen.
%    \begin{macrocode}
    \print@changedatlist{#1}{%
      \dimexpr(\ht\strutbox+\dp\strutbox-\ht0-\dp0)/2\relax%
    }%
%    \end{macrocode}
% Zum Schluss wird das optionale Argument (in runden Klammern) neben der
% Deklarationsbox ausgegeben.
%    \begin{macrocode}
    \IfValueT{#3}{#3}%
    \par\nobreak%
    \vskip\medskipamount%
    \@afterindentfalse\@afterheading%
  \fi%
}
%    \end{macrocode}
% \end{macro}^^A \printdeclarationlist
% \begin{macro}{\printobsoletelist}
% \changes{v2.05}{2015/11/01}{neu}^^A
% Damit werden Deklarationen der Umgebung \env{Obsolete} ausgegeben.
%    \begin{macrocode}
\newcommand*\printobsoletelist{%
  \@tud@obsoletetrue%
  \printdeclarationlist*%
  \@tud@obsoletefalse%
}
%    \end{macrocode}
% \end{macro}^^A \printobsoletelist
% \begin{macro}{\printchangedatlist}
% \changes{v2.05}{2015/11/01}{neu}^^A
% Damit werden Änderungsnotizen ausgegeben, die zu Beginn einer der Umgebungen 
% \env{DeclareEntity*} und \env{DeclareEntity} angegeben wurden.
%    \begin{macrocode}
\NewDocumentCommand\printchangedatlist{!s !O{\z@}}{%
  \print@changedatlist{#1}{#2}%
}
%    \end{macrocode}
% \end{macro}^^A \printchangedatlist
%
% \iffalse
%</class>
% \fi
%
% \subsection{Markup von Klassen, Paketen, Optionen und weiteren Elementen}
%
% Es folgen die Definitionen für Befehle und Umgebungen für Klasse und Paket, 
% welche sich überschneidenden und für beide benötigt werden. Allerdings sind 
% diese für Klasse und Paket in ihrer Implementierung teilweise unterschiedlich.
%
% Als erstes werden für Klasse und Paket einige Hilfmakros definiert.
%
% \begin{macro}{\if@tud@index}
% \changes{v2.05}{2015/11/05}{neu}^^A
% \begin{macro}{\if@tud@changelog}
% \changes{v2.07}{2019/11/12}{neu}^^A
% Der Schalter \cs{if@tud@index} wird zwei unterschiedliche Aufgaben verwendet. 
% Zum einen wird er bei der Ausgabe von Verzeichnissen auf \val{true} gesetzt,
% um das Setzen von Indexeinträgen durch Markup-Befehle in den Verzeichnissen
% selbst zu unterbinden. Weiterhin verhindert der aktivierte Schalter bei der
% Ausführung von \cs{Process@Markup} das Erstellen von erweiterten 
% Querverweisen sowie das Setzen von CTAN-Links bei Paketen (\cs{Package}), was 
% weder in Verzeichnissen noch im Index oder der Änderungsliste erwünscht ist,
% weshalb sowohl von \cs{PrintIndex} als auch \cs{PrintChangelog} ebenfalls
% \cs{@tud@indextrue} gesetzt wird.
%    \begin{macrocode}
\tud@newif\if@tud@index
\addtoeachtocfile{\protect\@tud@indextrue}
%<class>\tud@newif\if@tud@changelog
%    \end{macrocode}
% \end{macro}^^A \if@tud@changelog
% \end{macro}^^A \if@tud@index
% \begin{macro}{\bsc}
% \changes{v2.02}{2014/07/22}{\cs{newrobustcmd} aus \pkg{etoolbox} anstatt
%   \cs{DeclareRobustCommand}}^^A
% Eine einfacher zu verwendende Kurzform.
%    \begin{macrocode}
\newrobustcmd*\bsc{\@backslashchar}
%    \end{macrocode}
% \end{macro}^^A \bsc
% \begin{macro}{\suffix}
% \changes{v2.05}{2015/10/27}{neu}^^A
% Für alle möglichen, zusätzlichen Informationen bei Deklarationen, im Index 
% oder der normalen in Ausgabe im Fließtext wird eine etwas kleinere Schrift 
% verwendet.
%    \begin{macrocode}
\newrobustcmd*\suffix[1]{\begingroup~\scriptsize(#1)\endgroup}
%    \end{macrocode}
% \end{macro}^^A \suffix
%
% \subsubsection{Definition der Markup-Befehle}
%
% \changes{v2.05}{2015/11/02}{Markup-Befehle komplett überarbeitet}^^A
%
% Im Folgenden werden allerhand Befehle mit Hilfe des Paketes \pkg{xparse} 
% definiert, um bestimmte Begriffe, Klassen, Pakete, Optionen, Umgebungen, 
% Befehle, Parameter, Bezeichner, Längen, Schriftelemente und Farben speziell
% auszuzeichnen. Diese Befehle lauten für Klasse und Paket aus Gründen der
% Konsistenz zwar gleich, unterschieden sich jedoch ein klein wenig in der
% Implementierung.
%
% Die Sternversion all dieser Befehlen tragen nichts in den Index ein. Für 
% (fast) alle der folgenden Befehle gilt, dass diese mit zwei optionalen
% Argumenten am Ende genutzt werden können. Sollte ein Label existieren, wird 
% automatisch ein Hyperlink erzeugt, welcher mit der optionalen Angabe von
% |'|\meta{Referenzvariante}|'| um einen textuellen Querverweis ergänzt werden
% kann. Mit \verb+|+\meta{Indexmarkup}\verb+|+ kann die Erscheinung im Index
% angepasst werden. Bei einigen Befehlen kann zusätzlich zuvor im Markup mit
% dem optionalen Argument \parg{Entität} die Zuweisung auf ein bestimmtes
% Paket oder eine Klasse aus dem \TUDScript-Bundle erfolgen.
%
% Die eigentliche Behandlung erfolgt mit dem Befehl \cs{Process@Markup}, 
% welcher die tatsächliche Auszeichnung im Fließtext bzw. als Deklaration 
% übernimmt. Das Auszeichnungsformat wird dafür zuvor mit \cs{Markup@SetFormat}
% festgelegt. Ein Eintrag in den Index wird mit \cs{Process@Index} realisiert.
% Für die Änderungsliste wird der Befehl \cs{Process@ChangedAt} genutzt, um die 
% entsprechende Formatierung zu gewährleisten, wobei dies nur für die Klasse
% \cls{tudscrmanual} und nicht für das Paket \pkg{tudscrtutorial} gilt.
%
% Für Labels, Index- und Änderungs- sowie PDF-Outline-Einträge etc. müssen die
% nachfolgend definierten Markup-Befehle durch eine expandierbare Version
% ersetzt werden, welche hier mit \cs{NewExpandableDocumentCommand} ebenfalls 
% definiert werden.
%
% \ToDo{Das ist bloß temporär und muss raus!}[v2.07]
%    \begin{macrocode}
\newcommand*\ApplicationRaw[2]{\Application{#1}}
\newcommand*\ClassRaw[2]{\Class{#1}}
\newcommand*\PackageRaw[2]{\Package{#1}}
\newcommand*\@ApplicationRaw[2]{#1}
\newcommand*\@ClassRaw[2]{#1}
\newcommand*\@PackageRaw[2]{#1}
\AfterPackage*{hyperref}{%
  \pdfstringdefDisableCommands{%
    \let\ApplicationRaw\@ApplicationRaw%
    \let\ClassRaw\@ClassRaw%
    \let\PackageRaw\@PackageRaw%
  }%
}
%    \end{macrocode}
% \begin{macro}{\Application}
% \changes{v2.02}{2014/10/08}{überarbeitet}^^A
% \begin{macro}{\@Application}
% Die Auszeichnung und der Indexeintrag einer Anwendungssoftware.
%    \begin{macrocode}
\NewExpandableDocumentCommand\@Application{s m}{#2}
\NewDocumentCommand\Application{s m !d() !d<> !d||}{%
  \Markup@SetFormat{\sbifont}%
  \Process@Markup{\Application{#2}}(#3)<#4>%
  \Process@Index{#1}{\Application{#2}}[Anwendungssoftware](#3)|#5|%
}
%    \end{macrocode}
% \end{macro}^^A \@Application
% \end{macro}^^A \Application
% \begin{macro}{\Distribution}
% \changes{v2.02}{2014/10/08}{überarbeitet}^^A
% \begin{macro}{\@Distribution}
% Die Auszeichnung und der Indexeintrag einer \LaTeX-Distribution. Das 
% optionale Argument kann für das Anhängen einer Versionsnummer o.\,ä. im 
% Fließtext genutzt werden.
%    \begin{macrocode}
\NewExpandableDocumentCommand\@Distribution{s m}{#2}
\NewDocumentCommand\Distribution{s m !o !d() !d||}{%
  \Markup@SetFormat{\sbnfont}%
  \IfValueTF{#3}{%
    \Process@Markup{\Distribution{#2}}[~#3](#4)%
  }{%
    \Process@Markup{\Distribution{#2}}(#4)%
  }%
  \Process@Index{#1}{\Distribution{#2}}[Distribution](#4)|#5|%
}
%    \end{macrocode}
% \end{macro}^^A \@Distribution
% \end{macro}^^A \Distribution
% \begin{macro}{\Format}
% \changes{v2.05}{2015/11/04}{neu}^^A
% \begin{macro}{\@Format}
% \changes{v2.05}{2015/11/04}{neu}^^A
% Die Auszeichnung und der Indexeintrag für ein bestimmtes Textsatzsystem.
%    \begin{macrocode}
\NewExpandableDocumentCommand\@Format{s m}{#2}
\NewDocumentCommand\Format{s m !d() !d||}{%
  \Markup@SetFormat{\sbnfont}%
  \Process@Markup{\Format{\Logo{#2}}}(#3)%
  \Process@Index{#1}{\Format{#2}}[Textsatzsystem](#3)|#4|%
}
%    \end{macrocode}
% \end{macro}^^A \@Format
% \end{macro}^^A \Format
% \begin{macro}{\Bundle}
% \begin{macro}{\@Bundle}
% Die Auszeichnung und der Indexeintrag einer Klasse. Das optionale Argument 
% zwischen Apostrophen kann für die Formatierung eines Querverweises im Text
% genutzt werden, das optionale Argument zwischen senkrechten Strichen dient
% der Formatierung des Indexeintrages.
%    \begin{macrocode}
\NewExpandableDocumentCommand\@Bundle{s m}{#2}
\NewDocumentCommand\Bundle{s m !d() !d'' !d||}{%
%<*class>
  \if@tud@changedat%
    \Process@ChangedAt{\Bundle{#2}}[Bundle]%
  \else%
%</class>
    \Markup@SetFormat{\sbnfont}%
    \Process@Markup{\Bundle{#2}}(#3)'#4'%
    \Process@Index{#1}{\Bundle{#2}}[Bundle](#3)|#5|%
%<*class>
  \fi%
%</class>
}
%    \end{macrocode}
% \end{macro}^^A \@Bundle
% \end{macro}^^A \Bundle
% \begin{macro}{\Class}
% \changes{v2.02}{2014/10/08}{überarbeitet}^^A
% \begin{macro}{\@Class}
% Die Auszeichnung und der Indexeintrag einer Klasse. Das optionale Argument 
% zwischen Apostrophen kann für die Formatierung eines Querverweises im Text
% genutzt werden, das optionale Argument zwischen senkrechten Strichen dient
% der Formatierung des Indexeintrages.
%    \begin{macrocode}
\NewExpandableDocumentCommand\@Class{s m}{#2}
\NewDocumentCommand\Class{s m !d() !d'' !d||}{%
%<*class>
  \if@tud@changedat%
    \Process@ChangedAt{\Class{#2}}[Klasse]%
  \else%
%</class>
    \Markup@SetFormat{\sbnfont}%
    \Process@Markup{\Class{#2}}(#3)'#4'%
    \Process@Index{#1}{\Class{#2}}[Klasse](#3)|#5|%
%<*class>
  \fi%
%</class>
}
%    \end{macrocode}
% \end{macro}^^A \@Class
% \end{macro}^^A \Class
% \begin{macro}{\Package}
% \changes{v2.02}{2014/07/10}{Ausgabe für Änderungsliste hinzugefügt}^^A
% \begin{macro}{\@Package}
% Für die Auszeichnungen von Paketen gelten vorherigen Aussagen äquivalent. 
% Für Pakete wird ergänzend ein Hyperlink auf CTAN erzeugt, wenn für dieses 
% kein Label im Dokument besteht. Genaueres ist der Beschreibung und Definition 
% von \cs{Process@Markup} zu entnehmen. Das optionale Argument in einfachen
% Guillemets dient zum Anpassen des CTAN-Links, welcher normalerweise aus
% obligatorischen Argument generiert wird.
%    \begin{macrocode}
\NewExpandableDocumentCommand\@Package{s m}{#2}
\NewDocumentCommand\Package{s m !d() !d<> !d'' !d||}{%
%<*class>
  \if@tud@changedat%
    \Process@ChangedAt{\Package{#2}}[Paket]%
  \else%
%</class>
    \Markup@SetFormat{\sbnfont}%
    \IfValueTF{#4}{%
      \Process@Markup{\Package{#2}}(#3)<#4>'#5'%
    }{%
      \Process@Markup{\Package{#2}}(#3)<#2>'#5'%
    }%
    \Process@Index{#1}{\Package{#2}}[Paket](#3)|#6|%
%<*class>
  \fi%
%</class>
}
%    \end{macrocode}
% \end{macro}^^A \@Package
% \end{macro}^^A \Package
% \begin{macro}{\Option}
% \changes{v2.02}{2014/10/08}{überarbeitet}^^A
% \begin{macro}{\Option@Value}
% \changes{v2.05}{2015/11/02}{neu}^^A
% \begin{macro}{\@Option}
% \changes{v2.02}{2014/11/02}{neu}^^A
% Im Gegensatz zu den vorherigen Befehlen, kann im Hauptargument ein spezieller 
% Wert für eine Option optional durch ein |=| getrennt angegeben werden. Durch
% den Argumentprozessor \cs{Processor@KeyVal} wird dieses vom eigentlichen
% Schlüssel getrennt. Dabei wird der gegebene Schlüssel immer in der Form
% \marg{Schlüssel} ausgegeben. Sollte ein optionaler Wert gegeben worden sein, 
% wird dieser in der Form |=|\meta{Wert}|=| einfach angehängt und als optionales
% Argument von \cs{Option@Value} weiter verarbeitet. Mit dem optionalen Argument
% in runden Klammern kann ggf. auf eine Option aus einem  \TUDScript-Paket
% verwiesen werden.
%    \begin{macrocode}
\NewExpandableDocumentCommand\@Option{s m}{#2}
\NewDocumentCommand\Option{s >{\Processor@KeyVal}m !d== !d() !d'' !d||}{%
  \Option@Value{#1}#2=#3=(#4)'#5'|#6|%
}
%    \end{macrocode}
% Für die interne Verwendung kann das optionale Argument für den Wert auch 
% direkt mit |=|\meta{Wert}|=| angehangen werden. Um die gleichzeitige 
% Verwendung beider Varianten zu unterdrücken, wird in diesem Fall ein Fehler 
% erzeugt.
% \ToDo{
%   Eigentlich sollte der Wert hier formatiert werden. Wünschenswert wäre die 
%   Angabe von \val{Option=Wert} und \val{Option=<Spezialwert>}, damit das 
%   Gezerre mit der Spezialbehandlung von \cs{PSet} etc. wegfallen könnte,
%   siehe \cs{tud@declare@start}
% }[v2.??]
%    \begin{macrocode}
\NewDocumentCommand\Option@Value{m m d== d== d() d'' d||}{%
  \IfValueT{#4}{\tud@keyval@error}%
%<*class>
  \if@tud@changedat%
    \Process@ChangedAt{\Option{#2}}=#3=[Option](#5)%
  \else%
%</class>
    \Markup@SetFormat{\ttfamily}%
    \Process@Markup{\Option{#2}}=#3=(#5)'#6'%
    \Process@Index{#1}{\Option{#2}}=#3=(#5)|#7|%
%<*class>
  \fi%
%</class>
}
%    \end{macrocode}
% \end{macro}^^A \@Option
% \end{macro}^^A \Option@Value
% \end{macro}^^A \Option
% \begin{macro}{\Environment}
% \changes{v2.02}{2014/10/08}{überarbeitet}^^A
% \begin{macro}{\@Environment}
% \changes{v2.02}{2014/11/02}{neu}^^A
% Bei diesem Makro dient das optionale Argument für die Ausgabe der möglichen 
% Umgebungsargumente bzw. -parameter \emph{bei der Deklaration}. 
%    \begin{macrocode}
\NewExpandableDocumentCommand\@Environment{s m}{#2}
\NewDocumentCommand\Environment{s m !o !d() !d'' !d||}{%
%<*class>
  \if@tud@changedat%
    \Process@ChangedAt{\Environment{#2}}[Umgebung](#4)%
  \else%
%</class>
%    \end{macrocode}
% Außerdem wird für den Fall, dass der \cs{Environment}-Befehl innerhalb der
% Umgebung \env{Declaration} verwendet wird, eine spezielle Ausgabe erzeugt. 
% Nur hier kommt das optionale Argument von \cs{Markup@SetFormat} nach dem
% Hauptargument zum Tragen. Die resultierende Ausgabe hat die Gesatlt:
%
% \begin{tabular}{l}
%   \cs{begin}\marg{Umgebung}\tabularnewline
%   \dots\tabularnewline
%   \cs{end}\marg{Umgebung}\tabularnewline
% \end{tabular}
%    \begin{macrocode}
    \Markup@SetFormat{\ttfamily}(%
      \ttfamily\bsc{}begin\textbraceleft#2\textbraceright\IfValueT{#3}{#3}%
      \tabularnewline\ttfamily\dots%
      \tabularnewline\ttfamily\bsc{}end\textbraceleft#2\textbraceright%
    )%
    \Process@Markup{\Environment{#2}}[{#3}](#4)'#5'%
    \Process@Index{#1}{\Environment{#2}}[Umgebung](#4)|#6|%
%<*class>
  \fi%
%</class>
}
%    \end{macrocode}
% \end{macro}^^A \@Environment
% \end{macro}^^A \Environment
% \begin{macro}{\Macro}
% \changes{v2.02}{2014/10/08}{überarbeitet}^^A
% \begin{macro}{\@Macro}
% \changes{v2.02}{2014/11/02}{neu}^^A
% Die Auszeichnung und der Indexeintrag eines Befehls. Das ordinäre optionale 
% Argument ist für das Anhängen von Parametern o.\,ä. nach dem eigentlichen 
% Makro zu verwenden. Das optionale Argument in runden Klammern dient dem
% Hyperlink zu einem Befehl aus einem anderen Paket oder einer anderen Klasse
% aus dem \TUDScript-Bundle.
%    \begin{macrocode}
\NewExpandableDocumentCommand\@Macro{s m}{#2}
\NewDocumentCommand\Macro{s m !o !d() !d'' !d||}{%
%<*class>
  \if@tud@changedat%
    \Process@ChangedAt{\Macro{#2}}[Befehl](#4)%
  \else%
%</class>
    \Markup@SetFormat[\bsc]{\ttfamily}%
    \Process@Markup{\Macro{#2}}[{#3}](#4)'#5'%
    \Process@Index{#1}{\Macro{#2}}(#4)|#6|%
%<*class>
  \fi%
%</class>
}
%    \end{macrocode}
% \end{macro}^^A \@Macro
% \end{macro}^^A \Macro
% \begin{macro}{\Length}
% \changes{v2.02}{2014/10/08}{überarbeitet}^^A
% \begin{macro}{\@Length}
% Die Auszeichnung und der Indexeintrag einer \LaTeX-Länge.
%    \begin{macrocode}
\NewExpandableDocumentCommand\@Length{s m}{#2}
\NewDocumentCommand\Length{s m !d() !d'' !d||}{%
%<*class>
  \if@tud@changedat%
    \Process@ChangedAt{\Length{#2}}[L\"ange](#3)%
  \else%
%</class>
    \Markup@SetFormat[\bsc]{\ttfamily}[L\"ange]%
    \Process@Markup{\Length{#2}}(#3)'#4'%
    \Process@Index{#1}{\Length{#2}}[L\"ange](#3)|#5|%
%<*class>
  \fi%
%</class>
}
%    \end{macrocode}
% \end{macro}^^A \@Length
% \end{macro}^^A \Length
% \begin{macro}{\Counter}
% \changes{v2.02}{2014/10/08}{überarbeitet}^^A
% Die Auszeichnung und der Indexeintrag einer \LaTeX-Zählers.
%    \begin{macrocode}
\NewExpandableDocumentCommand\@Counter{s m}{#2}
\NewDocumentCommand\Counter{s m !d() !d'' !d||}{%
%<*class>
  \if@tud@changedat%
    \Process@ChangedAt{\Counter{#2}}[Z\"ahler](#3)%
  \else%
%</class>
    \Markup@SetFormat{\ttfamily}[Z\"ahler]%
    \Process@Markup{\Counter{#2}}(#3)'#4'%
    \Process@Index{#1}{\Counter{#2}}[Z\"ahler](#3)|#5|%
%<*class>
  \fi%
%</class>
}
%    \end{macrocode}
% \end{macro}^^A \Counter
%
% \iffalse
%<*class>
% \fi
%
% \minisec{Exklusive Auszeichnungen für die Klasse}
% Alle weiteren Befehle werden ausschließlich für die Klasse \cls{tudscrmanual}
% definiert.
%
% \begin{macro}{\Key}
% \changes{v2.02}{2014/10/08}{überarbeitet}^^A
% \begin{macro}{\Key@Value}
% \changes{v2.05}{2015/11/02}{neu}^^A
% \begin{macro}{\@Key}
% Die Auszeichnung und der Indexeintrag eines Parameters für Umgebungen und 
% Befehle. Das erste Argument ist die Umgebung oder der Befehl, wofür der 
% Parameter gültig ist. Das zweite Argument ist der Parameter selbst. Die 
% optionale Zuweisung eines Wertes kann äquivalent zu \cs{Option} mit dem
% Trennzeichen~|=| im Hauptargument erfolgen.
% \ToDo{
%   Eigentlich sollte der Wert hier formatiert werden. Die Angabe von
%   \val{Parameter=Wert} und \val{Parameter=<Spezialwert>} wäre gut, damit
%   das Gezerre mit der Spezialbehandlung von \cs{PSet} etc. wegfallen könnte,
%   siehe \cs{tud@declare@start}
% }[v2.??]
%    \begin{macrocode}
\NewExpandableDocumentCommand\@Key{s m m}{#2!#3}
\NewDocumentCommand\Key{s m >{\Processor@KeyVal}m !d== !d() !d'' !d||}{%
  \Key@Value{#1}{#2}#3=#4=(#5)'#6'|#7|%
}
\NewDocumentCommand\Key@Value{m m m d== d== d() d'' d||}{%
  \IfValueT{#5}{\tud@keyval@error}%
  \if@tud@changedat%
    \Process@ChangedAt{\Key{#2}{#3}}=#4=[Parameter](#6)%
  \else%
    \Markup@SetFormat{\ttfamily}[Parameter]%
    \Process@Markup{\Key{#2}{#3}}=#4=(#6)'#7'%
    \Process@Index{#1}{\Key{#2}{#3}}=#4=(#6)|#8|%
  \fi%
}
%    \end{macrocode}
% \end{macro}^^A \@Key
% \end{macro}^^A \Key@Value
% \end{macro}^^A \Key
% \begin{macro}{\Term}
% \changes{v2.02}{2014/10/08}{überarbeitet}^^A
% \begin{macro}{\@Term}
% Die Auszeichnung und der Indexeintrag eines sprachabhängigen Bezeichners.
%    \begin{macrocode}
\NewExpandableDocumentCommand\@Term{s m}{#2}
\NewDocumentCommand\Term{s m !d() !d'' !d||}{%
  \if@tud@changedat%
    \Process@ChangedAt{\Term{#2}}[Bezeichner](#3)%
  \else%
    \Markup@SetFormat[\bsc]{\ttfamily}[Bezeichner]%
    \Process@Markup{\Term{#2}}(#3)'#4'%
    \Process@Index{#1}{\Term{#2}}(#3)|#5|%
  \fi%
}
%    \end{macrocode}
% \end{macro}^^A \@Term
% \end{macro}^^A \Term
% \begin{macro}{\PageStyle}
% \changes{v2.02}{2014/07/25}{neu}^^A
% \begin{macro}{\@PageStyle}
% Die Auszeichnung und der Indexeintrag eines Seitenstils.
%    \begin{macrocode}
\NewExpandableDocumentCommand\@PageStyle{s m}{#2}
\NewDocumentCommand\PageStyle{s m !d() !d'' !d||}{%
  \if@tud@changedat%
    \Process@ChangedAt{\PageStyle{#2}}[Seitenstil](#3)%
  \else%
    \Markup@SetFormat{\ttfamily}[Seitenstil]%
    \Process@Markup{\PageStyle{#2}}(#3)'#4'%
    \Process@Index{#1}{\PageStyle{#2}}[Seitenstil](#3)|#5|%
  \fi%
}
%    \end{macrocode}
% \end{macro}^^A \@PageStyle
% \end{macro}^^A \PageStyle
% \begin{macro}{\Font}
% \changes{v2.02}{2014/10/08}{überarbeitet}^^A
% \begin{macro}{\@Font}
% Die Auszeichnung und der Indexeintrag eines Schriftelementes.
%    \begin{macrocode}
\NewExpandableDocumentCommand\@Font{s m}{#2}
\NewDocumentCommand\Font{s m !d() !d'' !d||}{%
  \if@tud@changedat%
    \Process@ChangedAt{\Font{#2}}[Schriftelement](#3)%
  \else%
    \Markup@SetFormat{\ttfamily}[Schriftelement]%
    \Process@Markup{\Font{#2}}(#3)'#4'%
    \Process@Index{#1}{\Font{#2}}[Schriftelement](#3)|#5|%
  \fi%
}
%    \end{macrocode}
% \end{macro}^^A \@Font
% \end{macro}^^A \Font
% \begin{macro}{\Color}
% \changes{v2.02}{2014/10/08}{überarbeitet}^^A
% \begin{macro}{\@Color}
% Die Auszeichnung und der Indexeintrag einer Farbe des \CDs. Das optionale 
% Argument kann sowohl bei der Deklaration als auch im Fließtext für das 
% Anhängen eines Suffix verwendet werden. Alle mit \cs{Color} ausgezeichneten 
% Farben referenzieren standardmäßig auf das Paket \pkg{tudscrcolor}.
%    \begin{macrocode}
\NewExpandableDocumentCommand\@Color{s m}{#2}
\NewDocumentCommand\Color{s m !o !D(){\Package{tudscrcolor}} !d'' !d||}{%
  \if@tud@changedat%
    \Process@ChangedAt{\Color{#2}}[Farbe](#4)%
  \else%
    \Markup@SetFormat{\ttfamily}[Farbe](%
      \begingroup\ttfamily{#2\IfValueT{#3}{~(#3)}}\endgroup%
    )%
    \Process@Markup{\Color{#2}}[{#3}](#4)'#5'%
    \Process@Index{#1}{\Color{#2}}[Farbe](#4)|#6|%
  \fi%
}
%    \end{macrocode}
% \end{macro}^^A \@Color
% \end{macro}^^A \Color
%
% \iffalse
%</class>
% \fi
%
% \begin{macro}{\tud@x@textcase@uclcnotmath}
% \begin{macro}{\tud@nocasechange}
% \changes{v2.05}{2015/11/20}{neu}^^A
% \begin{macro}{\tud@@nocasechange}
% Die \TUDScript-Hauptklassen definieren in Ergänzung zum Paket \pkg{textcase} 
% den internen Befehl \cs{tud@x@textcase@uclcnotmath}, womit Makros definiert 
% werden können, welche von \cs{MakeTextUppercase} nicht beachtet werden. 
% Hierfür werden \emph{alle} Markup-Befehle (\cs{tud@markup@list}) der Liste 
% zum Ignorieren (\cs{tud@x@textcase@uclcnotmath}) hinzugefügt.
%    \begin{macrocode}
\AfterPackage*{textcase}{%
  \newcommand*\tud@@nocasechange[1]{\NoCaseChange{\the\toks@{#1}}}%
  \newcommand*\tud@nocasechange[1]{%
    \def#1##1##{\NoCaseChange{\toks@{\noexpand#1##1}}\tud@@nocasechange}%
  }%
  \def\tud@res@a#1{%
    \eappto\tud@x@textcase@uclcnotmath{%
      \noexpand\tud@nocasechange\expandafter\noexpand\csname#1\endcsname%
    }%
  }%
  \forlistloop\tud@res@a{\tud@markup@list}%
  \appto\tud@x@textcase@uclcnotmath{\tud@nocasechange\Logo}%
}
%    \end{macrocode}
% \end{macro}^^A \tud@@nocasechange
% \end{macro}^^A \tud@nocasechange
% \end{macro}^^A \tud@x@textcase@uclcnotmath
%
% \begin{macro}{\Processor@Underscore}
% \changes{v2.07}{2019/11/08}{neu}^^A
% Mit diesem Argumentprozessor werden Unterstriche in Datei- und Pfadangaben 
% unschädlich gemacht.
%    \begin{macrocode}
\newcommand*\Processor@Underscore[1]{%
  \begingroup%
    \def\tud@res@a{#1}%
    \tud@replace@in\tud@res@a{_}{\_}%
    \edef\tud@res@a{%
      \endgroup%
      \def\noexpand\ProcessedArgument{\expandonce\tud@res@a}%
    }%
  \tud@res@a%
}
%    \end{macrocode}
% \end{macro}^^A \Processor@Underscore
% \begin{macro}{\File}
% \changes{v2.02}{2014/10/08}{überarbeitet}^^A
% \begin{macro}{\@File}
% Die Auszeichnung und der Indexeintrag einer Datei.
%    \begin{macrocode}
\NewExpandableDocumentCommand\@File{s m}{#2}
\NewDocumentCommand\File{s >{\Processor@Underscore}m !d() !d||}{%
  \Markup@SetFormat{\sbnfont}%
  \Process@Markup{\File{#2}}(#3)%
  \Process@Index{#1}{\File{#2}}[Datei](#3)|#4|%
}
%    \end{macrocode}
% \end{macro}^^A \@File
% \end{macro}^^A \File
% \begin{macro}{\Path}
\NewDocumentCommand\Path{>{\Processor@Underscore}m}{\mbox{\texttt{#1}}}
% \end{macro}^^A \Path
% \begin{macro}{\Processor@KeyVal}
% \changes{v2.05}{2015/11/01}{neu}^^A
% \begin{macro}{\tud@keyval@error}
% \changes{v2.05}{2015/11/01}{neu}^^A
% Bei Optionen und Parametern können spezielle Werte einfach im Hauptargument 
% durch |=| getrennt angegeben werden. Um diese auszuwerten, wird dieser Befehl
% definiert, welcher als Argumentprozessor verwendet wird.
%    \begin{macrocode}
\newcommand*\Processor@KeyVal[1]{%
  \begingroup%
    \in@{=}{#1}%
%    \end{macrocode}
% Wird im Argument ein |=| gefunden, so wird alles Darauffolgende als Wert 
% erkannt und dem eigentlichen Hauptargument bei der Ausgabe angehangen. Das
% Makro, welches diesen Argumentprozessor verwendet, erhält als Ausgabe also
% entweder \marg{Schlüssel} oder \marg{Schlüssel}|=|\meta{Wert}|=| falls
% \cs{Processor@KeyVal} mit \marg{Schlüssel=Wert} verwendet wurde.
%    \begin{macrocode}
    \ifin@%
      \def\@tempa##1=##2\@nil{\toks@{{##1}=##2=}}%
    \else%
      \def\@tempa##1\@nil{\toks@{{##1}}}%
    \fi%
    \@tempa#1\@nil%
    \edef\tud@reserved{%
      \noexpand\endgroup%
      \def\noexpand\ProcessedArgument{\the\toks@}%
    }%
  \tud@reserved%
}
%    \end{macrocode}
% Es gibt auch noch eine interne Variante für ein optioneles Werte-Argument. 
% Dabei sollte vermieden werden, dass im Markup das Argument für einen Wert 
% doppelt angegeben wird. In diesem Fall wird dieser Fehler ausgegeben.
%    \begin{macrocode}
\newcommand*\tud@keyval@error{%
%<*class>
  \ClassError{tudscrmanual}%
%</class>
%<*package>
  \PackageError{tudscrtutorial}%
%</package>
    {Wrong usage of optional argument for value}%
    {There are two optional arguments for a value given!}%
}
%    \end{macrocode}
% \end{macro}^^A \tud@keyval@error
% \end{macro}^^A \Processor@KeyVal
%
% \subsubsection{Zuordnung der Markup-Befehle für Label und Index}
%
% \begin{macro}{\tud@attr@get}
% \changes{v2.05}{2015/11/03}{neu}^^A
% Der Befehl \cs{tud@attr@get} ordnet den einzelnen Markup-Befehlen ihren 
% spezifischen Präfix für ein Label oder in der Sternversion den passenden 
% Index zu. Im ersten obligatorischen Argument wird ein Makro angegeben, 
% welches die Zuordnung enthalten soll, das zweite ist der Markup-Befehl selbst.
%    \begin{macrocode}
\NewDocumentCommand\tud@attr@get{s m m}{%
  \begingroup%
%    \end{macrocode}
% Das temporäre Makro \cs{@tempa} definiert zunächst alle Markup-Befehle in 
% einer Gruppe neu und expandiert beim Aufruf jedes dieser lokal umdefinierten 
% Markup-Befehle~-- abhängig vom Aufruf von \cs{tud@attr@get} mit oder ohne
% Stern~-- entweder zum Markup-Befehl passenden Index oder zum entsprechenden
% Labelpräfix in \cs{@tempb}.
%    \begin{macrocode}
    \def\@tempa##1##2##3{%
      \def##1####1{%
        \edef\@tempb{\IfBooleanTF{#1}{##2}{##3}}%
      }%
    }%
    \@tempa\Application{\jobname}{app}%
    \@tempa\Distribution{\jobname}{dst}%
    \@tempa\Format{\jobname}{eng}%
    \@tempa\File{files}{fle}%
    \@tempa\Bundle{files}{bdl}%
    \@tempa\Class{files}{cls}%
    \@tempa\Package{files}{pkg}%
    \@tempa\Option{options}{opt}%
    \@tempa\Environment{macros}{env}%
    \@tempa\Macro{macros}{cmd}%
    \@tempa\Length{misc}{len}%
    \@tempa\Counter{misc}{cnt}%
%    \end{macrocode}
% Da \cs{Key} mit zwei Hauptargumenten aufgerufen wird, ist nur die Expansion
% des ersten Argumentes in \cs{@tempb} notwendig.
%    \begin{macrocode}
%<*class>
    \def\Key##1##2{%
      \edef\@tempb{\IfBooleanTF{#1}{macros}{key}}%
    }%
    \@tempa\Term{terms}{term}%
    \@tempa\PageStyle{elements}{pgs}%
    \@tempa\Font{elements}{font}%
    \@tempa\Color{elements}{clr}%
%</class>
%    \end{macrocode}
% Nachdem alle Markup-Befehle lokal redefiniert wurden, wird der nun angegebene 
% Befehl ausgeführt, was zum eigentlichen Definieren von \cs{@tempb} führt.
%    \begin{macrocode}
    #3%
%    \end{macrocode}
% Damit alle Änderungen der temporären Makros lokal bleiben, wird das Ergebnis 
% nach der Gruppe in das erste obligatorische Argument expandiert.
%    \begin{macrocode}
    \edef\tud@reserved{%
      \noexpand\endgroup%
      \def\noexpand#2{\@tempb}%
    }%
  \tud@reserved%
}
%    \end{macrocode}
% \end{macro}^^A \tud@attr@get
%
% \subsubsection{Markup von Variablen, Parametern etc.}
%
% \ToDo{
%   Verwendung der Befehle überprüfen, evtl. umbennenen. Wozu \cs{PValueName}?
%   Evtl. sollte \cs{PValue} innerhalb von \cs{PName} lokal geändert werden?
%   Was passiert, wenn auch \cs{PName} von \cs{tud@doifPValue} akzeptiert?
%   Zeile 542--546 in tudscr-hints, 294 in tudscr-packages
% }[v2.07]
% \ToDo{
%   nach '=\cs{P(Value)?Name}' in *.tex suchen und ggf. 
%   überarbeiten; \cs{PValueName} umbenennen
% }[v2.07]
% \ToDo{neues Makro \cs{PSetLength} mit \cs{PName}\marg{Längenwert}}[v2.??]
% \begin{macro}{\PValue}
% \begin{macro}{\PValueDefault}
% \changes{v2.05}{2015/11/01}{neu}^^A
% \begin{macro}{\PName}
% \begin{macro}{\MPName}
% \begin{macro}{\OPName}
% \begin{macro}{\OList}
% \begin{macro}{\OPList}
% \begin{macro}{\MPValue}
% \begin{macro}{\OPValue}
% \changes{v2.03}{2015/01/25}{neu}^^A
% \begin{macro}{\textOR}
% \begin{macro}{\PSet}
% \begin{macro}{\PMisc}
% \begin{macro}{\PBoolean}
% \begin{macro}{\PLength}
% Diese Befehle dienen zum Auszeichnen von obligatorischen und optionalen 
% Parametern und Befehlen oder bestimmten Wertzuweisungen. Pfade werden ohne
% zusätzliches Markup ausgegeben.
%    \begin{macrocode}
\newrobustcmd*\PValue[1]{\mbox{\texttt{#1}}}
\newrobustcmd*\PValueDefault[1]{\mbox{\texttt{\textsl{#1}}}}
\newrobustcmd*\PName[1]{\mbox{\texttt{\textsl{<#1>}}}}
\newrobustcmd*\PValueName[1]{\PName{#1}}
\newrobustcmd*\MPName[1]{%
  \mbox{\texttt{\textbraceleft}\PName{#1}\texttt{\textbraceright}}%
}
\newrobustcmd*\MPValue[1]{\mbox{\texttt{\textbraceleft#1\textbraceright}}}
\newrobustcmd*\OPName[1]{\mbox{\texttt{[}\PName{#1}\texttt{]}}}
\newrobustcmd*\OPValue[1]{\mbox{\texttt{[{#1}]}}}
\newrobustcmd*\OList{\mbox{\texttt{[}\PName{Parameterliste}\texttt{]}}}
\newrobustcmd*\OPList[1]{%
  \mbox{\texttt{[}\PName{#1}\textOR\PName{Parameterliste}\texttt{]}}%
}
\newrobustcmd*\textOR{\PValue{\,\textbardbl\,}}
\newrobustcmd*\PSet[1]{\PName{#1}}
\newrobustcmd*\PMisc{\PSet{Einstellung}}
\newrobustcmd*\PBoolean{\PSet{Ein-Aus-Wert}}
\newrobustcmd*\PLength{\PSet{L\"angenwert}}
%    \end{macrocode}
% \end{macro}^^A \PLength
% \end{macro}^^A \PBoolean
% \end{macro}^^A \PMisc
% \end{macro}^^A \PSet
% \end{macro}^^A \textOR
% \end{macro}^^A \OPValue
% \end{macro}^^A \MPValue
% \end{macro}^^A \OPList
% \end{macro}^^A \OList
% \end{macro}^^A \OPName
% \end{macro}^^A \MPName
% \end{macro}^^A \PName
% \end{macro}^^A \PValueDefault
% \end{macro}^^A \PValue
% \begin{macro}{\tud@doifPValue}
% \changes{v2.05}{2015/11/14}{neu}^^A
% Der Befehl wird von den Makros \cs{tud@lbl@get} und \cs{tud@idx@get} genutzt,
% um bedingten Quelltext auszuführen, falls im ersten obligatorischen Argument
% entweder Parameter direkt oder aber mit einem der Parameter-Markup-Befehle
% \cs{PValue} oder \cs{PValueName} angegeben wurde.
%    \begin{macrocode}
\newcommand*\tud@doifPValue[3][]{%
  \IfValueT{#2}{%
    \begingroup%
%    \end{macrocode}
% Zunächst wird der Inhalt fast aller ausgezeichneten Parameter unterdrückt.
% Lediglich das Argument der beiden Makros \cs{PValue} und \cs{PValueName} wird 
% durchgereicht.Dies wird bei der Generierung von Labeln sowie der Erstellung
% für Einträge im Index und der Änderungsliste benötigt, um die Angabe von
% speziellen Werten bei Schlüsseln zu erhalten.
%    \begin{macrocode}
      \let\PValue\@firstofone%
      \let\PValueDefault\@firstofone%
      \let\PName\@gobble%
      \let\PValueName\@firstofone%
      \let\MPName\@gobble%
      \let\OPName\@gobble%
      \let\OList\@empty%
      \let\OPList\@gobble%
      \let\MPValue\@gobble%
      \let\OPValue\@gobble%
      \let\textOR\@empty%
      \let\PSet\@gobble%
      \let\PMisc\@empty%
      \let\PBoolean\@empty%
      \let\PLength\@empty%
      \let\emph\@firstofone%
%    \end{macrocode}
% Im optionalen Argument können weitere Angaben gemacht werden, um zum Beispiel 
% weitere lokale Redefinitionen vorzunehmen.
%    \begin{macrocode}
      #1%
%    \end{macrocode}
% Falls tatsächlich ein passendes Argument angegeben wurde, wird der Quelltext 
% des zweiten obligatorischen Argumentes ausgeführt. Es ist zu beachten, dass
% dieser \emph{expandiert} wird!
%    \begin{macrocode}
      \ifxblank{#2}{%
        \def\tud@reserved{\endgroup}%
      }{%
        \protected@edef\tud@reserved{\endgroup#3}%
      }%
    \tud@reserved%
  }%
}
%    \end{macrocode}
% \end{macro}^^A \tud@doifPValue
% \begin{macro}{\Markup@Expandable}
% \changes{v2.05}{2015/11/01}{neu}^^A
% \begin{macro}{\Parameter@Expandable}
% \changes{v2.07}{2019/11/22}{neu}^^A
% Dieser Befehl definiert alle Markup-Befehle in der Form um, dass diese nur 
% noch das eigentliche Hauptargument unformatiert durchreichen. Dies wird für 
% die Erstellung von Label und Indexeinträgen benötigt. Die Sternversion führt 
% dies auch noch für die Auszeichnung von Parametern etc. durch.
%    \begin{macrocode}
\NewDocumentCommand\Markup@Expandable{s}{%
  \let\Application\@Application%
  \let\Distribution\@Distribution%
  \let\Format\@Format%
  \let\File\@File%
  \let\Bundle\@Bundle%
  \let\Class\@Class%
  \let\Package\@Package%
  \let\Option\@Option%
  \let\Environment\@Environment%
  \let\Macro\@Macro%
  \let\Length\@Length%
  \let\Counter\@Counter%
%<*class>
  \let\Key\@Key%
  \let\Term\@Term%
  \let\PageStyle\@PageStyle%
  \let\Font\@Font%
  \let\Color\@Color%
%</class>
  \IfBooleanF{#1}{%
    \Parameter@Expandable%
    \let\Logo\@firstofone%
    \def\_{-}%
    \protected\def~{~}%
  }%
}
%    \end{macrocode}
% Hiermit werden die Befehle für Parameter expandierbar.
%    \begin{macrocode}
\newcommand*\Parameter@Expandable{%
  \let\PValue\@firstofone%
  \let\PValueDefault\@firstofone%
  \let\PName\@firstofone%
  \let\PValueName\@firstofone%
  \let\MPName\@firstofone%
  \let\OPName\@firstofone%
  \let\OList\@empty%
  \let\OPList\@firstofone%
  \let\MPValue\@firstofone%
  \let\OPValue\@firstofone%
  \let\textOR\@empty%
  \let\PSet\@gobble%
  \let\PMisc\@empty%
  \let\PBoolean\@empty%
  \let\PLength\@empty%
}
% Mit dem zuvor definierten Makro \cs{Markup@Expandable} wird gleich dafür
% Sorge getragen, dass die Auszeichnungsbefehle für PDF-Outline-Einträge
% korrekt funktionieren.
%    \begin{macrocode}
\AfterPackage*{hyperref}{%
  \expandafter\pdfstringdefDisableCommands\expandafter{\Markup@Expandable}%
}
%    \end{macrocode}
% \end{macro}^^A \Parameter@Expandable
% \end{macro}^^A \Markup@Expandable
%
% \subsubsection{Abarbeitung der Markup-Befehle}
%
% Die Festlegung des individuellen Markups der Einzelnen Elemente erfolgt bei 
% der Definition mit \cs{Markup@SetFormat}. Bei der Nutztung der Markup-Befehle
% im Fließtext wird zum einen das in \cs{Markup@Format} individuell definierte
% Markup umgesetzt und zum anderen wird dabei gleich automatisch ein Eintrag
% für das Element im Index erzeugt.
%
% In der Klasse \cls{tudscrmanual} werden die Markup-Befehle zusätzlich auch 
% als Argument der Umgebung \env{Declaration} genutzt. Für diese Verwendung
% kommt die Definiton von \cs{Markup@Declare} und ggf. \cs{Markup@Suffix} zum 
% Einsatz. 
%
% \begin{macro}{\Process@Markup}
% \changes{v2.02}{2014/10/08}{Markup für Index und Fließtext getrennt}^^A
% \changes{v2.02}{2014/10/09}{Anpassung für Umgebung \env{DeclareEntity*}}^^A
% \changes{v2.05}{2015/11/05}{Neuimplementierung}^^A
% \begin{macro}{\Markup@Suppress}
% \changes{v2.05}{2015/11/05}{neu}^^A
% \begin{macro}{\Markup@@Suppress}
% \changes{v2.05}{2015/11/05}{neu}^^A
% Der Befehl \cs{Process@Markup} ist das Herzstück der Auszeichnungen aller
% Elemente. Das obligatorische Argument ist das auszuzeichnende Element selbst,
% welches im weiteren Verlauf der Abarbeitung expandiert wird. Darauf folgen 
% mehrere optionale Argumente. Mit |=|\meta{Wert}|=| kann ein Wert für einen
% Schlüssel angegeben werden, was aktuell von \cs{Option} und \cs{Key} genutzt
% wird. Darauf folgend kann in einem ordinären optionalen Argument ein Suffix
% für die Fließtextausgabe angegeben werden, was von \cs{Distribution}  sowie
% \cs{Environment}, \cs{Macro} und \cs{Color} verwendet wird.
%
% Mit dem optionalen Argument in runden Klammern kann eine Klasse oder ein 
% Paket aus dem \TUDScript-Bundle angegeben werden, auf welche sich das
% aktuelle auszuzeichnende Element bezieht und ggf. das Label und der
% Indexeintrag dementsprechend erzeugt werden sollen. Verwendet wird es mit: 
% |(\Class|\marg{Klasse}|)| oder |(\Package|\marg{Paket}|)| 
%
% Das optionale Argument in Guillemets wird von \cs{Package} benötigt, um ggf.
% die automatisch generierten Links auf CTAN anzupassen. Zuletzt kann mit 
% |'|\meta{Referenzvariante}|'| der automatisch erzeugte Querverweis in
% verschiedenen Varianten formatiert werden. Der vollständige Funktionsaufruf:
% \newline\begingroup\scriptsize^^A
%   \cs{Process@Markup}\marg{Element}|=|\meta{Wert}|=|^^A
%   \oarg{Ausgabesuffix}\parg{Entität}^^A
%   |<|\meta{CTAN-Paket}|>||'|\meta{Referenzvariante}|'|^^A
% \endgroup
% \ToDo{vorherige doc überarbeiten oder raus}[v2.07]
%
% In eingen Fällen ist es beim Aufruf eines Markup-Befehls nicht erwünscht, 
% dass dieser auch tatsächlich ausgegeben wird. Für diesen Fall wird gleich zu
% Beginn der Befehl \cs{Markup@Suppress} definiert, der dies ermöglicht.
%    \begin{macrocode}
\newcommand*\Markup@Suppress{\let\Process@Markup\Markup@@Suppress}
\NewDocumentCommand\Markup@@Suppress{m d== o d() d<> d''}{}
%    \end{macrocode}
% Nun folgt die eigentliche Befehlsdefinition.
%    \begin{macrocode}
\NewDocumentCommand\Process@Markup{m d== o d() d<> d''}{%
%    \end{macrocode}
% Zu Beginn wird mit dem Schalter \cs{if@tud@declare} geprüft, ob die der 
% Markup-Befehl in einer der Deklarationsumgebungen oder anderweitig genutzt 
% wird. Für den ersten Fall erfolgt die Weiterverarbeitung der Argumente mit
% \cs{Process@@MarkupDeclare}, andernfalls kommt \cs{Process@@MarkupInline} zum
% Einsatz. Da beide Makros die gleiche Reihenfolge der Argumente verlangen,
% wird der jeweilige Befehlsaufruf über ein Token-Register realisiert, womit
% das Zusammensetzen der notwendigen Übergabewerte erleichtert wird. 
%
% Die Fallunterscheidung betrifft des Weiteren die Erzeugung des Labels. Für 
% eine Deklaration wird die Sternversion von \cs{tud@lbl@get} verwendet, welche
% ein Label aus den gegebenen Argumenten zusammensetzt. Ist keine Deklaration
% aktiv, versucht \cs{tud@lbl@get} ein gültiges, schon vorhandenes Label zu 
% verwenden. Das generierte Label wird anschließend als erstes Argument für das
% weiterverabeitende Makro genutzt.
%    \begin{macrocode}
%<*class>
  \if@tud@declare%
    \tud@toks@{\Process@@MarkupDeclare}%
    \IfValueTF{#4}{%
      \tud@lbl@get*\tud@lbl@tmp{#4:#1}=#2=%
    }{%
      \tud@lbl@get*\tud@lbl@tmp{\tud@bdl@curr:#1}=#2=%
    }%
  \else%
%</class>
    \tud@toks@{\Process@@MarkupInline}%
    \tud@lbl@get\tud@lbl@tmp{#4:#1}=#2=%
%<*class>
  \fi%
%</class>
  \addto@hook@expandafter\tud@toks@{\expandafter{\tud@lbl@tmp}}%
%    \end{macrocode}
% Danach wird der Inhalt des im ersten Argument übergebenen Markup-Befehls in 
% einer Gruppe ein temporäres Makro expandiert und als zweites Argument für die 
% Weiterverarbeitung genutzt.
%    \begin{macrocode}
  \begingroup%
    \Markup@Expandable*%
    \protected@edef\tud@reserved{%
      \noexpand\endgroup%
      \def\noexpand\tud@reserved{#1}%
    }%
  \tud@reserved%
  \addto@hook@expandafter\tud@toks@{\expandafter{\tud@reserved}}%
%    \end{macrocode}
% Es folgen gegebenenfalls die optionalen Argument |=|\meta{Wert}|=| sowie
% \oarg{Ausgabesuffix}~-- falls diese angegeben wurden.
%    \begin{macrocode}
  \IfValueT{#2}{\addto@hook\tud@toks@{=#2=}}%
  \IfValueT{#3}{\addto@hook\tud@toks@{[{#3}]}}%
%    \end{macrocode}
% Erfolgt gerade eine Deklaration, wird mit dem Schalter \cs{if@tud@openindex} 
% eigentlich unterschieden, ob ein öffnender oder ein schließender Indexeintrag
% erzeugt werden soll. Dieser wird mit \cs{Process@@Index} erstellt. Um den 
% schließenden Indexeintrag zu erzeugen, ist die Ausführung des Hauptargumentes 
% der Deklarationsumgebung am Ende dieser notwendig. Dabei soll allerdings das
% Markup nicht noch ein weiteres Mal ausgegeben werden. Deshalb wird der
% Schalter hier genutzt, um lediglich zu Beginn einer Deklaration das Markup 
% auszuführen. Dabei Angaben für eine |'|\meta{Referenzvariante}|'| nicht
% erlaubt.
%   \begin{macrocode}
%<*class>
  \if@tud@declare%
    \if@tud@openindex%
      \IfValueT{#6}{%
        \ClassWarning{tudscrmanual}{%
          It is not possible to use any cross-reference\MessageBreak%
          shorthand like '#6' within the arguments\MessageBreak%
          of the environment `Declaration'%
        }%
      }%
%    \end{macrocode}
% Für ein eventuell notwendiges Debugging, wird \cs{Process@@MarkupDeclare} mit
% seinen Argumenten ggf. in das Log-File geschrieben.
%    \begin{macrocode}
      \tud@trace@markup@add{declare}{\the\tud@toks@}%
    \else%
      \tud@toks@{\relax}%
    \fi%
%    \end{macrocode}
% Findet der Auszeichnungsbefehl außerhalb einer Umgebung für Deklarationen
% Verwendung, werden die optionalen Argumente für einen CTAN-Link 
% |<|\meta{CTAN-Paketname}|>| sowie die Formatierung des Querverweise
% |'|\meta{Referenzvariante}|'| hinzugefügt~-- falls vorhanden. Dies geschieht
% jedoch nur, wenn das Markup nicht innerhalb eines Index erfolgt, da hier
% URL-Hyperlinks und formatierte Querverweise unerwünscht sind. Mit der Angabe
% eines leeren Argumentes |<>| wird gar kein Hyperlink erstellt.
%    \begin{macrocode}
  \else%
%</class>
    \if@tud@index\else%
      \IfValueT{#4}{\addto@hook\tud@toks@{(#4)}}%
      \IfValueT{#5}{%
        \ifxblank{#5}{}{\addto@hook\tud@toks@{<http://www.ctan.org/pkg/#5>}}%
      }%
      \IfValueT{#6}{\addto@hook\tud@toks@{'#6'}}%
    \fi%
%<*class>
%    \end{macrocode}
% Auch hier wird ggf. ein Debug-Eintrag ins Log-File geschrieben. 
%    \begin{macrocode}
    \tud@trace@markup@add{output}{\the\tud@toks@}%
  \fi%
%    \end{macrocode}
% Nun erfolgt mit \cs{Process@@MarkupDeclare} bzw. \cs{Process@@MarkupInline} 
% die Ausführung der eigentlichen Auszeichnung.
%    \begin{macrocode}
%</class>
  \the\tud@toks@%
}
%    \end{macrocode}
% \end{macro}^^A \Markup@@Suppress
% \end{macro}^^A \Markup@Suppress
% \end{macro}^^A \Process@Markup
% \begin{macro}{\Process@@MarkupDeclare}
% \changes{v2.05}{2015/11/05}{neu}^^A
% Mit \cs{Process@@MarkupDeclare} wird die formatierte Ausgabe der Deklaration 
% realisiert. Wie diese genau gestaltet ist, wird durch \cs{tud@declare@num}
% bestimmt. Folgende Werte sind möglich:
% \ToDo{\val{-1/-2} dokumentieren}[v2.07]
% \begin{description}
%   \item[\val{0}:] Ausgabe von Markup, Erzeugen eines Labels
%   \item[\val{1}:] Ausgabe von Markup, kein Label
%   \item[\val{2}:] keine Ausgabe, aber Erzeugen eines Labels
%   \item[\val{3}:] keine Ausgabe, Erzeugen eines nach oben verschobenen Labels
% \end{description}
% Normalerweise kommt die erste Variante zum Einsatz. Die zweite Variante wird 
% genutzt, wenn mit mit der Umgebung \env{Obsolete} zwar eine Ausgabe aber kein 
% Label erstellt werden soll. Dies wird verwendet, um bei der Beschreibung 
% veralteter Werte oder Parameter diese im Kontext ihrer Option oder Umgebung
% bzw. ihres Befehls anzugeben.
%
% Die dritte Version kommt bei Erklärungen mit der Umgebung \env{DeclareEntity*}
% zum Einsatz, welche im Fließtext verwendet wird und kein Markup, wohl aber
% eine Label für das beschriebene Element erzeugt werden soll. Für die vierte
% Variante, welche die Umgebung \env{DeclareEntity} betrifft, gilt dies im 
% Prinzip gleichermaßen. Allerdings wird diese Umgebung zu Beginn der
% Deklarationen einer Entität direkt nach einer Überschrift verwendet. Hier 
% soll der erzeugte Link direkt auf der Höhe der Überschrift platziert werden.
%
% Das erste Argument enthält das zu definierende Label, gefolgt vom Element, 
% welches ausgezeichnet werden soll. Die tatsächliche Ausgabe erfolgt mit dem 
% Makro \cs{Markup@Output}. An dieses werden die beiden optionalen Argumente 
% |=|\meta{Wert}|=| und \oarg{Ausgabesuffix} direkt weitergereicht.
%
% Vor der eigentlichen Ausführung wird mit \cs{Markup@CheckFormat} geprüft, ob 
% für das auszuzeichnende Element mit \cs{Markup@SetFormat} überhaupt eine 
% Ausgabeformatierung defineirt wurde. Nach der Ausgabe wird diese Formatierung 
% mit \cs{Markup@ClearFormat} zurückgesetzt.
%    \begin{macrocode}
%<*class>
\NewDocumentCommand\Process@@MarkupDeclare{m m d== o}{%
  \Markup@CheckFormat%
  \ifcase\tud@declare@num\relax%
    \tudhyperdef{#1}%
    \Markup@Output{#2}=#3=[{#4}]%
  \or%
    \Markup@Output{#2}=#3=[{#4}]%
  \or%
    \tudhyperdef{#1}%
  \or%
    \tudhyperdef*{#1}%
    \def\@tempa##1:##2:##3\@nil{\tudhyperdef*{##3:##2:##3}}%
    \@tempa#1\@nil%
  \else%
    \tudhyperdef{#1}%
    \Markup@Output{#2}=#3=[{#4}]%
  \fi%
  \Markup@ClearFormat%
}
%</class>
%    \end{macrocode}
% \end{macro}^^A \Process@@MarkupDeclare
% \begin{macro}{\Process@@MarkupInline}
% \changes{v2.05}{2015/11/05}{neu}^^A
% Mit \cs{Process@@MarkupInline} wird die formatierte Ausgabe außerhalb der 
% Deklarationsumgebungen umgesetzt. Die ersten vier Argument entsprechen denen
% des Befehls \cs{Process@@MarkupDeclare} und werden bis auf das Label ebenso an
% \cs{Markup@Output} übergeben, nachdem mit dem Befehl \cs{Markup@CheckFormat} 
% auf eine existierende Markup-Definition geprüft wurde.
% \ToDo{
%   Hyperlinks auf erläuterte Element innerhalb der Umgenung \env{Declaration}
%   unterbinden? Könnte \cs{tud@declaration@list} genutzt werden?
% }[v2.07]
%    \begin{macrocode}
\NewDocumentCommand\Process@@MarkupInline{m m d== o d() d<> d''}{%
  \Markup@CheckFormat%
%    \end{macrocode}
% Um die aktuelle Definiton der temporären Makros nicht zu ändern, erfolgt die
% formatierte Ausgabe in einer Gruppe. Dabei wird in \cs{@tempc} die minimale 
% Variante gesichert.
%    \begin{macrocode}
  \begingroup%
    \def\@tempc{\Markup@Output{#2}=#3=[{#4}]}%
%    \end{macrocode}
% Danach wird eine Fallunterscheidung anhand des im ersten Argument übergebenen 
% Labels getroffen. Existiert dieses, soll das Element als Hyperlink ausgegeben 
% werden. Die Definition dafür wird in \cs{@tempa} gespeichert.
%    \begin{macrocode}
%<*class>
    \tud@if@lbl@exists{#1}{%
      \def\@tempa{\hyperref{}{\tud@manualname}{#1}{\@tempc}}%
%    \end{macrocode}
% Anschließend wird \cs{@tempb} ggf. für den erweiterten Querverweis verwendet.
% Wurde ein Format für den Querverweis gesetzt, muss dieses validiert werden. 
% Gültige Kürzel sind |'|\val{auto}|'|, |'|\val{page}|'| und |'|\val{full}|'|. 
% Damit werden die erzeugten Querverweise um den Gliederungsabschnitt, die
% Seite oder beides ergänzt. Außerdem kann mit |'|\val{none}|'| der Hyperlink 
% komplett unterbunden werden. Für den Befehl \cs{Package} kann mit zusätzlich 
% |'|\val{url}|'| noch der CTAN-Link forciert werden, auch wenn eigentlich ein
% Label für das Paket existiert.
%    \begin{macrocode}
      \let\@tempb\relax%
      \IfValueT{#7}{%
        \def\@tempb{%
%<*class>
          \ClassWarning{tudscrmanual}%
%</class>
%<*package>
          \PackageWarning{tudscrtutorial}%
%</package>
          {%
            You've used the unknown cross-reference\MessageBreak%
            shorthand '#7'. Only 'auto', 'page' and 'full'\MessageBreak%
            as well as 'none' \IfValueT{#6}{or 'url' }are valid%
          }%
        }%
        \Ifstr{#7}{auto}{\def\@tempb{ in \autoref{#1}}}{%
        \Ifstr{#7}{ref}{\def\@tempb{ in \autoref{#1}}}{
        \Ifstr{#7}{page}{\def\@tempb{ \vpageref{#1}}}{%
        \Ifstr{#7}{ppage}{\def\@tempb{ \reftextfaraway{#1}}}{%
        \Ifstr{#7}{full}{\def\@tempb{ in \fullref{#1}}}{%
        \Ifstr{#7}{none}{\let\@tempa\@tempc\let\@tempb\relax}{}}}}}}%
        \IfValueT{#6}{%
          \Ifstr{#7}{url}{\def\@tempa{\href{#6}{\@tempc}}\let\@tempb\relax}{}%
        }%
      }%
      \tud@trace@lbl@add{matched}{#1}%
    }{%
%</class>
%    \end{macrocode}
% Existiert kein Label, so wird einfach die minimale Markup-Variante verwendet. 
% Für Pakete wird ein CTAN-Link erzeugt.
%    \begin{macrocode}
      \let\@tempa\@tempc%
      \IfValueT{#6}{\def\@tempa{\href{#6}{\@tempc}}}%
%    \end{macrocode}
% Ein Querverweis kann logischerweise nicht erstellt werden. Wurde dennoch im 
% letzten optionalen Argument eine |'|\meta{Referenzvariante}|'| für den
% Querverweis angegeben, wird eine Warnung erzeugt.
%    \begin{macrocode}
      \let\@tempb\relax%
      \IfValueT{#7}{%
        \Ifstr{#7}{none}{\let\@tempa\@tempc}{%
%<package>        \Ifstr{#7}{manual}{\def\@tempa{\tudhyperref{#1}{\@tempc}}}{%
          \def\@tempb{%
%<*class> 
            \ClassWarning{tudscrmanual}%
%</class>
%<*package>
            \PackageWarning{tudscrtutorial}%
%</package>
            {%
%<*class>
              Label #1\MessageBreak%
              is missing, no cross-reference created%
%</class>
%<*package>
              You've used the unknown cross-reference\MessageBreak%
              shorthand '#7'. Only 'none' and 'manual'\MessageBreak%
              are valid%
%</package>
            }%
          }%
%<package>        }%
        }%
      }%
%    \end{macrocode}
% Um im Zweifel nach allen fehlenden Labels im Log-File prüfen zu können, gibt 
% es den passenden Debug-Befehl.
%    \begin{macrocode}
%<*class>
      \tud@trace@lbl@add{missing}{#1}%
    }%
%</class>
%    \end{macrocode}
% Ganz zum Schluss erfolgt die Ausgabe als Hyperlink mit optional erweitertem 
% Querverweis nicht, wenn gerade eine Überschrift gesetzt wird.
%    \begin{macrocode}
    \if@tud@sec%
      \@tempc%
    \else%
      \@tempa\@tempb%
    \fi%
%    \end{macrocode}
% Zum Schluss wird die Formatierung mit \cs{Markup@ClearFormat} zurückgesetzt.
%    \begin{macrocode}
  \endgroup%
  \Markup@ClearFormat%
}
%    \end{macrocode}
% \end{macro}^^A \Process@@MarkupInline
% \begin{macro}{\Markup@Output}
% \changes{v2.05}{2015/11/05}{neu}^^A
% \begin{macro}{\Markup@@Output}
% \changes{v2.05}{2015/11/05}{neu}^^A
% Der Befehl \cs{Markup@Output} wird für die formatierte Markup-Ausgabe von den
% beiden Makros \cs{Process@@MarkupDeclare} sowie \cs{Process@@MarkupInline}
% aufgerufen. Das erste Argument enthält dabei das auszuzeichnende Element.
% Dabei ist die Besonderheit des Makros \cs{Key}\marg{Makro}\marg{Parameter} zu
% beachten, dessen beiden Argumente hier in der Form \marg{Makro!Parameter} 
% übergeben werden. Deshalb wird das erste Argument mit dem Argumentprozessor 
% \cs{SplitArgument}|{1}{!}| getrennt und dann weiter verarbeitet.
%    \begin{macrocode}
\NewDocumentCommand\Markup@Output{>{\SplitArgument{1}{!}}m r== r[]}{%
  \Markup@@Output#1=#2=[{#3}]%
}
%    \end{macrocode}
% Anschließend wird entweder \cs{Markup@Declare} oder \cs{Markup@Inline}
% aufgerufen~-- abermals abhängig vom Schalter \cs{if@tud@declare}. Auch hier 
% wird für den Befehlsaufruf mit dem dazugehörigen Argument zur Vereinfachung
% ein Token-Register verwendet.
%    \begin{macrocode}
\NewDocumentCommand\Markup@@Output{m m r== r[]}{%
%<*class>
  \if@tud@declare%
    \tud@toks@{\Markup@Declare}%
  \else%
%</class>
    \tud@toks@{\Markup@Inline}%
%<*class>
  \fi%
%</class>
%    \end{macrocode}
% Ist das aktuelle Element \cs{Key} wird nur das zweite Argument ausgegeben. 
% Das erste wird lediglich für Label und Indexeintrag benötigt.
%    \begin{macrocode}
  \IfValueTF{#2}{%
    \def\@tempa{#2}%
  }{%
    \def\@tempa{#1}%
  }%
%    \end{macrocode}
% Die beiden optionalen Argumente werden ggf. in der gleichen Formatierung 
% ausgegeben. 
%    \begin{macrocode}
  \IfValueT{#3}{\appto\@tempa{=#3}}%
  \IfValueT{#4}{\appto\@tempa{#4}}%
  \addto@hook@expandafter\tud@toks@{\expandafter{\@tempa}}%
  \the\tud@toks@%
}
%    \end{macrocode}
% \end{macro}^^A \Markup@@Output
% \end{macro}^^A \Markup@Output
% \begin{macro}{\Markup@Inline}
% \changes{v2.05}{2015/11/05}{neu}^^A
% \begin{macro}{\Markup@Declare}
% \changes{v2.05}{2015/11/05}{neu}^^A
% \begin{macro}{\Markup@@Declare}
% \changes{v2.05}{2015/11/05}{neu}^^A
% Die Ausgabe selbst ist alles andere als spektakulär. Die zur Formatierung 
% verwendeten Makros \cs{Markup@Format} und \cs{Markup@Suffix} werden durch
% \cs{Markup@SetFormat} für jedes Markup-Element individuell definiert.
%    \begin{macrocode}
\newcommand*\Markup@Inline[1]{\mbox{\Markup@Format{#1}}}
%<*class>
\newcommand*\Markup@Declare{}
\newcommand*\Markup@@Declare[1]{\Markup@Format{#1}\Markup@Suffix}
%</class>
%    \end{macrocode}
% \end{macro}^^A \Markup@@Declare
% \end{macro}^^A \Markup@Declare
% \end{macro}^^A \Markup@Inline
% \begin{macro}{\Markup@SetFormat}
% \changes{v2.05}{2015/11/05}{neu}^^A
% \begin{macro}{\Markup@CheckFormat}
% \changes{v2.05}{2015/11/05}{neu}^^A
% \begin{macro}{\Markup@ClearFormat}
% \changes{v2.05}{2015/11/05}{neu}^^A
% \begin{macro}{\Markup@Format}
% \changes{v2.05}{2015/11/05}{neu}^^A
% \begin{macro}{\Markup@Suffix}
% \changes{v2.05}{2015/11/05}{neu}^^A
% Der Befehl \cs{Markup@SetFormat} setzt das gewünschte Format für die jeweilge
% Ausgabe. Dieses wird im ersten Argument angegeben. Das ordinäre optionale 
% Argument kann genutzt werden, wenn bei der Deklaration noch eine genauere 
% Beschreibung oder Spezifizierung erscheinen soll, beispielsweise etwas wie
% \enquote{Umgebung} oder \enquote{Parameter}. Mit dem optionalen Argument in 
% runden Klammern wird es möglich, die Definition von \cs{Markup@Declare}, die 
% ohne eine Angabe der von \cs{Markup@@Declare} entspricht, zu ändern. Dies
% wird insbesondere von \cs{Environment} genutzt, um bei der Deklaration eine
% Tabelle zu erzeugen.
%    \begin{macrocode}
\newcommand*\Markup@Format{}
\undef\Markup@Format
\newcommand*\Markup@Suffix{}
\NewDocumentCommand\Markup@SetFormat{o m o d()}{%
%    \end{macrocode}
% Außerdem ist noch eine weitere Besonderheit zu beachten. Sollte gerade eine
% Überschrift gesetzt werden, wird das Hauptargument nicht formatiert sondern 
% lediglich mit \cs{tud@sec@format} ausgegeben.
%    \begin{macrocode}
  \def\Markup@Format##1{%
    \def\tud@res@a{#2}%
    \tud@ifdin{\let\tud@res@a\tud@sec@format}{}%
    \begingroup\tud@res@a{\IfValueT{#1}{#1}##1}\endgroup%
  }%
  \IfValueT{#3}{\def\Markup@Suffix{\suffix{#3}}}%
%<*class>
  \IfValueT{#4}{\renewcommand*\Markup@Declare[1]{#4\Markup@Suffix}}%
%</class>
}
%    \end{macrocode}
% Nach der formatierten Ausgabe wird \cs{Markup@ClearFormat} aufgerufen, um die 
% aktuell definierte Formatierung zurückzusetzen und bei einem neuen Aufruf 
% eines der Markup-Befehle mit \cs{Markup@CheckFormat} auf die Verwendung von 
% \cs{Markup@SetFormat} prüfen zu können.
%    \begin{macrocode}
\newcommand*\Markup@ClearFormat{%
  \undef\Markup@Format%
  \let\Markup@Declare\Markup@@Declare%
  \let\Markup@Suffix\relax%
}
\Markup@ClearFormat
\newcommand*\Markup@CheckFormat{%
  \ifundef{\Markup@Format}{%
%<*class>
    \ClassError{tudscrmanual}%
%</class>
%<*package>
    \PackageError{tudscrtutorial}%
%</package>
      {\string\Markup@SetFormat\space unused}%
      {It seems you have forgotten to use \string\Markup@SetFormat.}%
  }{}%
}
%    \end{macrocode}
% \end{macro}^^A \Markup@Suffix
% \end{macro}^^A \Markup@Format
% \end{macro}^^A \Markup@ClearFormat
% \end{macro}^^A \Markup@SetFormat
% \end{macro}^^A \Markup@CheckFormat
%
% \iffalse
%<*class>
% \fi
%
% \subsection{Auflistung gültiger Werte von Optionen und Parametern}
%
% \begin{environment}{DeclareValues}
% \changes{v2.07}{2021/06/16}{neu}^^A
% \begin{macro}{\tud@val@main}
% \changes{v2.07}{2021/06/16}{neu}^^A
% \begin{macro}{\tud@val@addon}
% \changes{v2.07}{2021/06/16}{neu}^^A
% \begin{macro}{\tud@val@alias}
% \changes{v2.07}{2021/06/16}{neu}^^A
% \begin{macro}{\tud@val@declaration@list}
% \changes{v2.07}{2021/06/16}{neu}^^A
% \begin{macro}{\tud@val@match}
% \changes{v2.07}{2021/06/16}{neu}^^A
% Die Umgebung \env{DeclareValues} dient zur Beschreibung gültiger Werte für 
% aktuelle Deklarationen von Optionen aber auch Befehls- und Optionsparametern.
%
% Ohne optionales Argument werden in \cs{tud@declaration@inner@list} alle 
% Einträge gesucht, welche zuvor mit den Werten \cs{PMisc} oder \cs{PBoolean} 
% definiert worden und damit potenziell unterschiedliche gültige Werte annehmen 
% können. Ein optionales Argument wird dahingehend geprüft, ob es gerade in der 
% aktuellen Deklaration (\cs{tud@declaration@inner@list}) enthalten ist.
%
% Die eigentliche Listenumgebung \env{Declare@Values} für die Werte wird nach 
% der Initialisierung aufgerufen.
%    \begin{macrocode}
\newcommand*\tud@val@main{}
\newcommand*\tud@val@addon{}
\newcommand*\tud@val@alias{}
\newcommand*\tud@val@declaration@list{}
\NewDocumentEnvironment{DeclareValues}{!o +b}{%
  \tud@declare@check%
  \ifx\tud@declaration@inner@list\@empty%
    \ClassError{tudscrmanual}{Wrong usage of `DeclareValues'}{%
      The environment `DeclareValues' can only be used\MessageBreak%
      within declarations.%
    }%
  \fi%
  \begingroup%
%    \end{macrocode}
% In \cs{tud@res@a} werden alle passenden Deklarationen als Liste gespeichert. 
% Dabei sind nur solche gültig, die \cs{PMisc} oder \cs{PBoolean} verwenden. 
% Diese werden zunächst temporär in \cs{tud@val@declaration@list} gesichert.
% Der Schalter \cs{if@tud@res@swa} wird zu \val{false} gesetzt, falls keine 
% gültigen Treffer erzielt werden konnten.
%    \begin{macrocode}
    \@tud@res@swatrue%
    \let\tud@res@a\@empty%
    \let\tud@val@declaration@list\@empty%
    \def\do##1{%
      \If@Markup@Value@TF[\PMisc,\PBoolean]{##1}{%
%    \end{macrocode}
% Ohne optionales Argument wird bei mehreren Treffern eine Warnung ausgegeben.
%    \begin{macrocode}
        \IfValueF{#1}{%
          \ifx\tud@val@declaration@list\@empty\else\@tud@res@swafalse\fi%
        }%
        \listadd\tud@val@declaration@list{##1}%
      }{}%
    }%
    \dolistloop{\tud@declaration@inner@list}%
%    \end{macrocode}
% Die im optionalen Argument angegebenen Markup-Befehle werden überprüft, ob 
% diese aktuell auch tatsächlich deklariert werden. In \cs{tud@res@a} werden 
% gültige Einträge aus \cs{tud@declaration@inner@list} abgelegt, \cs{tud@res@b}
% enthält die nicht zuzuordnende Markup-Befehle, welche lediglich benötigt 
% werden, um ungültige Angaben zu melden.
%    \begin{macrocode}
    \IfValueTF{#1}{%
      \let\tud@res@b\@empty%
      \def\do##1{%
%    \end{macrocode}
% Der aktuelle Markup-Befehl wird \cs{tud@res@b} hinzugefügt und bei einem 
% Treffer durch \cs{tud@val@match} wieder entfernt.
%    \begin{macrocode}
        \listeadd\tud@res@b{\detokenize{##1}}%
        \forlistloop%
          {\tud@val@match\tud@res@a{\tud@res@b}{##1}}%
          {\tud@val@declaration@list}%
      }%
      \docsvlist{#1}%
%    \end{macrocode}
% Alle in \cs{tud@res@b} abgelegten Markup-Befehle aus dem optionalen Argument 
% konnten nicht zugeordnet werden.
%    \begin{macrocode}
      \def\do##1{%
        \ClassWarning{tudscrmanual}{%
          Argument `\detokenize{##1}' did not match\MessageBreak%
          any current declaration%
        }%
      }%
      \dolistloop{\tud@res@b}%
    }{%
%    \end{macrocode}
% Ohne optionales Argument werden alle potentiellen Einträge verwendet.
%    \begin{macrocode}
      \let\tud@res@a\tud@val@declaration@list%
    }%
%    \end{macrocode}
% Eine leere Liste ist in jedem Fall nicht akzeptabel. Ohne gültige Treffer 
% wird eine Warnung über gar keine oder zu viele, nicht spezifizerte Kandidaten
% ausgegeben.
%    \begin{macrocode}
    \ifx\tud@res@a\@empty%
      \@tud@res@swafalse%
    \fi%
    \if@tud@res@swa\else%
      \let\tud@res@c\@empty%
      \def\do##1{%
        \def\tud@res@d{##1}%
        \Markup@Outer@Get\tud@res@d{\tud@res@d}%
        \eappto\tud@res@c{%
          \detokenize\expandafter{\tud@res@d}\noexpand\MessageBreak%
        }%
      }%
      \ifx\tud@res@a\@empty%
        \let\tud@res@a\tud@declaration@inner@list%
        \@tud@res@swafalse%
      \else%
        \@tud@res@swatrue%
      \fi%
      \dolistloop{\tud@res@a}%
      \if@tud@res@swa%
        \ClassWarning{tudscrmanual}{%
          Multiple matching declarations, one or more of\MessageBreak%
           \tud@res@c should be specified with the\MessageBreak%
           optional argument of `DeclareValues'%
        }%
      \else%
        \ClassWarning{tudscrmanual}{%
          None of the given declarations:\MessageBreak%
          \tud@res@c\IfValueT{#1}{was matched or }holds a special value%
        }%
      \fi%
      \let\tud@res@a\@empty%
    \fi%
%    \end{macrocode}
% Am Ende der Initialisierung enthält \cs{tud@val@declaration@list} alle 
% Einträge aus \cs{tud@declaration@inner@list}, die für die nachfolgende 
% Deklaration der Werte verwendet werden.
%    \begin{macrocode}
    \edef\tud@res@a{%
      \endgroup%
      \unexpanded{\def\tud@val@declaration@list}{\expandonce\tud@res@a}%
    }%
  \tud@res@a%
  \begin{Declare@Values}#2\end{Declare@Values}%
}{}
\NoIndentAfterEnv{DeclareValues}
%    \end{macrocode}
% Hiermit wird geprüft, ob der explizit angegebenen Markupbefehl im dritten 
% Argument mit dem einzelnen Eintrag aus \cs{tud@declaration@inner@list} im
% vierten Argument korreliert.
%    \begin{macrocode}
\newcommand*\tud@val@match[4]{%
%    \end{macrocode}
% Der Vergleich selbst erfolgt auf Basis der zugehörigen Labels.
%    \begin{macrocode}
  \begingroup%
    \@tud@res@swafalse%
    \tud@lbl@get\tud@res@a{#3}%
    \tud@lbl@@get\tud@res@b{#4}%
    \ifx\tud@res@a\tud@res@b%
      \@tud@res@swatrue%
    \else%
      \tud@truncate@value\tud@res@b{\tud@res@b}%
      \ifx\tud@res@a\tud@res@b%
        \@tud@res@swatrue%
      \fi%
    \fi%
%    \end{macrocode}
% Korrelieren die Angaben wird der Eintrag aus \cs{tud@declaration@inner@list} 
% in die Liste im ersten Argument geschrieben und der Markup-Befehl aus der 
% Liste des zweiten Arguments entfernt.
%    \begin{macrocode}
    \edef\tud@res@c{%
      \endgroup%
      \if@tud@res@swa%
        \unexpanded{\listadd#1{#4}}%
        \unexpanded{\listeremove#2{\detokenize{#3}}}%
      \fi%
    }%
  \tud@res@c%
}
%    \end{macrocode}
% \end{macro}^^A \tud@val@match
% \end{macro}^^A \tud@val@declaration@list
% \end{macro}^^A \tud@val@alias
% \end{macro}^^A \tud@val@addon
% \end{macro}^^A \tud@val@main
% \end{environment}^^A DeclareValues
%
% \begin{environment}{Declare@Values}
% \changes{v2.07}{2021/06/16}{neu}^^A
% \begin{macro}{\itemval}
% \changes{v2.07}{2021/06/16}{neu}^^A
% \begin{macro}{\tud@item@val}
% \changes{v2.07}{2021/06/16}{neu}^^A
% \begin{macro}{\tud@item@@val}
% \changes{v2.07}{2021/06/16}{neu}^^A
% \begin{macro}{\tud@val@format}
% \changes{v2.07}{2021/06/16}{neu}^^A
%    \begin{macrocode}
\AtBeginDocument{%
  \newcommand*\itemval{}%
  \undef\itemval%
}
%    \end{macrocode}
% Der Befehl \cs{itemval} ist nur innerhalb von \env{Declare@Values} gültig.
%    \begin{macrocode}
\newcommand*\tud@item@@val{%
  \let\itemval\tud@item@val%
}
\tud@list@create[before=\tud@item@@val]{Declare@Values}{description}{1}
%    \end{macrocode}
% Innerhalb von \env{DeclareValues} kann mit \cs{itemval} das resultierende 
% Verhalten für die Wertzuweisung an eine Option respektive einen Parameter 
% beschrieben werden. Mit der Sternversion lässt sich dabei die Einstellung 
% für den Säumniswert hervorheben. 
%
% Im obligatorischen Argument |=|\meta{Wert}|=| können die möglichen Werte 
% einer Option oder eines Parameters angegeben werden. Sind mehrere Werte
% gleichbedeutend verwendbar, so sind diese mit Komma zu trennen, wobei der 
% erste angegebene Wert für den Untereintrag in den Index verwendet wird. Das 
% erste optionale Argument kann genutzt werden, falls sich der Säumniswert
% beispielsweise für eine Klasse unterscheidet. Das optionale Argument in 
% Guillemets lässt sich für einen Querverweis auf eine weitere Deklaration 
% nutzen. Das letzte optionale Argument fügt einen Änderungseintrag hinzu.
%    \begin{macrocode}
\NewDocumentCommand\tud@item@val{s r== d() d<> o}{%
  \begingroup%
%    \end{macrocode}
% Zunächst werden die Werte aus dem obligatorischen Argument formatiert, wobei 
% für zusätzliche Werte die unformatierten Einträge in \cs{tud@val@alias} zum 
% erzeugen von Labeln, die formatierte Ausgabe in \cs{tud@val@addon} abgelegt 
% wird. Der (formatierte) Haupteintrag wird in \cs{tud@val@main} gesichert.
%    \begin{macrocode}
    \tud@val@format\tud@val@main\tud@val@addon\tud@val@alias{#1}{#2}%
%    \end{macrocode}
% Erstellen des Säumniswertes aus optionalen Argumenten.
%    \begin{macrocode}
    \let\tud@res@d\@empty%
    \IfValueTF{#3}{%
      \appto\tud@res@d{\suffix{S\"aumniswert f\"ur #3}}%
    }{%
      \IfBooleanT{#1}{\appto\tud@res@d{\suffix{S\"aumniswert}}}%
    }%
%    \end{macrocode}
% Erstellen des optionalen Querverweises mithilfe des Markup-Befehls, wobei 
% kein Indexeintrag erzeugt (\verb+||+) und die Seitenzahl der Deklaration 
% referenziert (|'page'|) wird.
%    \begin{macrocode}
    \IfValueT{#4}{%
      \tud@ref@get\tud@res@a{see}{#4}{||'page'}%
      \eappto\tud@res@d{%
        {\unexpanded{\hfill\suffixsize}\expandonce\tud@res@a}%
      }%
    }%
%    \end{macrocode}
% Die in \cs{tud@val@declaration@list} gespeicherten Basis-Deklarationen werden 
% genutzt, um die spezifischen Werte zu deklarieren. Dabei wird lediglich der 
% erste Eintrag inlusive der möglichen Werte ausgegeben. Alle nachfolgenden 
% Einträge aus der Liste werden ohne Ausgabe deklariert (Label, Index).
%    \begin{macrocode}
    \let\tud@res@a\@empty%
    \def\do##1{%
      \begingroup%
%    \end{macrocode}
% Der in der Basis-Deklaration gegebene Wert wird durch den spezifischen mit 
% \cs{Markup@Replace} ersetzt.
%    \begin{macrocode}
        \edef\tud@res@b{%
          \unexpanded{\Markup@Replace\tud@res@b}%
            =\expandonce\tud@val@main=%
            \ifx\tud@val@addon\@empty\else[{\expandonce\tud@val@addon}]\fi%
        }%
        \tud@res@b{##1}%
        \Markup@Outer@Get\tud@res@b{\tud@res@b}%
        \edef\tud@res@c{%
          \endgroup%
%    \end{macrocode}
% In \cs{tud@res@a} werden alle Werte-Deklarationen abgelegt, wobei auch 
% Änderungseinträge sowie mögliche Alias-Label beachtet werden. Sobald ein 
% Eintrag exisitiert, werden alle folgenden Deklarationen mit der Sternversion 
% von \cs{Inline@Declaration} zur Unterdrückung der Ausgabe.
%    \begin{macrocode}
          \unexpanded{\appto\tud@res@a}{%
            \noexpand\Inline@Declaration\ifx\tud@res@a\@empty\else*\fi'%
              \unexpanded{[{#5}]}%
              =\expandonce\tud@val@alias=%
              {\expandonce\tud@res@b}%
          }%
        }%
      \tud@res@c%
    }%
    \dolistloop{\tud@val@declaration@list}%
%    \end{macrocode}
% Abschließend erfolgt die Ausgabe des generierten Eintrags mit \cs{item}. 
% Aufgrund der ggf. mehrmaligen Verwendung von \cs{Inline@Declaration} im 
% optionalen Argument von \cs{item}, würde auch \cs{tud@print@changedatlist} 
% mehrmalig ausgeführt werden, was zu Problemen bei der Ausgabe führt. Deshalb 
% wird \cs{tud@print@changedatlist} zunächst unschädlich gemacht und direkt 
% nach dem Label von \cs{item} aufgerufen.
%    \begin{macrocode}
    \edef\tud@res@a{%
      \endgroup%
      \noexpand\item[{%
        \unexpanded{\let\tud@print@changedatlist\relax}%
        \ifx\tud@res@a\@empty%
          \PValue{???=#2}%
        \else%
          \expandonce\tud@res@a\expandonce\tud@res@d%
        \fi%
      }]%
    }%
  \tud@res@a%
  \tud@print@changedatlist[-1\baselineskip]%
}
%    \end{macrocode}
% Mit diesem Makro wird die kommaseparierte Liste möglicher Werte im letzten 
% Argument formatiert.
%    \begin{macrocode}
\newcommand*\tud@val@format[5]{%
  \begingroup%
    \protected@edef\tud@res@a{#5}%
    \let\tud@res@b\@empty%
    \let\tud@res@c\@empty%
    \let\tud@res@d\@empty%
    \@for\tud@res@a:=\tud@res@a\do{%
      \trim@spaces@in\tud@res@a%
      \ifx\tud@res@a\@empty\else%
%    \end{macrocode}
% Die kommaseparierte Liste wird nach boolschen Werten durchsucht. Diese werden 
% bei der Ausgabe immer als erstes gesetzt, wobei bei mehreren boolschen Werten 
% nur der zuerst aufgetretene akzeptiert wird.
%    \begin{macrocode}
        \TUD@set@ifkey{}{@tempswa}{\tud@res@a}%
        \ifx\FamilyKeyState\FamilyKeyStateProcessed%
          \ifx\tud@res@b\@empty%
            \let\tud@res@b\tud@res@a%
            \if@tempswa%
              \preto\tud@res@d{true,on,yes,}%
            \else%
              \preto\tud@res@d{false,off,no,}%
            \fi%
          \else%
            \ClassWarning{tudscrmanual}{%
              \string\itemval\space already read boolean value\MessageBreak%
              `\tud@res@b' so `\tud@res@a' is ignored%
            }%
          \fi%
        \else%
%    \end{macrocode}
% Für nicht-boolsche Werte wird im Nachgang geprüft (\cs{tud@res@c}), ob die 
% aktuellen Deklarationen auf entsprechend angegeben wurden.
%    \begin{macrocode}
          \eappto\tud@res@c{\ifx\tud@res@c\@empty\else,\fi\expandonce\tud@res@a}%
          \eappto\tud@res@d{,\expandonce\tud@res@a}%
        \fi%
      \fi%
    }%
%    \end{macrocode}
% Sollte mindestens ein nicht-boolscher Wert angegeben worden sein, wird hier 
% geprüft, ob die aktuellen Deklarationen nicht mit |\PBoolean| erfolgt sind.
%    \begin{macrocode}
    \ifx\tud@res@c\@empty\else%
      \def\do##1{%
        \If@Markup@Value@TF[\PBoolean]{##1}{%
          \def\tud@res@a{##1}%
          \Markup@Outer@Get\tud@res@a{\tud@res@a}%
          \ClassWarning{tudscrmanual}{%
            \string\itemval\space read a non-boolean value(s)\MessageBreak%
            `\tud@res@c' so the declaration of\MessageBreak%
            `\tud@res@a'\MessageBreak%
            should be done with `\string\PMisc'%
          }%
        }{}%
      }%
      \dolistloop{\tud@val@declaration@list}%
    \fi%
%    \end{macrocode}
% Die kommaseparierte Liste \cs{tud@res@d} möglicher Werte wird verarbeitet und 
% die Werte werden formatiert, wobei die Sternversion von \cs{itemval} für die 
% Formatierung als Säumniswert genutzt wird. Der erste Wert wird insbesondere 
% für den Indexeintrag benötigt und in \cs{tud@res@a} gesichert, alle weiteren
% Einträge werden in \cs{tud@res@b} gespeichert und lediglich bei der Ausgabe
% aufgelistet. In \cs{tud@res@c} werden die weiteren Einträge unformatiert 
% abgelegt.
%    \begin{macrocode}
    \let\tud@res@a\@empty%
    \let\tud@res@b\@empty%
    \let\tud@res@c\@empty%
    \def\do##1{%
      \def\tud@res@d{##1}%
      \IfBooleanTF{#4}{%
        \PValue@Enfold*{\tud@res@d}%
      }{%
        \PValue@Enfold{\tud@res@d}%
      }%
      \ifx\tud@res@a\@empty%
        \let\tud@res@a\tud@res@d%
      \else%
        \eappto\tud@res@b{\PValue{/}\expandonce\tud@res@d}%
        \eappto\tud@res@c{\ifx\tud@res@c\@empty\else,\fi\expandonce\tud@res@d}%
      \fi%
    }%
    \expandafter\docsvlist\expandafter{\tud@res@d}%
    \edef\tud@res@a{%
      \endgroup%
      \unexpanded{\def#1}{\expandonce\tud@res@a}%
      \unexpanded{\def#2}{\expandonce\tud@res@b}%
      \unexpanded{\def#3}{\expandonce\tud@res@c}%
    }%
  \tud@res@a%
}
%    \end{macrocode}
% \end{macro}^^A \tud@val@format
% \end{macro}^^A \tud@item@@val
% \end{macro}^^A \tud@item@val
% \end{macro}^^A \itemval
% \end{environment}^^A Declare@Values
%
%
% \iffalse
%</class>
%</body>
%<*option>
% \fi
%
% \subsection{Index}
%
% Hier erscheint alles, was für Erstellen und Ausgabe der einzelnen Indexe 
% notwendig ist. Hierfür wird das Paket \pkg{imakeidx} in Verbindung mit 
% \app{texindy} verwendet. Diese können sowohl mit dem Paket als auch mit der 
% Klasse erzeugt werden.
%
% \begin{macro}{\tud@xdy@make}
% \changes{v2.05}{2015/11/01}{neu}^^A
% \begin{macro}{\tud@xdy@settings}
% \changes{v2.05}{2019/10/30}{neu}^^A
% Um die einzelnen Indexe erstellen zu können, wird das Makro \cs{tud@xdy@make} 
% definiert. Die Sternversion dieses Befehle erstellt dabei neben dem normalen
% Spezialindex einen weiteren, welcher explizit für Deklarationen genutzt wird.
% Dieser wird anschließen als erstes an \app{texindy} weitergereicht, um die
% richtige Formatierung der einzelnen Einträge gewährleisten zu können. Erst 
% danach wird die Datei mit den normalen Einträgen verarbeitet. Siehe hierzu 
% auch \cs{Process@@Index}.
%    \begin{macrocode}
\newcommand*\tud@xdy@settings{}
\edef\tud@xdy@settings{-M \@currname-ind.xdy -L german-din}
\NewDocumentCommand\tud@xdy@make{s o m !O{\jobname}}{%
%    \end{macrocode}
% Mit \app{texindy} gibt es Probleme bei der Bildung von Seitenzahlenbereichen
% (siehe auch \file{tudscr-texindy.dtx}). Dies wird umgangen, indem als 
% Deklaration markierte Indexeinträge in einen separaten Index geschrieben und 
% am Ende von \app{texindy} zwei Indexe für jede Kategorie prozessiert werden.
%    \begin{macrocode}
%<*class>
  \IfBooleanT{#1}{\makeindex[name={#4-declare}]}%
%</class>
  \protected@edef\tud@res@a{%
    title={#3},%
    columnsep=\noexpand\f@size\noexpand\p@,%
    name={#4},%
    options={\tud@xdy@settings\space-t \jobname-#4.xlg},%
    \IfValueT{#2}{#2}%
  }%
  \expandafter\makeindex\expandafter[\tud@res@a]%
}
%    \end{macrocode}
% \end{macro}^^A \tud@xdy@settings
% \end{macro}^^A \tud@xdy@make
%
% Damit \pkg{imakeidx} nicht bei jedem Aufruf mit \file{-{}-shell-escape} die 
% Indexe neu erstellt, wird mit \cs{pdf@filemdfivesum} geprüft, ob sich die
% Basisdatei überhaupt seit dem letzten Aufruf geändert hat. Dafür wird die 
% Prüfsumme in aux"~Datei geschrieben, wobei diese dort nur geändert wird, wenn
% das Flag \file{-{}-shell-escape} aktiv ist, da nur dann auch wirklich der 
% nachgelagerte Prozess mit \pkg{imakeidx} auseführt wird.
% \begin{macro}{\tud@idx@mdfive}
% \changes{v2.07}{2019/11/22}{neu}^^A
% Das Makro für die Prüfsumme, welches in die aux"~Datei geschrieben wird.
%    \begin{macrocode}
\newcommand*\tud@idx@mdfive{}
%    \end{macrocode}
% \end{macro}^^A \tud@idx@mdfive
% Hier erfolgt das vergleichen der letzten mit der aktuellen Prüfsumme. Ist 
% diese identisch, kann der nachgelagerte Prozess von \pkg{imakeidx} 
% deaktiviert werden.
%    \begin{macrocode}
\AtBeginDocument{%
  \ifundef{\pdf@filemdfivesum}{}{%
    \PassOptionsToPackage{quiet}{imakeidx}%
    \edef\tud@res@a{\pdf@filemdfivesum{\jobname.idx}}%
%    \end{macrocode}
% Das Paket \pkg{imakeidx} prüft nach dem durch \cs{printindex} initiierten 
% Aufruf von \app{splitindex} nicht, ob \file{\cs{jobname}-\meta{name}.idx} 
% auch tatsächlich exisitiert, was am Ende zu einem fehlerhaften Aufruf von
% \app{texindy} führt. Um dies zu umgehen, wird durch \cs{tud@index@print}
% geprüft, ob die gewünschte Datei auch vorhanden ist, bevor \cs{printindex} 
% ausgeführt wird. Dafür muss \app{splitindex} aber zuvor aufgerufen worden 
% sein, was hier erfolgt.
%    \begin{macrocode}
    \ifnum\pdf@shellescape=\@ne\relax%
      \ifx\tud@idx@mdfive\@empty%
        \ifx\tud@res@a\@empty\else%
          \ShellEscape{splitindex -m \string"\string" \jobname.idx}%
        \fi%
      \fi%
    \fi%
    \ifnum\pdf@strcmp{\tud@res@a}{\tud@idx@mdfive}=\z@\relax%
      \PassOptionsToPackage{noautomatic}{imakeidx}%
    \else%
      \ifnum\pdf@shellescape=\@ne\relax\else%
        \ClassWarningNoLine{tudscrmanual}{%
          The index file `\jobname.idx' has changed. Run again\MessageBreak%
          with --shell-escape flag enabled%
        }%
        \let\tud@res@a\tud@idx@mdfive%
      \fi%
    \fi%
    \immediate\write\@mainaux{\string\gdef\string\tud@idx@mdfive{\tud@res@a}}%
  }%
%    \end{macrocode}
% Nun erfolgt das eigentliche Laden des Paketes.
%    \begin{macrocode}
  \PassOptionsToPackage{xindy,splitindex}{imakeidx}%
  \RequirePackage{imakeidx}[2013/07/11]%
%    \end{macrocode}
% Zuerst ein paar kleinere Einstellungen für das Layout\dots
%    \begin{macrocode}
  \indexsetup{%
%<*class>
    level=\addsec,%
%</class>
%<*package>
    level=\subsection*,%
%</package>
    noclearpage,firstpagestyle=headings,headers={\indexname}{\indexname},%
    othercode={%
      \renewcommand*\@idxitem{\par\hangindent3em}%
      \let\item\@idxitem%
      \renewcommand*\subitem{\@idxitem\hspace*{1em}}%
      \renewcommand*\subsubitem{\@idxitem \hspace*{2em}}%
      \ifundef{\indexspace}{%
        \let\indexspace\relax%
      }{%
        \renewcommand*\indexspace{\par\vskip1em\@plus1ex\@minus.5ex\relax}%
      }%
    }%
  }%
%    \end{macrocode}
% \begin{environment}{theindex}
% \dots gefolgt von einem Patch für die Umgebung \env{theindex}, um unschöne 
% Seitenumbrüche direkt nach Überschriften zu vermeiden. Diese treten auf, das 
% das Paket \pkg{imakeidx} meiner Meinung nach die Überschriften zusammen mit 
% der \env{multicols}-Umgebung falsch setzt. Der Patch sorgt dafür, dass die
% Überschriften (\cs{imki@indexlevel}|{|\cs{indexname}|}|) nicht 
% vor der Umgebung sondern~-- wie für \pkg{multicol} auch dokumentiert~-- im
% optionalen Argument von \env{multicols} aufgerufen werden.
%    \begin{macrocode}
  \ifimki@original\else%
    \CheckCommand\theindex{%
      \imki@maybeaddtotoc
      \imki@indexlevel{\indexname}\imki@indexheaders
      \thispagestyle{\imki@firstpagestyle}%
      \ifnum\imki@columns>\@ne
        \columnsep \imki@columnsep
        \ifx\imki@idxprologue\relax
          \begin{multicols}{\imki@columns}
        \else
          \begin{multicols}{\imki@columns}[\imki@idxprologue]
        \fi
      \else
        \imki@idxprologue
      \fi
      \global\let\imki@idxprologue\relax
      \parindent\z@
      \parskip\z@ \@plus .3\p@\relax
      \columnseprule \ifKV@imki@columnseprule.4\p@\else\z@\fi
      \raggedright
      \let\item\@idxitem
      \imki@othercode%
    }%
    \patchcmd\theindex{%
      \imki@indexlevel{\indexname}\imki@indexheaders%
    }{%
      \imki@indexheaders%
    }{}{\tud@patch@wrn{theindex}}%
    \patchcmd\theindex{%
      \ifnum\imki@columns>\@ne
        \columnsep \imki@columnsep
        \ifx\imki@idxprologue\relax
          \begin{multicols}{\imki@columns}
        \else
          \begin{multicols}{\imki@columns}[\imki@idxprologue]
        \fi
      \else
        \imki@idxprologue
      \fi
    }{%
      \ifnum\imki@columns>\@ne\relax%
        \columnsep \imki@columnsep%
        \ifx\imki@idxprologue\relax%
          \begin{multicols}{\imki@columns}[\imki@indexlevel{\indexname}]%
        \else%
          \begin{multicols}{\imki@columns}[%
            \imki@indexlevel{\indexname}%
            \imki@idxprologue%
          ]%
        \fi%
      \else%
        \imki@indexlevel{\indexname}\imki@idxprologue%
      \fi%
    }{}{\tud@patch@wrn{theindex}}%
  \fi%
%    \end{macrocode}
% \end{environment}^^A theindex
% \begin{macro}{\imki@build}
% Wie zuvor bereits geschildert, gibt es aufgrund einer Eingenheit~-- oder auch 
% eines Bugs~-- von \app{texindy} den Ansatz, den Index für Deklarationen vom
% normalen Index für die unterschiedlichen Indextypen abzuspalten, um Bereiche  
% von Seitenzahlen vernünftig bilden zu können. Damit beiden erzeugten Indexe 
% von \app{texindy} verarbeitet werden können, muss die entsprechende Option
% gesetzt werden. Leider stellt das Paket \pkg{imakeidx} dafür keine geeigneten 
% Mittel zur Verfügung, da sich erst beim Aufruf von \app{texindy} entscheiden 
% lässt, welche Dateien zu prozessieren sind. Die entsprechnden Optionen sind 
% bei \pkg{imakeidx} bereits zum Zeitpunkt des Aufrufs von \cs{makeindex} 
% anzugeben. Deshalb wird später das Makro \cs{imki@options} innerhalb von 
% |\imki@set@|\meta{name} angepasst.
%    \begin{macrocode}
%<*class>
  \CheckCommand*\imki@build[1]{%
    \toks@{}%
    \imki@dokey\imki@title
    \imki@dokey\imki@program
    \imki@dokey\imki@options
    \imki@dokey\imki@columns
    \imki@dokey\imki@columnsep
    \ifKV@imki@noautomatic
      \addto@hook\toks@{\KV@imki@noautomatictrue}%
    \else
      \addto@hook\toks@{\KV@imki@noautomaticfalse}%
    \fi
    \ifKV@imki@intoc
      \addto@hook\toks@{\KV@imki@intoctrue}%
    \else
      \addto@hook\toks@{\KV@imki@intocfalse}%
    \fi
    \ifKV@imki@columnseprule
      \addto@hook\toks@{\KV@imki@columnsepruletrue}%
    \else
      \addto@hook\toks@{\KV@imki@columnseprulefalse}%
    \fi
    \expandafter\edef\csname imki@set@#1\endcsname{\the\toks@}%
  }%
%</class>
%    \end{macrocode}
% \end{macro}^^A \imki@build
% Die Eingabekodierung wird an \app{texindy} weitergereicht.
%    \begin{macrocode}
  \ifundef{\inputencodingname}{}{%
    \eappto\tud@xdy@settings{\space-C\space\inputencodingname}%
  }%
%    \end{macrocode}
% Nun können mit \cs{tud@xdy@make} die einzelnen Indexe erstellt werden.
%    \begin{macrocode}
  \tud@xdy@make{Allgemeiner Index}%
  \tud@xdy@make*{Klassen- und Paketoptionen}[options]%
  \tud@xdy@make*{Befehle und Umgebungen mit zugeh\"origen Parametern}[macros]%
%<*class>
  \tud@xdy@make*{Sprachabh\"angige Bezeichner}[terms]%
  \tud@xdy@make*{Seitenstile, Schriftelemente und Farben}[elements]%
%</class>
  \tud@xdy@make{L\"angen und Z\"ahler}[misc]%
  \tud@xdy@make*{Klassen, Pakete und Dateien}[files]%
%<*class>
  \tud@xdy@make[columns=1]{\"Anderungsliste}[changelog]%
%</class>
}
%    \end{macrocode}
%
% \begin{option}{indexnote}
% \changes{v2.07}{2021/06/09}{neu}^^A
% \begin{macro}{\if@tud@index@note}
% \changes{v2.07}{2021/06/09}{neu}^^A
% Wird diese Option aktiviert, wird für jeden erzeugten Indexeintrag zusätzlich 
% eine Randnotiz zur manuellen Kontrolle erstellt.
%    \begin{macrocode}
\tud@newif\if@tud@index@note
\TUD@key{indexnote}[true]{%
  \TUD@set@ifkey{indexnote}{@tud@index@note}{#1}%
}
\AtEndPreamble{%
  \TUD@key@toolate{indexnote}%
  \if@tud@index@note%
    \AtBeginDocument{\setlength\marginparpush{\z@}}%
  \else%
    \let\tud@index@note@write\@gobbletwo%
  \fi%
}
%    \end{macrocode}
% \end{macro}^^A \if@tud@index@note
% \end{option}^^A indexnote
%
% \iffalse
%</option>
%<*body>
% \fi
%
% \subsubsection{Definition von Indexeinträgen}
%
% \begin{macro}{\@gobbleopt@one}
% \changes{v2.07}{2021/06/15}{neu}^^A
%    \begin{macrocode}
\NewExpandableDocumentCommand\@gobbleopt@one{o m}{}
\tud@outputpage@special{\let\index\@gobbleopt@one}
\tud@addtocontents@special*{\let\index\@gobbleopt@one}
%    \end{macrocode}
% \end{macro}^^A \@gobbleopt@one
%
% \subsubsection{Formatierung von Indexeinträgen}
%
% \begin{macro}{\tud@idx@get}
% \changes{v2.05}{2015/11/05}{neu}^^A
% \begin{macro}{\tud@idx@key}
% \changes{v2.05}{2015/11/05}{neu}^^A
% \begin{macro}{\tud@idx@fmt}
% \changes{v2.05}{2015/11/05}{neu}^^A
% \begin{macro}{\tud@idx@val}
% \changes{v2.05}{2015/11/05}{neu}^^A
% \begin{macro}{\tud@idx@bdl}
% \changes{v2.05}{2015/11/05}{neu}^^A
% Mit dem Makro \cs{tud@idx@get} wird die Formatierung eines Indexeintrags für 
% einen Markup-Befehl realisiert. Für das Sortieren der Indexeinträge kommt 
% \app{texindy} zum Einsatz. Um die Indexeinträge wie gewünscht zu Formatieren, 
% gibt es zwei Möglichkeit. 
%
% Bei der ersten Variante würde der Indexeintrag einfach direkt mit den 
% Markup-Befehlen erstellt und in der \app{texindy}-Stildatei wird für alle
% Auszeichnungsbefehle die passende |merge-rule| erstellt, um die korrekte 
% Sortierung zu gewährleisten. Tatsächlich war in einer früheren Version genau
% das der Ansatz. Allerdings können die manuell erstellten RegExp-Regeln durch 
% \hrfn{http://sourceforge.net/p/xindy/bugs/22/}{\app{texindy} nicht korrekt}
% genutzt werden, weshalb der Ansatz verworfen wurde.
%
% Damit das Sortieren verlässlich funktioniert, werden die Einträge für den 
% Index deshalb in der gewohnten Syntax von \app{makeindex} in der Form
% \meta{Schlüsselwort}|@|\meta{Markup} erstellt. Diese Syntax kann auch mit
% \app{texindy} genutzt werden. 
%
% An \cs{tud@idx@get} werden vier obligatorische gefolgt von vier optionalen 
% Argumenten übergeben. Die ersten beiden Argumente sind die Makros, in welche
% \meta{Schlüsselwort}~-- für gewöhnlich \cs{tud@idx@key}~-- sowie die 
% Formatierung \meta{Markup}~-- normalerweise \cs{tud@idx@fmt}~-- expandiert 
% werden. Mit dem Makro im dritten Argument wird es möglich, Untereinträge zu 
% einem \meta{Schlüsselwort} für beispielsweise Parameter von Umgebungen oder
% Befehlen (\cs{Key}) sowie spezielle Schlüsselwerte von Optionen zu erzeugen.
% Dabei wird vor der Erstellung des Untereintrages der direkt zuvor generierte
% Indexhaupteintrag ins dritte Argument~-- normalerweise \cs{tud@idx@val}~--
% gesichert. Das vierte und letzte obligatorische Argument enthält schließlich 
% den eigentlichen Markup-Befehl, für welchen der Indexeintrag erzeugt werden 
% soll. 
%
% Daran schließen sich vier optionale Argumente an, mit denen die Formatierung 
% des Indexeintrags differenziert werden kann. Das erste optionale Argument 
% |=|\meta{Wert}|=| kann wie bereits gewohnt für das Hinzufügen eines
% Schlüsselwertes genutzt werden. Das zweite, ordinäre optionale Argument 
% \oarg{Anmerkung} fügt dem Eintrag in den Index eine zusätzliche Anmerkung
% hinzu. Soll der Indexeintrag für ein spezifisches Paket oder eine Klasse aus
% dem \TUDScript-Bundle erstellt werden, wird das optionale Argument in runden 
% Klammern \parg{\string\Class\marg{Klasse}/\string\Package\marg{Paket}} für 
% einen Verweis auf das \parg{Entität} verwendet, der in \cs{@idxbundle} 
% gespeichert wird. Das Argument \verb+|+\meta{Indexmarkup}\verb+|+ wird bei
% Deklarationen zur Unterdrückung von Untereinträgen verwendet.
% Der vollständige Funktionsaufruf lautet:
% \newline\begingroup\scriptsize^^A
%   \cs{tud@idx@get}\cs{tud@idx@key}\cs{tud@idx@fmt}^^A
%   \cs{tud@idx@val}\marg{Elem.}|=|\meta{Wert}|=|\oarg{Anm.}^^A
%   \parg{Entität}\verb+|+\meta{Indexmark.}\verb+|+^^A
% \endgroup
% \ToDo{vorherige doc überarbeiten oder raus}[v2.07]
%    \begin{macrocode}
\newcommand*\tud@idx@key{}
\newcommand*\tud@idx@fmt{}
\newcommand*\tud@idx@val{}
\newcommand*\tud@idx@bdl{}
\NewDocumentCommand\tud@idx@get{s m m m m r== r[] r() d||}{%
%    \end{macrocode}
% Die Änderungen an allerhand temporären Makros sollen lokal bleibens.
%    \begin{macrocode}
  \begingroup%
%    \end{macrocode}
% In einer weiteren Gruppe wird der Markup-Befehl des vierten obligatorischen
% Arguments ausgewertet. Es wird eine Fallunterschiedung durchgeführt, ob es 
% sich dabei um einen Parameter (\cs{Key}) handelt oder nicht. Ist dies der
% Fall, wird für diesen Parameter der hier nachfolgend formatierte Indexeintrag
% als Untereintrag verwendet. Dafür wird zuvor ein Haupteintrag aus dem ersten
% Argument von \cs{Key} generiert und in das dritte obligatorische Argument
% gespeichert (\cs{tud@idx@val}).
%    \begin{macrocode}
    \begingroup%
%<*class>
      \let#4\@empty%
      \in@{\Key}{#5}%
%    \end{macrocode}
% Um den Haupteintrag zu extrahieren, wird mit \cs{Markup@Suppress} die Ausgabe
% des Markups deaktiviert und das erste Argument von \cs{Key} ausgeführt. Dies
% führt über \cs{Process@Index} zum rekursiven Aufruf von \cs{tud@idx@get}. Als
% Ergebnis sind im zweiten und dritten Argument~-- sprich in \cs{tud@idx@key} 
% und \cs{tud@idx@fmt}~-- \meta{Markup} und \meta{Schlüsselwort} für den
% Elterneintrag enthalten. Diese werden in das vierte Argument (\cs{idxentry})
% gespeichert.
%    \begin{macrocode}
      \ifin@%
        \Markup@Suppress%
        \let\Key\@firstoftwo%
        #5%
%    \end{macrocode}
% Da der Inhalt des vierten Arguments am Ende der Gruppe expandiert wird, wird 
% mit \cs{expandonce} dafür gesorgt, dass die Expansion nur einmalig erfolgt. 
% Zu beachten ist außerdem, dass der Hauptindexeintrag bereits in der Form 
% \meta{Schlüsselwort}|@|\meta{Markup}|!| zusammengefügt wird. Die Sternversion
% wird für die Änderungsnotizen verwendet. Für diese wird eine kleine Anmerkung
% im Haupteintrag ergänzt.
%    \begin{macrocode}
        \let\@tempa\@empty%
        \IfBooleanT{#1}{\def\@tempa{: Parameter angepasst}}%
        \def#4{%
          \expandonce#2\expandonce\@tempa @%
          \expandonce#3\expandonce\@tempa!%
        }%
      \fi%
%</class>
%    \end{macrocode}
% Nachdem ein möglicher Haupteintrag für Parameter erzeugt wurde, folgt nun 
% der formatierte Indexeintrag für das aktuelle Markup-Element. Um diesen zu
% erstellen, wird für \meta{Schlüsselwort} zunächst nur der Inhalt des
% Hauptargumentes benötigt. Dieser wird hier in das zweite Argument
% expandiert, der ggf. erzeugte Haupteintrag in das vierte. Für \cs{Key} ist
% hier nur noch das zweite Argument relevant.
%    \begin{macrocode}
      \Markup@Expandable%
%<class>      \let\Key\@secondoftwo%
      \edef\tud@reserved{%
        \noexpand\endgroup%
        \def\noexpand#2{#5}%
%<class>        \def\noexpand#4{#4}%
      }%
    \tud@reserved%
%    \end{macrocode}
% Die Auszeichnung für den Indexeintrag besteht in erster Linie aus dem 
% Markup-Befehl selbst. Damit ein |@|"~Zeichen beispielsweise in einem 
% Makronamen korrekt verarbeitet wird, wird dieses im Stil von \app{makeindex} 
% mit |"| maskiert.
%    \begin{macrocode}
    \def#3{#5}%
    \tud@replace@@in#2{@}{"@}%
    \tud@replace@@in#3{@}{"@}%
%    \end{macrocode}
% In \cs{@idxbundle} wird ggf. das Paket oder die Klasse gespeichert, für die 
% der aktuelle Eintrag erzeugt werden soll. Eine explizite Angabe wird in jedem 
% Fall genutzt,\dots
%    \begin{macrocode}
    \let\tud@idx@bdl\tud@bdl@dflt%
    \IfValueTF{#8}{%
      \def\tud@idx@bdl{#8}%
    }{%
%    \end{macrocode}
% \dots eine implizite nur, wenn auch tatsächlich das passende Label existiert, 
% da sonst mit Sicherheit falsche Einträge im Index erscheinen würden.
%    \begin{macrocode}
%<*class>
      \tud@if@bdl{%
        \tud@if@lbl@exists{\tud@bdl@curr:#5}{%
          \edef\tud@idx@bdl{\expandonce\tud@bdl@curr}%
%    \end{macrocode}
% Sollte der Eintrag selbst dem Suffix für Paket oder Klasse entsprechen, wird
% dieser ignoriert.
%    \begin{macrocode}
          \def\tud@reserved{#5}%
          \ifx\tud@reserved\tud@idx@bdl%
            \let\tud@idx@bdl\tud@bdl@dflt%
          \fi%
        }{}%
      }{}%
%</class>
    }%
%    \end{macrocode}
% Nachfolgend wird für den zu erzeugenden Indexeintrag die Zugehörigkeit des
% aktuellen Elements zu einem Paket oder einer Klasse aus dem \TUDScript-Bundle 
% durch das Anhängen des jeweiligen \TUDScript-Bundle-Elements signalisiert.
% Dabei werden für die Anpassung von Schlüssel und Formatierung des Eintrags
% die temporären Makros \cs{@tempa}~(Schlüssel) und \cs{@tempb}~(Formatierung)
% gespeichert. In \cs{@tempc} wird der Inhalt von \cs{@tempb} zwischenzeitlich
% zur späteren Verwendung gesichert.
%    \begin{macrocode}
    \let\@tempa\@empty%
    \let\@tempb\@empty%
    \let\@tempc\@empty%
%    \end{macrocode}
% Der temporäre Schalter \cs{@tempswa} wird genutzt, um das Hinzufügen der 
% Ergänzungen zu steuern. Diese sollen nur für Elemente, welche nicht zu den 
% Hauptklassen gehören, erfolgen.
%    \begin{macrocode}
    \@tempswatrue%
    \ifx\tud@idx@bdl\tud@bdl@dflt%
      \@tempswafalse%
%    \end{macrocode}
% Ebenso werden die Anmerkungen für \cs{Key}-Elemente unterdrückt, da diese 
% sowieso als Untereintrag erzeugt werden. Einträge in der Änderungsliste 
% werden ohnehin separat für jedes \TUDScript-Bundle-Element ausgegeben. In 
% jedem Fall ist jedoch Formatierung beim Markup für das Erzeugen des richtigen 
% Querverweises notwendig und wird in \cs{@tempb} und \cs{@tempc} abgelegt.
%    \begin{macrocode}
    \else%
%<class>      \in@{\Key}{#5}\ifin@\@tempswafalse\fi%
      \IfBooleanT{#1}{\@tempswafalse}%
      \edef\@tempb{(\expandonce\tud@idx@bdl)}%
    \fi%
    \let\@tempc\@tempb%
%    \end{macrocode}
% Der Indexeintrag kann zur besseren Kenntnisnahme außerdem standardmäßig mit 
% einer Beschreibung versehen werden.
%    \begin{macrocode}
    \IfValueT{#7}{%
      \appto\@tempa{ #7}%
      \appto\@tempb{\suffix{#7}}%
    }%
%    \end{macrocode}
% Wird die Anmerkung gesetzt, ist für den Schlüssel nur der Inhalt des in 
% \cs{@idxbundle} gesicherten Markup-Befehls relevant. Dieser wird in der 
% folgenden Gruppe extrahiert und \cs{@tempa} angehangen. Für die Formatierung 
% bleibt das Markup erhalten und wird \cs{tempb} hinzugefügt.
%    \begin{macrocode}
    \if@tempswa%
      \begingroup%
        \Markup@Expandable%
        \edef\tud@reserved{%
          \noexpand\endgroup%
          \noexpand\appto\noexpand\@tempa{ \tud@idx@bdl}%
        }%
      \tud@reserved%
      \eappto\@tempb{\suffix{\expandonce\tud@idx@bdl}}%
    \fi%
%    \end{macrocode}
% Sollte mit |=|\meta{Wert}|=| ein spezieller Schlüsselwert angegeben worden
% sein, wird für diesen normalerweise ein separater Untereintrag erstellt. Der
% Schalter \cs{@tempswa} wird genutzt, um das Erzeugen dieses Untereintrages im
% Zweifel zu unterdrücken und diesen stattdessen als normalen Eintrag zu
% setzen. Dies ist zum einen bei Deklarationen und zum anderen in der
% Änderungsliste notwendig. Außerdem kann dies auch mit der Angabe von 
% \val{default} als Indexargument erzwungen werden.
%    \begin{macrocode}
    \@tempswafalse%
    \IfBooleanT{#1}{\@tempswatrue}%
    \IfValueT{#9}{%
      \Ifstr{#9}{declare}{%
        \@tempswatrue%
        \tud@doifPValue{#6}{\noexpand\@tempswafalse}%
      }{}%
      \Ifstr{#9}{default}{\@tempswatrue}{}%
    }%
%    \end{macrocode}
% In diesem Fall werden die Ergänzungen für Schlüssel und Formatierung ggf. um 
% die speziellen Schlüsselwerte für das Element ergänzt.
%    \begin{macrocode}
    \if@tempswa%
      \protected@eappto#2{\expandonce\@tempa}%
      \tud@doifPValue{#6}{\noexpand\appto\noexpand#2{=#6}}%
      \protected@eappto#3{\IfValueT{#6}{=#6=}\expandonce\@tempb}%
%    \end{macrocode}
% Andernfalls wird geprüft, ob ein verwertbarer Schlüsselwert angegeben wurde.
%    \begin{macrocode}
    \else%
      \tud@doifPValue{#6}{\noexpand\@tempswatrue}%
%    \end{macrocode}
% Ist dies der Fall, wird aus den bisherigen Eingaben der Haupteintrag und 
% daran anschließend der dazugehörige Untereintrag erstellt\dots
%    \begin{macrocode}
      \if@tempswa%
        \eappto#4{%
          \expandonce#2\expandonce\@tempa @%
          \expandonce#3\expandonce\@tempb!%
        }%
        \appto#2{=#6}%
        \appto#3{=#6=}%
        \protected@eappto#3{\expandonce\@tempc}%
%    \end{macrocode}
% \dots andernfalls bleibt es bei einem normalem Eintrag in den Index.
%    \begin{macrocode}
      \else%
        \protected@eappto#2{\expandonce\@tempa}%
        \protected@eappto#3{\expandonce\@tempb}%
      \fi%
    \fi%
%    \end{macrocode}
% Die Erzeugung eines formatierten Indexeintrages ist beendet, das Resultat 
% wird nach der letzten Gruppe definiert.
%    \begin{macrocode}
    \let\emph\@firstofone%
    \protected@edef\tud@reserved{%
      \noexpand\endgroup%
      \def\noexpand#2{#2}%
      \def\noexpand#3{#3}%
      \def\noexpand#4{#4}%
    }%
  \tud@reserved%
}
%    \end{macrocode}
% \end{macro}^^A \tud@idx@bdl
% \end{macro}^^A \tud@idx@val
% \end{macro}^^A \tud@idx@fmt
% \end{macro}^^A \tud@idx@key
% \end{macro}^^A \tud@idx@get
%
% \begin{macro}{\cleversee}
% \changes{v2.05}{2015/11/02}{neu}^^A
% \begin{macro}{\cleverseealso}
% \changes{v2.05}{2015/11/02}{neu}^^A
% \begin{macro}{\tud@cleversee}
% \changes{v2.05}{2015/11/02}{neu}^^A
% \changes{v2.05k}{2017/03/20}{neu}^^A
% Diese Befehle dienen zum smarten Setzen von Hinweisen im Index. Existiert 
% lediglich dieser Hinweis im Index, wird dieser mit dem Präfix \cs{seename} 
% ausgegeben. Sind jedoch für einen Indexeintrag auch Seitenzahlen vorhanden, 
% so werden diese zuerst ausgegeben, danach folgt der Querverweis mit dem 
% Präfix \cs{seealsoname}. Der Befehl \cs{cleverseealso} verwendet letzteren 
% Präfix in jedem Fall.
%    \begin{macrocode}
\newrobustcmd*\cleversee{\tud@cleversee{\seename}}
\newrobustcmd*\cleverseealso{%
%<*class>
  \ClassWarning{tudscrmanual}%
%</class>
%<*package>
  \PackageWarning{tudscrtutorial}%
%</package>
    {You should use `|see' instead of `|seealso'}%
  \tud@cleversee{\alsoname}%
}
%    \end{macrocode}
% Diese Makro übernimmt die eigentliche Arbeit. Es ist darauf angewiesen, dass 
% die angegebene Seitenzahlen eines Indexeintrages erst \emph{nach} den
% Hinweisen ausgegeben und mit \cs{relax} abgeschlossen werden. Dies wird mit
% der später definierten Stildatei für \app{texindy} sichergestellt. So wird es 
% möglich, dass das Makro \cs{tud@cleversee} auf alles ihm bis \cs{relax} 
% nachfolgende parsen kann und abhängig davon die Ausgabe gestaltet. Das zweite 
% obligatorische Argument beinhaltet dabei den Querverweis, das dritte Argument
% ist alles nachfolgende bis \cs{relax}.
%    \begin{macrocode}
\newcommand*\tud@cleversee{}
\def\tud@cleversee#1#2#3\relax{%
  \IfArgIsEmpty{#3}{%
    \emph{#1}\space#2%
  }{%
%    \end{macrocode}
% Folgen im Index nach \cs{cleversee}\marg{Querverweis} noch weitere Einträge, 
% so sind diese zu Beginn durch \texttt{,\textvisiblespace} getrennt. Diese 
% zwei Zeichen werden mithilfe von \cs{@tempa} ignoriert.
%    \begin{macrocode}
    \begingroup%
      \def\@tempa, ##1\@nil{##1,\space\emph{\alsoname}\space#2}%
      \@tempa#3\@nil%
    \endgroup%
  }%
}
%    \end{macrocode}
% \end{macro}^^A \tud@cleversee
% \end{macro}^^A \cleverseealso
% \end{macro}^^A \cleversee
% \begin{macro}{\seeref}
% \changes{v2.05}{2015/11/02}{neu}^^A
% \begin{macro}{\seeidx}
% Der Befehl \cs{seeref} kann anstelle von \cs{see} bzw. in der Sternversion
% statt \cs{alsosee} genutzt werden. Das Makro \cs{seeidx} verweist auf die 
% Seite eines Indexes.
%    \begin{macrocode}
%<*class>
\NewDocumentCommand\seeref{s m}{%
  \emph{\IfBooleanTF{#1}{\alsoname}{\seename}}\space#2%
}
\newcommand*\seeidx[2]{\pageref{idx:#1}}
%</class>
%    \end{macrocode}
% \end{macro}^^A \seeidx
% \end{macro}^^A \seeref
%
% \subsubsection{Erstellen von Indexeinträgen}
%
% \begin{macro}{\Process@Index}
% \changes{v2.05}{2015/11/15}{neu}^^A
% \begin{macro}{\Process@@Index}
% \changes{v2.05}{2015/11/15}{neu}^^A
% Mit \cs{Process@Index} wird geprüft, ob mit dem im zweiten obligatorischen 
% Argument enthaltenen Markup-Befehl ein Indexeintrag erzeugt werden soll. 
% Ein Indexeintrag kann mit der Sternversion eines Markup-Befehls explizit 
% unterdrückt werden, wobei der boolesche Wert im ersten obligatorischen 
% Argument an \cs{Process@Index} zu Prüfung übergeben wird. Außerdem wird für
% obsolete Deklarationen ebenso wie bei aktiviertem Schalter \cs{if@tud@index} 
% kein Eintrag erstellt. In allen genannten Fällen passiert beim Aufruf von 
% \cs{Process@Index} nichts, andernfalls wird \cs{Process@@Index} ausgeführt.
%
% Die auf die zwei obligatorischen Argumente folgenden optionalen sind in der
% Nomenklatur identisch zu den bisherigen Erläuterungen, der vollständige 
% Funktionsaufruf lautet:
% \newline\begingroup\scriptsize^^A
%   \cs{Process@Index}\marg{Stern?}\marg{Element}^^A
%   |=|\meta{Wert}|=|\oarg{Anmerkung}\parg{Entität}^^A
%   \verb+|+\meta{Indexmarkup}\verb+|+^^A
% \endgroup
% \ToDo{vorherige doc überarbeiten oder raus}[v2.07]
%    \begin{macrocode}
\NewDocumentCommand\Process@Index{m m d== o d() d||}{%
  \ifboolexpr{%
%<class>    bool {@tud@index} or bool {@tud@obsolete}%
%<package>    bool {@tud@index}%
  }{}{%
    \IfBooleanTF{#1}{%
      \IfValueT{#6}{%
%<*class> 
        \ClassWarning{tudscrmanual}%
%</class>
%<*package>
        \PackageWarning{tudscrtutorial}%
%</package>
        {%
          You've used the starred version. No index entry\MessageBreak%
          for #2 is created. The\MessageBreak%
          optional argument |#6| will be ignored%
        }%
      }%
    }{%
      \Process@@Index{#2}=#3=[{#4}](#5)|#6|%
    }%
  }%
}
%    \end{macrocode}
% Mit \cs{Process@@Index} erfolgt die eigentliche Erzeugung des Indexeintrages.
%    \begin{macrocode}
\NewDocumentCommand\Process@@Index{m r== r[] r() r||}{%
%    \end{macrocode}
% Dabei erledigt \cs{tud@idx@get} einen Großteil der Aufgabe. Mit besagtem 
% Makro werden Schlüssel und Format für den gewünschten Indexeintrag erzeugt.
% Sollte optional ein spezieller |=|\meta{Wert}|=| für einen Schlüssel gegeben
% sein, so wird ggf. auch der passende Haupteintrag erstellt.
%    \begin{macrocode}
%<*class>
  \if@tud@declare%
    \tud@idx@get\tud@idx@key\tud@idx@fmt\tud@idx@val{#1}=#2=[{#3}](#4)|declare|%
  \else%
%</class>
    \tud@idx@get\tud@idx@key\tud@idx@fmt\tud@idx@val{#1}=#2=[{#3}](#4)|#5|%
%<*class>
  \fi%
%</class>
%    \end{macrocode}
% Mit der Sternversion \cs{tud@attr@get*} wird der Zielindex für das im 
% ersten Argument übergebene \marg{Element} ermittelt.
%    \begin{macrocode}
  \tud@attr@get*\tud@lbl@tmp{#1}%
%    \end{macrocode}
% Markup-Befehle, welche in Deklarationen verwendet wurden, werden für eine 
% höhere Priorisierung in einem speziellen Index angelegt, wobei hier die 
% Formatierung dieses Eintrags fest vorgegeben ist.
%    \begin{macrocode}
%<*class>
  \if@tud@declare%
    \if@tud@openindex%
      \IfValueT{#5}{%
        \ClassWarning{tudscrmanual}{%
          It is not possible to use any indexing format\MessageBreak%
          like |#5| within the arguments of the\MessageBreak%
          environments `Declaration' or `DeclareEntity*'%
        }%
      }%
%    \end{macrocode}
% Jetzt folgt~-- abhängig vom Schalter \cs{if@tud@openindex}~-- der öffnende 
% oder schließende Indexeintrag der Deklaration. Für den schließenden ist dabei
% eine Formatierung des Schlüssels nicht notwendig.
%    \begin{macrocode}
      \index[\tud@lbl@tmp-declare]{%
        \tud@idx@val\tud@idx@key @\tud@idx@fmt|(declare%
      }%
    \else%
      \index[\tud@lbl@tmp-declare]{%
        \tud@idx@val\tud@idx@key @\tud@idx@fmt|declare)%
      }%
    \fi%
%    \end{macrocode}
% Für Markup-Befehle außerhalb von Deklarationsumgebungen wird ein einfacher 
% Eintrag in den Index erzeugt, wobei auch im Fließtext über das Indexmarkup 
% \verb+|+\val{declare}\verb+|+ eine Quasi-Deklaration verwendet werden kann. 
% Dies wird beispielsweise für \KOMAScript-Optionen genutzt, um diese in der 
% gewünschten Formatierung im Index erscheinen zu lassen.
%    \begin{macrocode}    
  \else%
%</class>
    \IfValueT{#5}{%
%<*class>
      \Ifstr{#5}{declare}{%
        \appto\tud@lbl@tmp{-declare}%
        \appto\tud@idx@fmt{|declare}%
      }{%
        \appto\tud@idx@fmt{|#5}%
      }%
%</class>
%<*package>
      \appto\tud@idx@fmt{|#5}%
%</package>
    }%
    \index[\tud@lbl@tmp]{\tud@idx@val\tud@idx@key @\tud@idx@fmt}%
%<*class>
  \fi%
%</class>
}
%    \end{macrocode}
% \end{macro}^^A \Process@@Index
% \end{macro}^^A \Process@Index
%
% \iffalse
%<*class>
% \fi
%
% \begin{macro}{\CrossIndex}
% Der Befehl \cs{CrossIndex} dient zum Eintragen eines Schlagwortes, welches im 
% ersten obligatorischen Argument angegeben wird, in den allgemeinen Index und
% verweist auf den im zweiten obligatorischen Argument, zum Schlagwort gehörigen
% Spezialindex. Das ordinäre optionale Argument kann verwendet werden, um ggf.
% den Eintrag in den allgemeinen Index, der normalerweise mit dem jeweiligen
% Schlagwort erfolgt, zu überschrieben.
%
% Wird die Sternversion von \cs{CrossIndex} genutzt, so wird der Querverweis 
% als Eintrag in der obersten Ebene gesetzt, andernfalls wird ein Untereintrag
% gesetzt. Mit der normalen Variante können so zu einem Schlagwort weitere
% Verweise im allgemeinen Index erscheinen. Das zweite obligatorische Argument
% kann eine kommagetrennte Liste enthalten.
%    \begin{macrocode}
\NewDocumentCommand\CrossIndex{s m o m}{%
  \def\@tempa##1##2##3{%
    \index{%
      \IfBooleanTF{#1}{##3@##3}{##3!"|@}%
      \,\textrightarrow\,%
      \tudhyperref{idx:##2}{\IfValueTF{##1}{##1}{Index der ##3}}|seeidx{##2}%
    }%
  }%
  \forcsvlist{\@tempa{#3}{#4}}{#2}%
}
%    \end{macrocode}
% \end{macro}^^A \CrossIndex
% \begin{macro}{\SeeRef}
% \changes{v2.05}{2015/11/05}{neu}^^A
% Mit \cs{SeeRef} wird unter dem im ersten Argument gegebenen Schlagwort ein
% Indexuntereintrag erzeugt, der wiederum auf einen Indexeintrag des zweiten 
% Argumentes verweist. Dabei kann im zweiten Argument ein normaler Begriff oder 
% ein Markup-Befehl verwendet werden. Normalerweise wird für den Querverweis 
% die Referenzklasse \verb+|see+ verwendet, die Sternversion des Befehls
% hingegen nutzt \verb+|seeunverified+, um auf eine Prüfung des verwiesenen
% Eintrags zu verzichten.
%    \begin{macrocode}
\NewDocumentCommand\SeeRef{s m m}{%
  \sbox\z@{%
    \let\tud@idx@fmt\relax%
    #3%
%    \end{macrocode}
% Wurde im zweiten Argument ein Markup-Befehl angegeben, so wurde durch das 
% Erstellen der Box das dazugehörige Indexformat in \cs{tud@idx@fmt} für den
% Eintrag erstellt. Andernfalls wurde die Definiton von \cs{tud@idx@fmt} nicht 
% geändert und das Argument wird nach der Box direkt in den Index eingetragen.
%    \begin{macrocode}
    \ifx\tud@idx@fmt\relax%
      \gdef\tud@reserved{#3}%
    \else%
      \global\let\tud@reserved\tud@idx@fmt%
    \fi%
  }%
  \IfBooleanTF{#1}{\def\tud@idx@fmt{seeunverified}}{\def\tud@idx@fmt{see}}%
  \index{#2!#3|\tud@idx@fmt{\tud@reserved}}%
}
%    \end{macrocode}
% \end{macro}^^A \SeeRef
%
% \iffalse
%</class>
% \fi
%
% \subsubsection{Indexausgabe}
%
% Dies sind alle Befehle, die zur Ausgabe der erzeugten Indexe benötigt werden.
% \begin{macro}{\PrintIndex}
% \changes{v2.02}{2014/08/20}{neu}^^A
% Mit \cs{PrintIndex} erfolgt die Ausgabe aller erstellten Indexe. Dabei wird 
% für bestimmte Spezialindexe \cs{indexprologue} aus dem Paket \pkg{imakeidx} 
% genutzt, um für diese vor der eigentlichen Ausgabe einige Anmerkungen machen
% zu können.
%    \begin{macrocode}
\newcommand*\PrintIndex{%
  \begingroup%
    \@tud@indextrue%
    \providecommand*\lettergroup[1]{%
      \par\textbf{\textsf{##1}}\par%
      \nopagebreak%
    }%
    \tud@index@print%
    (%
%<*class>
      Die im Folgenden aufgelisteten Schlagworte sollen f\"ur den Umgang mit %
      \Logo{LaTeXe} im Allgemeinen sowie dem \TUDScript-Bundle im Speziellen %
      sowohl Antworten bei generellen Fragen liefern als auch L\"osungen f\"ur %
      typische Probleme bereitstellen. Falls ein gesuchter Begriff hier nicht %
      zu finden ist oder trotz vorhandener Hinweise kein zufriedenstellendes %
      Ergebnis erzielt werden kann, sollte das \Forum erster Anlaufpunkt %
      sein, um weitere Hilfe bei der Nutzung von \TUDScript zu erhalten.%
%</class>
%<*package>
      \let\lettergroup\@gobble%
      \let\indexspace\relax%
%</package>
    )%
%<*class>
    \clearpage%
%</class>
    \tud@index@print[options]%
%<*class>
    (%
      Dies ist der Index aller im Handbuch erl\"auterten sowie erw\"ahnten %
      Optionen, wobei bei den meisten auch Untereintr\"age mit Seitenangaben %
      f\"ur spezielle Wertzuweisungen existieren.%
    )%
%</class>
    \tud@index@print[macros]%
%<*class>
    (%
      Dies ist eine Auflistung aller zuvor erl\"auterten sowie erw\"ahnten %
      Befehle und Umgebungen. Bei einigen sind zus\"atzliche Untereintr\"age %
      f\"ur Schl\"ussel-Wert-Parameter zu finden, die im optionalen Argument %
      der jeweiligen Anweisung verwendet werden k\"onnen. Gegebenenfalls sind %
      f\"ur explizite Wertzuweisungen an diese Parameter Seitenverweise zu %
      finden.%
    )%
%</class>
%<*class>
    \tud@index@print[terms]%
    (%
      Dies sind die von \TUDScript definierten beziehungsweise erw\"ahnten, %
      sprachabh\"angigen Bezeichner. Informationen zur Verwendung sowie den %
      Anpassungsm\"oglichkeiten sind in \autoref{sec:localization} zu finden.%
    )%
    \tud@index@print[elements]%
%</class>
    \tud@index@print[misc]%
%<*package>
    (%
      \let\lettergroup\@gobble%
      \let\indexspace\relax%
    )%
%</package>
    \tud@index@print[files]%
  \endgroup%
}
%    \end{macrocode}
% \end{macro}^^A \PrintIndex
% \begin{macro}{\tud@index@print}
% \changes{v2.02}{2014/07/25}{neu}^^A
% \begin{macro}{\tud@idx@vskip}
% \changes{v2.02}{2014/09/02}{neu}^^A
% Mit \cs{tud@index@print} erfolgt die Ausgabe der einzelnen Indexe. Dabei wird
% in der Klasse \cls{tudscrmanual} zuvor für jeden Index ein referenzierbares
% Label erstellt und ggf. der Prolog gesetzt.
%
% Aufgrund der Verwendung der \env{multicols}-Umgebung durch das Paket
% \pkg{imakeidx} werden normalerweise ohne einen Prolog zu große vertikale
% Abstände nach der Überschrift und am Ende des Index gesetzt. Dies wird mit
% \cs{tud@idx@vskip} behoben.
%    \begin{macrocode}
\newcommand*\tud@idx@vskip{%
  \ifnum\imki@columns>\@ne\relax\vspace{-\multicolsep}\fi%
}
\NewDocumentCommand\tud@index@print{!O{\jobname} !+d()}{%
%    \end{macrocode}
% Falls ein zusätzlicher Deklarationsindex erstellt wurde, müssen die Optionen 
% beim Aufruf von \app{texindy} angepasst werden. Da auf das Vorhandensein der 
% entsprechenden Datei erst hier geprüft werden kann, ist dies nicht über das 
% Interface von \pkg{imakeidx} möglich. Für dieses Unterfangen wird der Befehl
% |\imki@set@|\meta{name} genutzt, welcher die individuellen Einstellungen 
% des jeweiligen Index beinhaltet. Dieser wird in einer Gruppe aufgerufen, 
% anschließend werden dem darin definierten Befehl \cs{imki@options} die 
% benötigten Flags für \app{texindy} für die Ausgabe- und Indexdatei angehangen 
% und an das Ende von |\imki@set@|\meta{name} zurückgeschrieben. So wird der 
% Aufruf \file{texindy \cs{imki@options} \cs{jobname}-\meta{name}.idx} zu
% \begin{quote}\raggedright^^A
% \file{texindy \cs{imki@options} -o \jobname-\meta{name}.ind}\newline
% \null\qquad\file{\jobname-\meta{name}-declare.idx \jobname-\meta{name}.idx}
% \end{quote}
% gepatcht. Damit werden beide Dateien von \app{texindy} verarbeitet, wobei die 
% Einträge in \file{\jobname-\meta{name}-declare.idx} priorisiert werden.
%    \begin{macrocode}
  \IfFileExists{\jobname-#1-declare.idx}{%
    \begingroup%
      \csuse{imki@set@#1}%
      \protected@edef\tud@res@a{%
        \endgroup%
        \noexpand\csappto{imki@set@#1}{%
          \unexpanded{\def\imki@options}{%
            \imki@options\space-o \jobname-#1.ind\space%
            \jobname-#1-declare.idx\space%
          }%
        }%
      }%
    \tud@res@a%
%    \end{macrocode}
% Jetzt muss noch dafür Sorge getragen werden, dass die zweite Datei auch 
% vorhanden ist, da sonst der Aufruf von \app{texindy} ebenfalls fehlerhaft 
% endet.
%    \begin{macrocode}
    \IfFileExists{\jobname-#1.idx}{}{%
      \immediate\openout\tud@write@a=\jobname-#1.idx\relax%
      \immediate\closeout\tud@write@a%
    }%
  }{}%
%    \end{macrocode}
% Falls ein Seitenumbruch notwendig ist, sollte dieser vor dem Index und nicht 
% unmittelbar nach dem Beginn erfolgen.
%    \begin{macrocode}
  \IfFileExists{\jobname-#1.idx}{%
    \pagebreak[3]%
%<*class>
%    \end{macrocode}
% Das zu erstellende Label wird mit der Sternversion von \cs{tudhyperdef}
% gesetzt, um dieses auf die Höhe der Überschrift zu setzen. Mit Prolog wird
% der fehlerhafte vertikale Abstand nach diesem korrigiert, andernfalls sofort.
%    \begin{macrocode}
    \IfValueTF{#2}{%
      \indexprologue{\tudhyperdef*{idx:#1}#2\tud@idx@vskip}%
    }{%
      \indexprologue[\tud@idx@vskip]{\tudhyperdef*{idx:#1}}%
    }%
%</class>
%    \end{macrocode}
% Fur das Paket \pkg{tudscrtutorial} erfolgt eine einfache Ausgabe der Indexe.
% Hier wird das zweite optionale Argument im Zweifel nur für Makrodefinitionen
% genutzt.
%    \begin{macrocode}
%<*package>
    \indexprologue[\tud@idx@vskip]{}%
    \begingroup%
    \IfValueT{#2}{#2}%
%</package>
%    \end{macrocode}
% Die Ausgabe des gewünschten Index.
%    \begin{macrocode}
    \printindex[{#1}]%
    \IfFileExists{\jobname-#1.ind}{}{%
      \immediate\write\@mainaux{\string\gdef\string\tud@idx@mdfive{}}%
    }%
%<*package>
    \endgroup%
%</package>
    \tud@idx@vskip%
  }{%
    \ClassWarning{tudscrmanual}%
    {%
      No index entries found, index file\MessageBreak%
      `\jobname-#1.idx' does not exist%
    }%
  }%
}
%    \end{macrocode}
% \end{macro}^^A \tud@idx@vskip
% \end{macro}^^A \tud@index@print
%
% \iffalse
%<*class>
% \fi
%
% \subsection{Änderungsliste}
%
% Um dem Anwender einen schnellen Überblick zu Änderungen der aktuellen Version 
% bereitstellen zu können, werden Befehle zur automatisierten Erzeugung einer 
% solchen Liste definiert. Die Änderungsliste ist der Klasse \cls{tudscrmanual} 
% vorbehalten.
%
% Änderungsnotizen lassen sich auf zwei unterschiedlichen Wegen generieren. 
% Entweder über die Nutzung von \cs{ChangedAt} oder über das optionale Argument
% einer der Deklarationsumgebungen. Diese sind in der Form 
% \meta{Versionsnummer}|:|\meta{Änderungsnotiz} anzugeben. Die alleinige Angabe
% der Versionsnummer ohne Änderungsnotiz ist ebenso möglich.
%
% Wird die Änderungsnotiz für ein bestimmtes Element wie eine Option oder ein 
% Befehl erstellt, wie es bei den Deklarationsumgebungen implizit oder bei der 
% Verwendung von \cs{ChangedAt} mit optionalem Argument geschieht, gibt es die 
% zusätzliche Möglichkeit, einen Untereintrag zu erstellen. Dabei ist dieser 
% nach Versionsnummer und vor Änderungsnotiz in folgender Form anzugeben: 
% \meta{Versionsnummer}|!|\meta{Untereintrag}|:|\meta{Änderungsnotiz}. Der
% Untereintrag ist für die explizite Angabe eines Schlüssel-Wert-Paares gedacht.
% \begin{macro}{\if@tud@changedat}
% \begin{macro}{\Process@ChangedAt}
% \changes{v2.02}{2014/07/25}{erweitert}^^A
% \changes{v2.02}{2014/10/08}{Sternversion ergänzt}^^A
% Der Schalter \cs{if@tud@changedat} wird im weiteren Verlauf dazu verwendet, 
% das Standardverhalten der einzelnen Markup-Befehle kurzeitig zu ändern und
% anstelle der Makros \cs{Process@Markup} und \cs{Process@Index} den Befehl 
% \cs{Process@ChangedAt} auszuführen, mit welchem die Formatierung der Einträge 
% der Änderungsliste erfolgt.
%   \begin{macrocode}
\tud@newif\if@tud@changedat
%    \end{macrocode}
% Die Formatierung der Änderungseinträge erfolgt~-- wie auch für den Index~-- 
% mit dem Makro \cs{tud@idx@get}, wobei die Sternversion für die Identifikation
% als Änderungseintrag fungiert. Aufgerufen wird \cs{Process@ChangedAt} während 
% der Erstellung der Änderungseinträge mit \cs{Changed@At@CreateEntry}. Der
% Aufruf des Makros erfolgt dabei in gewohnter Form mit einem obligatorischen 
% gefolgt von drei optionalen Argumenten:
% \newline\begingroup\scriptsize^^A
%   \cs{Process@ChangedAt}\marg{Element}|=|\meta{Wert}|=|^^A
%   \oarg{Ausgabesuffix}\parg{Entität}^^A
% \endgroup
% \ToDo{vorherige doc überarbeiten oder raus}[v2.07]
%   \begin{macrocode}
\NewDocumentCommand\Process@ChangedAt{m d== o d()}{%
  \tud@idx@get*\tud@idx@key\tud@idx@fmt\tud@idx@val{#1}=#2=[{#3}](#4)%
}
%    \end{macrocode}
% \end{macro}^^A \Process@ChangedAt
% \end{macro}^^A \if@tud@changedat
% \begin{macro}{\ChangedAt}
% \changes{v2.02}{2014/07/25}{erweitert}^^A
% \changes{v2.02}{2014/10/15}{Sternversion neu (keine Randnotiz)}^^A
% \changes{v2.06}{2018/09/03}{optionale Angabe der Entität}^^A
% \begin{macro}{\@ChangedAt}
% \changes{v2.06}{2019/06/24}{neu}^^A
% \begin{length}{\tud@dim@changedatvskip}
% \changes{v2.04}{2015/06/08}{neu}^^A
% Der Befehl \cs{ChangedAt} kann im Fließtext für das Erstellen einer freien 
% Änderungsnotiz genutzt werden. Das obligatorische Argument sollt wie kurz 
% zuvor beschrieben verwendet werden.
%
% Eine Änderungsnotiz wird für die angegebene Versionsnummer normalerweise im
% Abschnitt \enquote{Allgemein} aufgeführt. Soll jedoch eine Notiz explizit für
% eine Option, eine Umgebung, einen Befehlt etc. erstellt werden, kann dieses 
% Element vor dem obligatorischen im optionalen Argument angegeben werden. Der 
% Eintrag erfolgt dann im Abschnitt \enquote{Implementierung} für das gegebene
% Element. Im obligatorischen Argument können auch mehrere Änderungsnotizen 
% gleichzeitig erzeugt werden. Hierfür sind diese mit Semikolon voneinander zu 
% trennen. Das Erzeugen der Liste erfolgt mit \cs{Changed@At@CreateList}.
%
% Normalerweise wird bei der Nutzung von \cs{ChangedAt} zusätzlich zum Eintrag
% in die Änderungsliste eine Randnotiz mit den angegebenen Versionsnummern
% erzeugt. Mit dem letzten optionalen Argument nach dem obligatorischen kann
% ein vertikaler Versatz dieser angegeben werden. Die Sternversion des Befehls 
% unterdrückt die Ausgabe der Randnotiz. 
%    \begin{macrocode}
\tud@newdim\tud@dim@changedatvskip
\NewDocumentCommand\ChangedAt{s o d() m !O{\tud@dim@changedatvskip}}{%
  \Changed@At@CreateList{#4}[{#2}](#3)%
%    \end{macrocode}
% Nach dem Erstellen der Liste wird diese abgearbeitet und ggf. die Randnotiz 
% ausgegeben.
%    \begin{macrocode}
  \print@changedatlist{#1}{#5}%
}
%    \end{macrocode}
% Die expandierbare Version des Befehls ist innerhalb von Überschriften nötig.
%    \begin{macrocode}
\NewExpandableDocumentCommand\@ChangedAt{s o d() m}{}
\AfterPackage*{hyperref}{%
  \pdfstringdefDisableCommands{%
    \let\ChangedAt\@ChangedAt%
  }%
}
\BeforeStartingTOC{\let\ChangedAt\@ChangedAt}
%    \end{macrocode}
% \end{length}^^A \tud@dim@changedatvskip
% \end{macro}^^A \@ChangedAt
% \end{macro}^^A \ChangedAt
%
% \subsubsection{Sukzessive Erstellung der Einträge für die Änderungsliste}
%
% Das Erstellen von Änderungsnotizen erfolgt in zwei Schritten. Diese werden 
% zuerst mit dem Befehl \cs{Changed@At@CreateList} in einer standardisierten 
% Form in der temporären Liste \cs{tud@changedat@list} gespeichert und später 
% mit dem Makro \cs{Changed@At@CreateEntry} verarbeitet. Dieses Vorgehen liegt
% in den Umgebungen für Deklarationen begründet, welche verschachtelt werden
% können, jedoch einmalig mit \cs{printdeclarationlist} abgearbeitet werden.
%
% \begin{macro}{\Changed@At@CreateList}
% \changes{v2.02}{2014/09/02}{neu}^^A
% \begin{macro}{\Changed@At@@CreateList}
% \changes{v2.02}{2014/10/09}{neu}^^A
% \begin{macro}{\Changed@At@@@CreateList}
% \begin{macro}{\Changed@At@@@@CreateList}
% \begin{macro}{\tud@changedat@list}
% \changes{v2.02}{2014/07/25}{neu}^^A
% Mit diesen Befehlen wird eine Liste im Format von \pkg{etoolbox} erzeugt, 
% welche alle notwendigen Angaben für das Erzeugen der Änderungshistorie in 
% Form eines Indexes mit \cs{Changed@At@CreateEntry} enthält.
%
% Der Befehl \cs{Changed@At@CreateList} kann nach dem obligatorischen Argument 
% mit einem ordinären optionalen Argument verwendet werden, in welchem ein 
% Makro, eine Umgebung, eine Option etc. angegeben wird. Ist dies der Fall, so 
% wird der Eintrag in die Änderungsliste für dieses Element generiert, sonst 
% wird eine allgemeiner Eintrag erzeugt. Das optionale Argument in runden 
% Klammern wird lediglich verwendet, wenn für eine der beiden Spezialumgebungen 
% \env{DeclareEntity*} bzw. \env{DeclareEntity} eine Änderungsnotiz erstellt
% wird, um diese für das jeweilige \TUDScript-Bundle-Element in den
% entsprechenden Abschnitt der Änderungsliste einzutragen. Das Hauptargument
% verarbeitet eine semikolongetrennte Liste und reicht jeden Bestandteil
% zusammen mit den beiden optionalen Argumenten an \cs{Changed@At@@CreateList}
% weiter. 
%    \begin{macrocode}
\newcommand*\tud@changedat@list{}
\let\tud@changedat@list\relax
\NewDocumentCommand\Changed@At@CreateList{m !o !d()}{%
  \IfValueT{#1}{\forssvlist{\Changed@At@@CreateList[{#2}](#3)}{#1}}%
}
%    \end{macrocode}
% Mit \cs{Changed@At@@CreateList} wird lediglich die Versionsnummer von der 
% eigentlichen Änderungsnotiz getrennt.
%    \begin{macrocode}
\NewDocumentCommand\Changed@At@@CreateList{r[] r() >{\SplitArgument{1}{:}}m}{%
  \Changed@At@@@CreateList[{#1}](#2)#3%
}
%    \end{macrocode}
% Zuletzt wird durch \cs{Changed@At@@@CreateList} ein möglicher Untereintrag
% in ein separates Argument abgetrennt und \cs{Changed@At@@@@CreateList} mit
% allen Argumenten aufgerufen.
%    \begin{macrocode}
\NewDocumentCommand\Changed@At@@@CreateList{%
  r[] r() >{\SplitArgument{1}{!}}m m%
}{%
  \Changed@At@@@@CreateList[{#1}](#2)#3{#4}%
}
%    \end{macrocode}
% Der Befehl \cs{Changed@At@@@@CreateList} übernimmt nun die Erstellung des 
% Eintrags in die Liste \cs{tud@changedat@list}. Wie bereits erwähnt, enthalten 
% die beiden ersten Argumente ggf. Markup-Befehl und \TUDScript-Bundle-Element. 
% Danach folgt die Versionsnummer der Änderungsnotiz, der mögliche Untereintrag 
% für einen Markup-Befehl sowie die Änderungsnotiz selbst. 
%
% Die oberste Gliederungsebene der Änderungshistorie ist die Versionsnummer. 
% Unter dieser werden für jedes \TUDScript-Bundle-Element die Änderungsnotizen 
% separat ausgegeben, wobei diese nochmal in einen allgemeinen Teil und einen 
% zur Implementierung getrennt werden. 
%
% Der im Folgenden erzeugte Eintrag für die Liste \cs{tud@changedat@list} wird
% in zwei unterschiedlichen Varianten generiert:
% \begin{description}
%   \item[\meta{Versionsnummer}|!Allgemein!|\meta{Änderungsnotiz}]\strut\newline
%     allgemeine Änderungsnotiz
%   \item[\meta{Versionsnummer}|!Implementierung!|\meta{Markup}^^A
%   |!|\meta{Untereintrag}|!|\meta{Änderungsnotiz}]\strut\newline
%     Änderungsnotiz für Implementierung eines Befehls, Option etc.
% \end{description}
%    \begin{macrocode}
\NewDocumentCommand\Changed@At@@@@CreateList{r[] r() m m m}{%
%    \end{macrocode}
% Die Aufteilung der Änderungsliste in die einzelnen \TUDScript-Bundle-Elemente 
% erfolgt entweder anhand des explizit angegebenen optionalen Argumentes in
% runden Klammern oder aber implizit über den gegenwärtigen Inhalt des Makros
% \cs{tud@bdl@curr}. Dafür wird das Makro \cs{@tempa} so definiert, dass es
% das angegebene Argument in einer Box ausführt und die gesuchte Entität in
% \cs{@tempb} gespeichert ist.
%    \begin{macrocode}
  \def\@tempa##1{%
    \sbox\z@{%
      \let\tud@idx@fmt\relax%
      \@tud@changedattrue##1\@tud@changedatfalse%
      \ifx\tud@idx@fmt\relax%
        \gdef\@tempb{##1}%
      \else%
        \global\let\@tempb\tud@idx@fmt%
      \fi%
    }%
  }%
  \let\@tempb\@empty%
  \IfValueTF{#2}{%
    \@tempa{#2}%
  }{%
    \tud@if@bdl{\@tempa{\tud@bdl@curr}}{}%
  }%
%    \end{macrocode}
% Nachdem klar ist, für welche Entität ggf. der Änderungslisteneintrag erzeugt
% werden soll, wird nun bestimmt, ob dieser im allgemeinen Teil oder in den 
% zur Implementierung erscheinen soll. Dies wird an der Existenz des ersten
% Argumentes entschieden. Ist es vorhanden, handelt es sich um einen Eintrag 
% für den Implementierungsteil, welcher in \cs{tud@changedat@list} in der Form 
% \newline\begingroup^^A
%   \meta{Versionsnummer}|!Implementierung!|\meta{Markup-Befehl}^^A
%   |!|\meta{Untereintrag}|!|\meta{Änderungsnotiz}^^A
% \endgroup\newline^^A
% gespeichert wird, wobei der Untereintrag auch leer bleiben kann.
% \ToDo{vorherige doc überarbeiten oder raus}[v2.07]
%    \begin{macrocode}
  \IfValueTF{#1}{%
    \toks@{#3!Implementierung }%
%    \end{macrocode}
% Hier erfolgt ggf. der Eintrag des \TUDScript-Bundle-Elements, danach folgt 
% der Markup-Befehl.
%    \begin{macrocode}
    \addto@hook@expandafter\toks@{\@tempb}%
    \addto@hook\toks@{!#1!}%
%    \end{macrocode}
% Wurde ein Untereintrag angegeben, wird dieser hier gefolgt von der 
% eigentlichen Änderungsnotiz eingefügt. Für obsolete Deklarationen für die 
% Änderungsnotiz in jedem Fall ignoriert, da beim späteren Aufruf des Makros  
% \cs{Changed@At@CreateEntry} eine Standardmeldung ausgegeben wird.
%    \begin{macrocode}
    \IfValueT{#4}{\addto@hook\toks@{#4}}%
    \addto@hook\toks@{!}%
    \if@tud@obsolete\else%
      \IfValueT{#5}{\addto@hook\toks@{#5}}%
    \fi%
  }{%
%    \end{macrocode}
% Handelt es sich um einen allgemeinen Änderungseintrag, wird dieser in der Form
% \newline\begingroup^^A
%   \meta{Versionsnummer}|!Allgemein!|\meta{Änderungsnotiz}^^A
% \endgroup\newline^^A
% in der Liste \cs{tud@changedat@list} gespeichert. Für den allgemeinen Teil 
% \ToDo{vorherige doc überarbeiten oder raus}[v2.07]
% wird mit der Angabe eines \TUDScript-Bundle-Elements etwas anders verfahren.
% Wurde dieses~-- wenn auch nur indirekt über eine der beiden Spezialumgebungen
% \env{DeclareEntity*} bzw. \env{DeclareEntity}~-- angegeben, so wird der 
% Eintrag in den allgemeinen Hauptteil als Untereintrag erzeugt. Erfolgte die
% Verwendung jedoch innerhalb einer \TUDScript-Bundle-Deklaration, so erscheint
% der Eintrag im allgemeinen Teil für die explizite engegebene Entität.
%    \begin{macrocode}
    \toks@{#3!Allgemein }%
    \IfValueTF{#2}{%
      \addto@hook\toks@{!}%
      \addto@hook@expandafter\toks@{\@tempb:\space}%
      \IfValueTF{#5}{%
        \addto@hook\toks@{#5}%
      }{%
        \addto@hook\toks@{\emph{neu}}%
      }%
    }{%
      \addto@hook@expandafter\toks@{\@tempb}%
      \addto@hook\toks@{!}%
      \addto@hook\toks@{#5}%
    }%
    \IfValueT{#4}{%
      \ClassError{tudscrmanual}{Using !#4 isn't allowed for a change notice}{%
        At least, it has to be implemented!%
      }%
    }%
  }%
  \listeadd\tud@changedat@list{\the\toks@}%
}
%    \end{macrocode}
% \end{macro}^^A \tud@changedat@list
% \end{macro}^^A \Changed@At@@@@CreateList
% \end{macro}^^A \Changed@At@@@CreateList
% \end{macro}^^A \Changed@At@@CreateList
% \end{macro}^^A \Changed@At@CreateList
%
% \subsubsection{Ausgabe der Änderungsliste}
%
% Ähnlich wie für den Index wird auch für die Änderungsliste bei der Ausgabe 
% verfahren. 
%
% \begin{macro}{\PrintChangelog}
% \begin{environment}{theindex}
% Mit \cs{PrintChangelog} erfolgt die Ausgabe der Änderungsliste. Dabei ist zu 
% beachten, dass die Einträge im Index bis zur vierten Ebene erfolgen.
%    \begin{macrocode}
\newcommand*\PrintChangelog{%
  \begingroup%
    \@tud@indextrue%
    \@tud@changelogtrue%
%    \end{macrocode}
% Die oberste Ebene enthält die Versionsnummer mit dem Präfix |v|. Diese Ebene
% soll nicht als Indexeintrag selber sondern vielmehr als Überschrift der Ebene
% \cs{subsection} genutzt werden. Dafür wird zum einen das durch das Paket
% \pkg{imakeidx} definierte Makro \cs{lettergroup} \emph{unschädlich} gemacht,
% zum anderen wird der Befehl \cs{item} so umdefiniert, dass dieser alles bis
% zum nächsten Zeilenumbruch als Argument einliest. Alle darunter liegenden
% \cs{item}-Befehle werden eine Ebene nach oben gehoben.
%    \begin{macrocode}
    \let\lettergroup\@gobble%
    \apptocmd\theindex{%
      \let\subsubsubitem\subsubitem%
      \let\subsubitem\subitem%
      \let\subitem\item%
      \renewcommand*\item{%
        \begingroup%
          \escapechar=`\\%
          \catcode\endlinechar=\active%
          \csname\string\item\endcsname%
      }%
      \begingroup%
      \escapechar=`\\%
      \lccode`\~=\endlinechar%
      \lowercase{%
        \expandafter\endgroup%
        \expandafter\def\csname\string\item\endcsname##1~%
      }{%
        \endgroup%
        \let\@tempb\@firstofone%
        \if@tud@cdoldfont@active\def\@tempb##1{\NoCaseChange{##1}}\fi%
        \addsec[{##1}]{\TUDScript \@tempb{##1}}%
        \tudhyperdef*{idx:changelog:##1}%
        \def\@tempa{\indexname: \TUDScript \@tempb{##1}}%
        \@mkboth{\@tempa}{\@tempa}%
      }%
    }{}{\tud@patch@wrn{theindex}}%
%    \end{macrocode}
% Mit der so angepassten \env{theindex}-Umgebung erfolgt die Ausgabe der 
% Änderungshistorie.
%    \begin{macrocode}
    \clearpage%
    \def\imki@indexlevel{\addchap}%
    \tud@index@print[changelog]%
  \endgroup%
}
%    \end{macrocode}
% \end{environment}^^A theindex
% \end{macro}^^A \PrintChangelog
% \begin{macro}{\print@changedatlist}
% \changes{v2.02}{2014/10/09}{neu}^^A
% Die Einträge in der Liste der Änderungen \cs{tud@changedat@list} werden mit 
% dem Makro \cs{Changed@At@CreateList} abgearbeitet, sortiert und erstellt. Das 
% zweite obligatorische Argument von \cs{@printchangedatlist} steuert den 
% vertikalen Versatz der Randnotiz. Wird im ersten Argument das boolesche Flag 
% zu \cs{BooleanTrue} gesetzt, wird die Randnotiz unterdrückt.
%    \begin{macrocode}
\newcommand*\print@changedatlist[2]{%
  \ifx\tud@changedat@list\relax\else%
    \begingroup%
%    \end{macrocode}
% In \cs{tud@res@a} wird eine Liste aller angegebenen Versionsnummern 
% gespeichert, die nach dem Setzen der Änderungseinträge sortiert als Randnotiz 
% ausgegeben wird. Um diese zu erhalten, wird diese von jedem Eintrag aus 
% \cs{tud@changedat@list} mit \cs{tud@res@b} respektive \cs{tud@res@c}
% extrahiert.
%    \begin{macrocode}
      \let\tud@res@a\@empty%
      \def\tud@res@b##1!##2\@nil{%
        \ifinlist{##1}{\tud@res@a}{}{\listadd\tud@res@a{##1}}%
        \Changed@At@CreateEntry{##1!##2}%
      }%
      \def\tud@res@c##1{\tud@res@b##1\@nil}%
      \forlistloop\tud@res@c{\tud@changedat@list}%
      \global\let\tud@changedat@list\relax%
%    \end{macrocode}
% Nach der Verarbeitung der Einräge sind in \cs{tud@res@a} alle angegebenen
% Versionsnummern genau einmal enthalten. Mit \cs{tud@list@sort} werden diese 
% in die richtige Reihenfolge sortiert und anschließend als Randnotiz in einer
% Tabelle ausgegeben, falls nicht die Sternversion verwendet wurde. Hierfür 
% wird für jede Versionsnummer ein Tabellenzeileneintrag generiert, der einen 
% Link auf den entsprechenden Abschnitt in der Änderungsliste enthält. Daran 
% anschließend wird die eigentliche Tabelle in der Randnotiz ausgegeben.
%    \begin{macrocode}
      \IfBooleanF{#1}{%
        \tud@list@sort\tud@res@a%
        \let\tud@res@b\@empty%
        \def\tud@res@c##1{%
          \appto\tud@res@b{%
            \ignorespaces%
            \tudhyperref{idx:changelog:##1}{##1}%
            \tabularnewline%
          }%
        }%
        \forlistloop\tud@res@c{\tud@res@a}%
        \strut%
        \marginnote{%
          \begin{tabular}{|l|}%
            \hline%
            \tud@res@b%
            \hline%
          \end{tabular}%
        }[{#2}]%
        \aftergroup\ignorespaces%
      }%
    \endgroup%
  \fi%
}
%    \end{macrocode}
% \end{macro}^^A \print@changedatlist
% \begin{macro}{\Changed@At@CreateEntry}
% \changes{v2.02}{2014/09/02}{neu}^^A
% \begin{macro}{\Changed@At@@CreateEntry}
% \changes{v2.02}{2014/09/02}{neu}^^A
% Mit diesen Makros erfolgt das eigentliche Eintragen der Änderungen aus der 
% Liste \cs{tud@changedat@list} in den Index~\val{changelog}. Der Befehl
% \cs{Changed@At@CreateEntry} wird durch \cs{@printchangedatlist} aufgerufen
% und teilt die gegebene Liste am Delimiter Ausrufezeichen |!| in fünf
% Argumente auf und reicht sie an \cs{Changed@At@@CreateEntry} weiter. Sind
% weniger als vier Ausrufezeichen vorhanden, so werden die ungenutzten 
% Argumente mit dem~-- durch das Paket \pkg{xparse} definierten~-- leeren Wert
% \val{-NoValue-} an den Befehl \cs{Changed@At@@CreateEntry} übergeben.
%    \begin{macrocode}
\NewDocumentCommand\Changed@At@CreateEntry{>{\SplitArgument{4}{!}}m}{%
  \Changed@At@@CreateEntry#1%
}
%    \end{macrocode}
% Mit \cs{Changed@At@@CreateEntry} wird der Eintrag in die Änderungshistorie
% erzeugt, falls denn überhaupt ein Eintrag generiert werden soll. Dies wird
% daran erkannt, ob das dritte Argument dew Wert \val{-NoValue-} entspricht 
% oder eben nicht. Der zweite Fall tritt auf, wenn lediglich eine Randnotiz
% gesetzt werden soll. Die in \cs{tud@changedat@list} gespeicherten Einträge 
% haben die Form 
% \newline\begingroup^^A
%   \meta{Versionsnummer}|!Allgemein!|\meta{Änderungsnotiz}^^A
% \endgroup\newline^^A
% oder 
% \newline\begingroup^^A
%   \meta{Versionsnummer}|!Implementierung!|\meta{Markup-Befehl}^^A
%   |!|\meta{Untereintrag}|!|\meta{Änderungsnotiz}^^A
% \endgroup
% \ToDo{vorherige doc überarbeiten oder raus}[v2.07]
%    \begin{macrocode}
\newcommand*\Changed@At@@CreateEntry[5]{%
  \IfValueT{#3}{%
%    \end{macrocode}
% Bei der Deklaration von Optionen, Befehlen etc. werden diese automatisch in 
% der Liste der Änderungen im Bereich \enquote{Implementierung} vor der
% gegebenen Erklärung selbst ausgegeben. Hierfür wird die Existenz des vierten
% Arguments geprüft. Ist dieses vorhanden\dots
%    \begin{macrocode}
    \IfValueTF{#4}{%
%    \end{macrocode}
% \dots befindet sich im dritten Argument der Markup-Befehl für den Eintrag im
% Implementierungsteil. Mit dem zwischenzeitlichen Aktivieren des Schalters
% \cs{if@tud@changedat} wird beim nachfolgenden Aufruf des Markup-Befehls das 
% Makro \cs{Process@ChangedAt} ausgeführt und dadurch auch \cs{tud@idx@get*} 
% aufgerufen, wodurch in den Makros \cs{tud@idx@key}, \cs{tud@idx@fmt} und
% \cs{tud@idx@val} die passend formatierten Indexeinträge enthalten sind.
%    \begin{macrocode}
      \@tud@changedattrue#3\@tud@changedatfalse%
%    \end{macrocode}
% Das vierte Argument erstellt in der Änderungsliste einen Untereintrag für den
% im dritten Argument gegebenen Markup-Befehl. Dies wird für Anmerkungen zu 
% expliziten Schlüssel-Wert-Paaren bei Optionen oder Parametern genutzt. 
%    \begin{macrocode}
      \ifxblank{#4}{}{%
%    \end{macrocode}
% Hierfür wird die zuvor erhaltene Formatierung des Markup-Befehls des dritten
% Argumentes an den Haupteintrag \cs{tud@idx@val} mit der zusätzlichen
% Anmerkung \enquote{Werte angepasst} angehängt.
%    \begin{macrocode}
        \eappto\tud@idx@val{%
          \expandonce\tud@idx@key: Werte angepasst@%
          \expandonce\tud@idx@fmt: Werte angepasst!%
        }%
%    \end{macrocode}
% Anschließend werden die Formatierungsbefehle des vierten Arguments genutzt, 
% wobei vom Befehl \cs{suffix} nur das Argument selbst benötigt wird. Um den 
% Inhalt von \cs{tud@idx@val} zu schützen, erfolgt das ganze in einer Gruppe.
%    \begin{macrocode}
        \begingroup%
          \@tud@changedattrue#4\@tud@changedatfalse%
          \let\suffix\@gobble%
          \protected@edef\tud@reserved{%
            \noexpand\endgroup%
            \def\noexpand\tud@idx@key{\tud@idx@key}%
            \def\noexpand\tud@idx@fmt{\tud@idx@fmt}%
          }%
        \tud@reserved%
      }%
%    \end{macrocode}
% Nachdem die Formatierung der Haupt- und Untereinträge soweit zusammengebaut 
% wurden, wird die eigentliche Änderungsnotiz des fünften Arguments angehangen. 
% Dabei wird für den Fall, dass \emph{keine} Erklärung angegeben wurde, in der 
% Änderungsliste vermerkt, ob es sich bei dem Markup-Befehl respektive dessen 
% Untereintrag um eine \emph{neue} bzw. eine \emph{obsolete} Variante handelt.
%    \begin{macrocode}
      \ifxblank{#5}{%
        \if@tud@obsolete%
          \appto\tud@idx@fmt{: \emph{entf\"allt}}%
        \else%
          \appto\tud@idx@fmt{: \emph{neu}}%
        \fi%
%    \end{macrocode}
% Existiert ein Eintrag, wird dieser für Schlüssel und Format verwendet.
%    \begin{macrocode}
      }{%
        \appto\tud@idx@key{: #5}%
        \appto\tud@idx@fmt{: #5}%
      }%
%    \end{macrocode}
% Nachdem alles abgearbeitet wurde, wird der Indexeintrag erstellt.
%    \begin{macrocode}
      \index[changelog]{#1!#2!\tud@idx@val\tud@idx@key @\tud@idx@fmt}%
%    \end{macrocode}
% Existiert das vierte Argument nicht, handelt es sich um einen allgemeinen 
% Eintrag in der Änderungshistorie. Dieser wird direkt ausgeführt.
%    \begin{macrocode}
    }{%
      \index[changelog]{#1!#2!#3}%
    }%
  }%
}
%    \end{macrocode}
% \end{macro}^^A \Changed@At@@CreateEntry
% \end{macro}^^A \Changed@At@CreateEntry
%
% \subsubsection{Kurzbeschreibung von Paketen}
%
% \begin{environment}{DeclarePackages}
% \begin{macro}{\itempkg}
% \begin{macro}{\tud@item@pkg}
% \begin{macro}{\tud@item@@pkg}
% \begin{macro}{\tud@pkg@label@list}
% \changes{v2.07}{2021/06/16}{neu}^^A
% \begin{macro}{\tud@pkg@declare}
% \changes{v2.07}{2021/06/16}{neu}^^A
% \begin{macro}{\tud@pkg@@declare}
% \changes{v2.07}{2021/06/16}{neu}^^A
% Ähnlich wie für die Auflistung von Werten eines Schlüssels wird auch mit der 
% Charakterisierung von Paketen verfahren. Diese werden in der Auflistung 
% speziell gekennzeichnet.
%    \begin{macrocode}
\AtBeginDocument{%
  \newcommand*\itempkg{}%
  \undef\itempkg%
}
%    \end{macrocode}
% Der Befehl \cs{itempkg} ist nur innerhalb von \env{DeclarePackages} gültig. 
% Für verschachtelte Aufrufe der Umgebung werden zu Beginn der Umgebung die 
% aktuell definierten Label in \cs{tud@pkg@label@list} gesichert, um diese vor
% jedem \cs{itempkg} als Standardwert zu verwenden.
%    \begin{macrocode}
\newcommand*\tud@pkg@label@list{}
\newcommand*\tud@item@@pkg{%
  \let\itempkg\tud@item@pkg%
  \let\tud@pkg@label@list\tud@declaration@label@list%
}
\tud@list@create[before=\tud@item@@pkg]{DeclarePackages}{description}{2}
\NoIndentAfterEnv{DeclarePackages}
%    \end{macrocode}
% Innerhalb von \env{DeclarePackages} kann mit \cs{itempkg} ein oder mehrere
% Pakete erläutert werden. Des Weiteren werden Textanker definiert, auf die im 
% Zweifelsfall in der Dokumentation verlinkt wird.
%    \begin{macrocode}
\NewDocumentCommand\tud@item@pkg{m !d() !d<> !o}{%
%    \end{macrocode}
% Im obligatorischen Argument werden die namentlich genannten Pakete deklariert 
% und ausgegeben. Mit \val=(\meta{Markup})= lassen sich auch andere Entitäten 
% angeben und in gleicher Weise deklarieren, \val=<\meta{Markup}>= unterdrückt 
% die Ausgabe erzeugt allerding Textanker und Indexeinträge. Das letzte 
% optionale Argument akzeptiert eine Änderungsnotiz.
%    \begin{macrocode}
  \begingroup%
    \let\tud@res@a\@empty%
    \forcsvlist{\tud@pkg@declare\tud@res@a{\Package'*'}}{#1}%
    \IfValueT{#2}{%
      \forcsvlist{\tud@pkg@@declare\tud@res@a}{#2}%
    }%
    \IfValueT{#3}{%
      \forcsvlist{\tud@pkg@@declare*\tud@res@a}{#3}%
    }%
%    \end{macrocode}
% Jetzt werden die Änderungsnotizen verarbeitet. Wurde lediglich eine 
% Versionsnummer angegeben, wird die definierten Pakete angehangen.
%    \begin{macrocode}
    \let\tud@res@b\@empty%
    \IfValueT{#4}{%
      \let\tud@res@d\@empty%
      \def\tud@res@b##1{%
        \in@{:}{##1}%
        \ifin@%
          \appto\tud@res@d{##1;}%
        \else%
          \let\tud@res@c\@empty%
          \docsvlist{#1}%
          \eappto\tud@res@d{##1:\expandonce\tud@res@c;}%
        \fi%
      }%
      \def\do##1{%
        \eappto\tud@res@c{%
          \ifx\tud@res@c\@empty\else,\space\fi%
          \noexpand\Package{##1}%
        }%
      }%
      \forssvlist{\tud@res@b}{#4}%
%    \end{macrocode}
% Paketbeschreibungen erhalten einen separaten Abschnitt in der Änderungsliste.
%    \begin{macrocode}
      \edef\tud@res@b{%
        \noexpand\Changed@At@Special[-1\baselineskip]{Paketbeschreibungen}%
          {sec:packages:recommended}{\expandonce\tud@res@d}%
      }%
    }%
%    \end{macrocode}
% Die Deklarationen werden durchgeführt und ausgegeben, die Änderungsnotizen 
% werden erzeugt und die Liste der aktuell deklarierten Label für diesen 
% Eintrag geändert.
%    \begin{macrocode}
    \edef\tud@res@a{%
      \endgroup%
      \noexpand\item[\expandonce\tud@res@a]%
      \expandonce\tud@res@b%
      \def\noexpand\tud@declaration@label@list{\expandonce\tud@pkg@label@list}%
    }%
  \tud@res@a%
  \strut\ignorespaces%
}
%    \end{macrocode}
% Hiermit erfolgt die eigentliche Deklaration (Textanker, Indexeinträg) und 
% ggf. die Ausgabe.
%    \begin{macrocode}
\newcommand\tud@pkg@declare[3]{\tud@pkg@@declare#1{#2{#3}}}
\NewDocumentCommand\tud@pkg@@declare{s m m}{%
  \tud@lbl@get\tud@lbl@tmp{#3}%
  \listeadd\tud@pkg@label@list{\tud@lbl@tmp}%
  \eappto#2{%
    \IfBooleanF{#1}{\ifx#2\@empty\else\unexpanded{\kern.1em/\kern.1em}\fi}%
    \noexpand\Inline@Declaration\IfBooleanT{#1}{*}\unexpanded{{#3}}%
  }%
}
%    \end{macrocode}
% \end{macro}^^A \tud@pkg@@declare
% \end{macro}^^A \tud@pkg@declare
% \end{macro}^^A \tud@pkg@label@list
% \end{macro}^^A \tud@item@@pkg
% \end{macro}^^A \tud@item@pkg
% \end{macro}^^A \itempkg
% \end{environment}^^A DeclarePackages
%
% \subsection{Erläuterungen und weiterführende Ergänzungen im Handbuch}
% \subsubsection{Tabelle mit abschließender Mehrspaltenzellen}
%
% \begin{environment}{tabularm}
% Die Umgebung \env{tabularm} ist eine Erweiterung der \env{tabular}-Umgebung.
% Im obligatorischen Argument wird die gewünschte Anzahl der linksbündigen 
% Spalten angegeben. Sollte danach das optionale Argument verwendet werden, 
% wird dessen Inhalt in einer alle Spalten übergreifenden Zeile unterhalb der 
% eigentlichen Tabelle ausgegeben.
%    \begin{macrocode}
\NewDocumentEnvironment{tabularm}{O{c} m !o +b}{%
  \sbox\z@{\tabular[{#1}]{*{#2}l}#4\endtabular}%
  \begin{tabular}{c}%
    \usebox\z@%
    \IfValueT{#3}{\tabularnewline\parbox[b]{\the\wd\z@}{\vskip1.5ex#3}}%
  \end{tabular}%
}{}
%    \end{macrocode}
% \end{environment}^^A tabularm
%
% \subsubsection{Tabelle für mehrsprachigen Bezeichner}
%
% \begin{macro}{\TermTable}
% \begin{macro}{\Term@Table}
% \begin{macro}{\Term@@Table}
% \begin{macro}{\Term@@@Table}
% Für sprachabhängige Bezeichner wird zusätzlich der Befehl \cs{TermTable} 
% definiert. Dieser kann innerhalb von \env{Declaration} verwendet werden, um 
% alle mit \cs{Term} definierten Bezeichner für die Sprachen Deutsch und
% English in einer Tabelle auszugeben. Wird im optionalen Argument eine Länge 
% angegeben, wird diese für die Breite einer \env{tabularx}-Umgebung genutzt.
%    \begin{macrocode}
\NewDocumentCommand\TermTable{!o}{%
  \ifhmode\par\fi%
  \vskip\smallskipamount%
  \@afterindentfalse\@afterheading%
  \begingroup%
%    \end{macrocode}
% Mit \cs{Term@Table} wird \cs{tud@declaration@inner@list} nach Einträgen von 
% \cs{Term} durchsucht und die deklarierten Werte in einer kommaseparierten
% Liste gespeichert.
%    \begin{macrocode}
    \let\tud@res@a\@empty%
    \def\do##1{\Term@Table\tud@res@a\@nil##1\@nil}%
    \dolistloop{\tud@declaration@inner@list}%
    \ifx\tud@res@a\@empty%
      \ClassWarning{tudscrmanual}{No declaration for Terms found}%
    \else%
%    \end{macrocode}
% Die extrahierten Werte werden für die Ausgabe der Tabelle verwendet.
%    \begin{macrocode}
      \IfValueTF{#1}{%
        \begin{tabularx}{\dimexpr\glueexpr#1\relax\relax}[b]{lXX}%
          \expandafter\Term@@Table\expandafter{\tud@res@a}%
        \end{tabularx}%
      }{%
        \begin{tabular}[b]{lll}%
          \expandafter\Term@@Table\expandafter{\tud@res@a}%
        \end{tabular}%
      }%
    \fi%
  \endgroup%
}
\newcommand*\Term@Table{}
\def\Term@Table#1\@nil#2#3#4\@nil{\tud@if@strequal{Term}{#2}{\appto#1{#3,}}{}}%
%    \end{macrocode}
% Das Setzen der eigentlichen Tabelle.
%    \begin{macrocode}
\newcommand*\Term@@Table[1]{%
  \toprule%
  \textbf{Bezeichner} & \textbf{Deutsch} & \textbf{Englisch}\tabularnewline%
  \midrule%
  \forcsvlist{\Term@@@Table}{#1}%
  \bottomrule%
}
\newcommand*\Term@@@Table[1]{%
  \Term*{#1} & %
  \Ifstr{\csuse{#1}}{}{\PName{leer}}{\csuse{#1}} & %
  \strut\selectlanguage{english}%
  \Ifstr{\csuse{#1}}{}{\PName{empty}}{\csuse{#1}}\tabularnewline%
}
%    \end{macrocode}
% \end{macro}^^A \Term@@@Table
% \end{macro}^^A \Term@@Table
% \end{macro}^^A \Term@Table
% \end{macro}^^A \TermTable
%
% \subsubsection{Umgebung für die Angabe eines Beispiels}
%
% \begin{environment}{Example}
% \begin{macro}{\if@tud@code@used}
% \changes{v2.07}{2021/06/16}{neu}^^A
% Diese Umgebung wird für die exemplarische Erläuterung von bestimmten Aspekten 
% im Handbuch verwendet. Wenn dafür ein Quelltextauszug nötig ist, kann 
% innerhalb dieser die \env{Code}-Umgebung genutzt werden. Sollte direkt nach 
% diesem auch die \env{Example}-Umgebung enden, wird etwas zu viel vertikaler 
% Abstand eingefügt, weshalb für diesen Fall (\cs{if@tud@code@used}) dieser am 
% Ende der Umgebung entfernt wird.
%    \begin{macrocode}
\tud@newif\if@tud@code@used
\newenvironment{Example}{%
  \labeling{{\usekomafont{disposition}{Beispiel:\nobreakspace}}}%
  \item[{\usekomafont{disposition}{Beispiel:\nobreakspace}}]%
  \@tud@code@usedfalse%
  \AfterEndEnvironment{Code}{\@tud@code@usedtrue}%
}{%
  \begingroup%
    \edef\tud@res@a{%
      \endgroup%
      \noexpand\endlabeling%
      \if@tud@code@used%
        \noexpand\addvspace{\the\glueexpr-\parskip\relax}%
      \fi%
    }%
  \tud@res@a%
}
\NoIndentAfterEnv{Example}
%    \end{macrocode}
% \end{macro}^^A \if@tud@code@used
% \end{environment}^^A Example
%
% \iffalse
%</class>
% \fi
%
% \subsection{Einbinden und Verlinkungen externer Dateien}
%
% Hier werden allerlei Befehle und Umgebungen für die Formatierung, Ausgabe und 
% Ausführung von Quelltextauszügen mit dem Paket \pkg{listings} definiert.
%
% \begin{macro}{\IncludeExample}
% \changes{v2.02}{2014/07/25}{Skalierung der eingefügten Seiten}^^A
% Mit diesem Befehl wird eine \LaTeX-Datei ggf. übersetzt und anschließend als
% PDF"~Datei wieder eingebunden. Zuvor wird der dazugehörige Quelltext mittels
% \cs{lstinputlisting} im Dokument ausgegeben. Dieser Befehl wird lediglich für 
% die Klasse \cls{tudscrmanual} benötigt.
%    \begin{macrocode}
%<*class>
\newcommand*\IncludeExample[2][1]{%
  \begingroup%
    \lstinputlisting[style=tudscr]{examples/#2}%
%    \end{macrocode}
% Die Beispiele werden nur erneut kompiliert, wenn sich diese geändert haben 
% oder noch gar kein entsprechendes PDF"~Dokument existiert.
%    \begin{macrocode}
    \ifnum\pdf@shellescape=\@ne\relax%
      \filemodCmp{examples/#2.pdf}{examples/#2.tex}{}{%
        \edef\tud@res@a{%
          \tud@latex@ext -output-directory examples examples/#2.tex%
        }%
        \ShellEscape{\tud@res@a}%
        \ShellEscape{\tud@res@a}%
      }%
%    \end{macrocode}
% Sollte es eine spezielle Version eines beispiels für die Druckausgabe geben, 
% wird auch dieses kompiliert.
%    \begin{macrocode}
      \filemodCmp{examples/#2_print.pdf}{examples/#2_print.tex}{}{%
        \edef\tud@res@a{%
          \tud@latex@ext -output-directory examples examples/#2_print.tex%
        }%
        \ShellEscape{\tud@res@a}%
        \ShellEscape{\tud@res@a}%
      }%
    \fi%
%    \end{macrocode}
% Ist die gesuchte Datei vorhanden, wird diese auch eingebunden, wobei 
% gegebenenfalls die Druckversion verwendet wird, falls vorhanden.
%    \begin{macrocode}
    \def\tud@res@a{examples/#2.pdf}%
    \ifdef{\tudprintflag}{%
      \IfFileExists{examples/#2_print.pdf}{%
        \def\tud@res@a{examples/#2_print.pdf}%
      }{}%
    }{}%
    \IfFileExists{\tud@res@a}{%
      \edef\tud@res@a{%
        \noexpand\includepdf[%
          pages=-,noautoscale,frame,keepaspectratio,pagecommand={},%
          height=\noexpand\textheight,width=\noexpand\textwidth,offset=5mm 0mm%
        ]{\tud@res@a}%
      }%
      \tud@res@a%
    }{%
%    \end{macrocode}
% Andernfalls wird eine Warnung mit dem Hinweis auf die notwendige Verwendung
% von \app{pdflatex} mit dem Parameter \file{-{}-shell-escape} erzeugt und ein 
% Platzhalter für das fehlende Dokument eingefügt, wbeo das optionale Argument 
% die Anzahl der erwarteten Seiten angibt.
%    \begin{macrocode}
      \begingroup%
        \tud@shellescape@wrn{\tud@res@a}%
        \tud@res@cnt=#1\relax%
        \@whilenum\tud@res@cnt>\z@\relax\do{%
          \advance\tud@res@cnt\m@ne%
          \clearpage%
          \fboxsep=-\arrayrulewidth%
          \noindent\fbox{\vbox to\textheight{%
            \vss\vss%
            \hbox to\textwidth{\hss\texttt{\tud@res@a}\hss}%
            \vskip\smallskipamount%
            \hbox to\textwidth{%
              \hss\texttt{\the\numexpr#1-\tud@res@cnt\relax/#1}\hss%
            }%
            \vss\vss\vss%
          }}%
        }%
      \endgroup%
      \clearpage%
    }%
  \endgroup%
}
%</class>
%    \end{macrocode}
% \end{macro}^^A \IncludeExample
% \begin{macro}{\HyperTutorial}
% \changes{v2.02}{2014/08/22}{neu}^^A
% \changes{v2.02}{2014/10/22}{Reimplementierung}^^A
% \begin{macro}{\tud@bash@write}
% Die gegebenenfalls notwendige Kompilierung und die Referenzierung eines 
% Tutorials aus dem Handbuch erfolgt mit \cs{Tutorial}. Um mit verschachtelten
% Aufrufen von \app{pdflatex} umgehen zu können, wird das ganze Prozedere in
% ein Skript ausgelagert. Somit können die Aufrufe von \app{pdflatex} für die
% Tutorials aus dem entsprechenden Ordner und mit den notwendigen Optionen
% erfolgen.
%    \begin{macrocode}
%<class>\tud@newwrite\tud@bash@write
\newcommand*\HyperTutorial[1]{%
%<*class>
  \ifnum\pdf@shellescape=\@ne\relax%
    \filemodCmp{tutorials/#1.pdf}{tutorials/#1.tex}{}{%
      \let\tud@res@a\@empty%
      \ifdef{\tudfinalflag}{\appto\tud@res@a{\def\noexpand\tudfinalflag{}}}{}%
      \ifdef{\tudprintflag}{\appto\tud@res@a{\def\noexpand\tudprintflag{}}}{}%
      \appto\tud@res@a{\noexpand\input{#1.tex}}%
      \immediate\openout\tud@bash@write=tutorials.sh\relax%
      \def\tud@res@b##1{\immediate\write\tud@bash@write{##1}}%
      \tud@res@b{cd tutorials}%
      \tud@res@b{\tud@latex@ext -shell-escape "\tud@res@a"}%
      \ifwindows%
        \tud@res@b{if exist #1.bcf biber #1}%
      \else%
        \tud@res@b{[ -f #1.bcf ] && biber #1}%
      \fi%
      \tud@res@b{\tud@latex@ext "\tud@res@a"}%
      \tud@res@b{\tud@latex@ext -shell-escape "\tud@res@a"}%
      \ifwindows%
        \tud@res@b{if exist #1.ist makeglossaries #1}%
      \else%
        \tud@res@b{[ -f #1.ist ] && makeglossaries #1}%
      \fi%
      \ifwindows%
        \tud@res@b{if exist #1.xdy makeglossaries #1}%
      \else%
        \tud@res@b{[ -f #1.xdy ] && makeglossaries #1}%
      \fi%
      \tud@res@b{\tud@latex@ext "\tud@res@a"}%
      \tud@res@b{\tud@latex@ext -shell-escape "\tud@res@a"}%
      \tud@res@b{\tud@latex@ext -shell-escape "\tud@res@a"}%
      \immediate\closeout\tud@bash@write%
%    \end{macrocode}
% Hier erfolgt die Unterscheidung der Befehle für die unterschiedlichen OS.
%    \begin{macrocode}
      \ifwindows%
        \ShellEscape{rename tutorials.sh tutorials.bat}%
        \ShellEscape{tutorials.bat}%
        \ShellEscape{del tutorials.bat}%
      \else%
        \ShellEscape{bash tutorials.sh}%
        \ShellEscape{rm tutorials.sh}%
      \fi%
    }%
  \fi%
%    \end{macrocode}
% Hyperlink und verlinkter Indexeintrag.
% \ToDo{verwenden von SuppressMarkupSuffix im Index}[v2.07]
%^^A \index[files]{#2.pdf Tutorial@\Tutorial{#2}{\suffix{Tutorial}}}%
%    \begin{macrocode}
  \IfFileExists{tutorials/#1.pdf}{%
    \href[pdfnewwindow]{tutorials/#1.pdf}{\InlineDeclaration{\Tutorial''{#1}}}%
  }{%
    \tud@shellescape@wrn{tutorials/#1.pdf}%
    \Tutorial{#1}%
  }%
%</class>
%<*package>
  \IfFileExists{#1.pdf}{%
    \href[pdfnewwindow]{#1.pdf}{\InlineDeclaration{\Tutorial''{#1}}}%
  }{%
    \tud@shellescape@wrn{#1.pdf}%
    \Tutorial{#1}%
  }%
%</package>
}
%    \end{macrocode}
% \end{macro}^^A \tud@bash@write
% \end{macro}^^A \HyperTutorial
%
% \iffalse
%<*package>
% \fi
%
% Für den Anwender werden im \TUDScript-Bundle einige Tutorials mit Hinweisen 
% zur Nutzung von \LaTeX{} bereitgestellt. Innerhalb dieser werden Auszüge von
% Quelltexten verwendet und erläutert. Zum einen soll die Möglichkeit 
% geschaffen werden, diese gesammelt am Ende eines Tutorials für ein
% Copy"~\&"~Paste"~Beispiel zu verwenden. Andererseits soll auch das sofortige
% Ausführen des beschriebenen Quelltextauszuges direkt im Tutorial möglich
% sein.
%
% Dafür werden im Folgenden die Umgebungen \env{Preamble}, \env{Trunk} und
% \env{Hint} sowie daraus abgeleitet Varianten definiert, womit sich die Angabe
% und Erläuterung der Quelltexte im Tutorial logisch strukturieren lässt und
% dennoch die notwendige Ordnung dieser für das Copy"~\&"~Paste"~Beispiel
% aufrechterhalten werden kann. Hierfür zeichnen die beiden Umgebungen
% \env{Preamble} und \env{Trunk} und deren Derivate verantwortlich. Die
% Umgebung \env{Hint} steht für zusätzliche Erläuterungen bereit, welche jedoch
% nicht in das Copy"~\&"~Paste"~Beispiel übernommen werden.
%
% \begin{macro}{\tud@write@a}
% \changes{v2.02}{2014/10/22}{neu}^^A
% \begin{macro}{\tud@write@b}
% \changes{v2.02}{2014/11/02}{neu}^^A
% \begin{macro}{\tud@read}
% \changes{v2.02}{2014/08/19}{neu}^^A
% Die notwendigen Ein- und Ausgabestreams.
%    \begin{macrocode}
\tud@newwrite\tud@write@a
\tud@newwrite\tud@write@b
\tud@newread\tud@read
%    \end{macrocode}
% \end{macro}^^A \tud@read
% \end{macro}^^A \tud@write@b
% \end{macro}^^A \tud@write@a
%
% \begin{macro}{\tud@tut@temp}
% \changes{v2.05}{2016/05/01}{neu}^^A
% \begin{macro}{\tud@tut@inputtostream}
% \changes{v2.02}{2014/12/16}{neu}^^A
% \begin{macro}{\tud@tut@append}
% \changes{v2.02}{2014/08/19}{neu}^^A
% Bei den Tutorials soll zum Schluss ein komplett kompilierbares Beispiel für
% Copy~\&~Paste gegeben werden. Um dieses zusammenzubauen, werden alle im 
% Dokument innerhalb der Varianten der \env{Trunk}-Umgebungen gegebenen
% Codefragmente zusammengesetzt. Um die Quelltexte einlesen und verarbeiten zu
% können, werden zwei Eingabe- sowie ein Ausgabestream benötigt, welche bereits 
% zuvor initialisiert wurden.
%
% Mit \cs{tud@tut@inputtostream} wird der Inhalt der Datei im ersten Argument 
% in den Ausgabestream des zweiten Argumentes geschrieben. Dies wird durch 
% \ToDo{inputtostream überhaupt notwendig?}
%    \begin{macrocode}
\newcommand*\tud@tut@temp{}
\edef\tud@tut@temp{\@currname-temp}
\newcommand*\tud@tut@inputtostream[2]{%
  \begingroup%
    \endlinechar=\m@ne\relax%
    \openin\tud@read=#1%
%    \end{macrocode}
% Der Schalter \cs{if@tempswa} wird verwendet, um unnötige Leerzeilen in der
% Ausgabedatei zu entfernen. Wurde eine nicht leere Zeile gefunden, wird diese 
% auf jeden Fall geschrieben, indem \cs{@tempswatrue} gesetzt wird. Eine leere 
% Zeile wird~-- bis auf den Sonderfall, dass es sich um die letzte Zeile in der
% Datei handelt~-- zunächst nicht weiter beachtet. Im Zweifelsfall wird diese
% (erste) Leerzeile geschrieben. 
%    \begin{macrocode}
    \@tempswafalse%
    \loop\unless\ifeof\tud@read%
      \readline\tud@read to\tud@reserved%
      \ifx\tud@reserved\@empty%
        \ifeof\tud@read\@tempswafalse\fi%
      \else%
        \@tempswatrue%
      \fi%
%    \end{macrocode}
% Hier erfolgt das eigentliche Schreiben im selektierten Stream.
%    \begin{macrocode}
      \if@tempswa%
        \immediate\write#2{\expandonce\tud@reserved}%
      \fi%
%    \end{macrocode}
% Im Nachgang wird überprüft, ob die aktuell geschriebene Zeile leer war. Ist 
% dies der Fall, so wird \cs{@tempswafalse} gesetzt, um eine etwaig folgende 
% Leerzeile nicht in die Ausgabedatei zu schrieben.
%    \begin{macrocode}
      \ifx\tud@reserved\@empty\@tempswafalse\fi%
    \repeat%
    \closein\tud@read%
  \endgroup%
}
%    \end{macrocode}
% Der innerhalb der Umgebungen \env{Preamble} und \env{Trunk}~-- sowie deren 
% Derivaten~-- angegebene Inhalt wird beim Schließen dieser Umgebungen in die 
% Hilfsdatei \cs{tud@tut@temp.tex} zwischengespeichert. Mit \cs{tud@tut@append}
% wird der Inhalt dieser Datei ausgelesen und den Hilfsdateien
% \cs{tud@tut@temp-preamble.tex} respektive \cs{tud@tut@temp-trunk.tex}
% angehangen und damit gesichert, um die jeweiligen Quelltextauszüge aus dem
% Tutorial für die Präambel sowie den Dokumentteil trennen beziehungsweise
% sortieren zu können.
%    \begin{macrocode}
\newcommand*\tud@tut@append[1]{%
  \Ifstr{#1}{preamble}{%
    \tud@tut@inputtostream{\tud@tut@temp.tex}{\tud@write@a}%
  }{%
    \Ifstr{#1}{trunk}{%
      \tud@tut@inputtostream{\tud@tut@temp.tex}{\tud@write@b}%
    }{%
      \tud@tut@inputtostream{\tud@tut@temp.tex}{#1}%
    }%
  }%
}
%    \end{macrocode}
% \end{macro}^^A \tud@tut@append
% \end{macro}^^A \tud@tut@inputtostream
% \end{macro}^^A \tud@tut@temp
% \begin{macro}{\StartTutorial}
% \changes{v2.02}{2014/08/21}{neu}^^A
% \begin{macro}{\FinishTutorial}
% \changes{v2.02}{2014/08/21}{neu}^^A
% Mit \cs{StartTutorial} wird ein Hyperlink für den Querverweis aus dem 
% Handbuch definiert. Außerdem wird gleich der Titel und~-- falls im optionalen 
% Argument angegeben~-- eine Zusammenfassung gesetzt. Die Sternversion gibt 
% nach der optionalen Beschreibung einen einleitenden Satz zur Dokumnentklasse 
% und sinnvollen Paketen an. Diese sollten direkt nach \cs{StartTutorial} in 
% der \env{Preamble}-Umgebung angegeben werden.
%    \begin{macrocode}
\TUDoptions{headingsvskip=-10ex}
\newcommand\StartTutorial[1][]{%
  \immediate\openout\tud@write@a=\tud@tut@temp-preamble.tex\relax%
  \immediate\openout\tud@write@b=\tud@tut@temp-trunk.tex\relax%
  \immediate\write\tud@write@b{^^J\string\begin{document}^^J}%
  \Hy@raisedlink{\hyperdef{\jobname}{tutorials:\jobname}{}}%
  \faculty{}%
  \maketitle%
  \ifblank{#1}{}{%
    \noindent%
    \begin{abstract}%
    \noindent#1%
    \end{abstract}%
    \medskip%
  }%
  \noindent\ignorespaces%
}
%    \end{macrocode}
% Der Befehl \cs{FinishTutorial} schleißt den noch offenen Ausgabestream und
% gibt den vorgestellten Quelltext vollständig aus.
%    \begin{macrocode}
\newcommand\FinishTutorial[1][]{%
  \immediate\write\tud@write@b{^^J\string\end{document}^^J}%
  \immediate\closeout\tud@write@b%
  \immediate\closeout\tud@write@a%
  \immediate\openout\tud@write@a\jobname-example.tex\relax%
  \tud@tut@inputtostream{\tud@tut@temp-preamble.tex}{\tud@write@a}%
  \tud@tut@inputtostream{\tud@tut@temp-trunk.tex}{\tud@write@a}%
  \immediate\closeout\tud@write@a%
  \clearpage%
  \addsec{Copy\nobreakspace\&\nobreakspace Paste}%
  \thispagestyle{empty}%
  \pagestyle{empty}%
  Der zuvor beschriebene Quelltext wird folgend ausgegeben, um diesen via %
  Copy~\&~Paste nutzen und nachvollziehen zu k\"onnen. Bitte beachten Sie, %
  dass~-- abh\"angig vom verwendeten PDF-Betrachter~-- beim Kopieren die hier %
  dargestellten Einz\"uge und Abs\"atze m\"oglicherweise verloren gehen %
  k\"onnen. Dies kann insbesondere aufgrund fehlender Leerzeilen zu einem %
  falschen Ausgabeergebnis f\"uhren. Alternativ finden Sie den folgenden %
  \Logo{LaTeX}-Quelltext auch im Pfad %
  \Path{\PName{texmf}/source/latex/tudscr/doc/examples/} %
  als Datei \File{\jobname-example.tex}. \par #1%
  \begin{quoting}[rightmargin=0pt]%
  \lstinputlisting[style=tudscr]{\jobname-example.tex}%
  \end{quoting}%
%    \end{macrocode}
% Falls es möglich ist, werden nach dem Durchlauf alle nicht mehr benötigten 
% Hilfsdateien gelöscht.
%    \begin{macrocode}
  \ifnum\pdf@shellescape=\@ne\relax%
    \ifwindows%
      \def\@tempa{del}%
    \else%
      \def\@tempa{rm}%
    \fi%
    \ShellEscape{\@tempa\space\tud@tut@temp*.*}%
  \fi%
}
%    \end{macrocode}
% \end{macro}^^A \FinishTutorial
% \end{macro}^^A \StartTutorial
% \begin{macro}{\CodePreamble}
% \changes{v2.02}{2014/08/20}{neu}^^A
% \begin{macro}{\Code@Preamble}
% \changes{v2.02}{2014/10/22}{neu}^^A
% \begin{macro}{\CodeHook}
% \changes{v2.02}{2014/10/11}{neu}^^A
% \begin{macro}{\Code@Hook}
% \changes{v2.02}{2014/10/11}{neu}^^A
% Bereitstellung von Hilfsmakros für die formatierte Ausgabe von Quelltexten.
%    \begin{macrocode}
\newcommand\Code@Preamble{}
\let\Code@Preamble\relax
\newcommand\CodePreamble[1]{%
  \long\gdef\Code@Preamble{%
    \hskip\glueexpr\leftmargin/2\relax%
    \textit{Die resultierende Ausgabe:}\space#1%
  }%
}
\newcommand*\Code@Hook{}
\let\Code@Hook\relax
\newcommand*\CodeHook[1]{\gdef\Code@Hook{#1}}
%    \end{macrocode}
% \end{macro}^^A \Code@Hook
% \end{macro}^^A \CodeHook
% \end{macro}^^A \Code@Preamble
% \end{macro}^^A \CodePreamble
% \begin{macro}{\filec@ntents@silent}
% \changes{v2.06e}{2019/10/10}{neu}^^A
% Die Umgebungen \env{Preamble}, \env{Trunk} und \env{Hint} sowie deren
% Varianten nutzen die Umgebung \env{filecontents}, um ihren Inhalt in eine
% temporäre Datei zu schreiben und diese direkt mit dem Paket \pkg{listings}
% darzustellen sowie ggf. den Quelltext auszuführen. Beim Überschreiben einer
% Datei wird für gewöhnlich eine Warnung erzeugt. Dies wird mit dem eigens 
% definierten Parameter \prm{silent} unterbunden.
%    \begin{macrocode}
\providecommand*\filec@ntents@silent{%
  \let\@latex@warning@no@line\@gobble%
}
%    \end{macrocode}
% \end{macro}^^A \filec@ntents@silent
% \begin{macro}{\tud@tut@pre}
% \changes{v2.02}{2014/08/19}{neu}^^A
% \begin{macro}{\tud@tut@post}
% \changes{v2.02}{2014/08/19}{neu}^^A
% Dies sind Hilfsmakros, welche zu Beginn und Ende der Quelltextumgebungen 
% \env{Preamble}, \env{Trunk} und \env{Hint} für das Sichern der Inhalte in
% eine Hilfsdatei verantwortlich sind, wofür die \env{filecontents}-Umgebung 
% genutzt wird.
%    \begin{macrocode}
\newcommand*\tud@tut@pre{%
  \csuse{filecontents*}[force,silent,nosearch]{\tud@tut@temp.tex}%
}
\newcommand*\tud@tut@post{%
  \csuse{endfilecontents*}%
}
%    \end{macrocode}
% \end{macro}^^A \tud@tut@post
% \end{macro}^^A \tud@tut@pre
% Die nachfolgenden Umgebungen verwenden die beiden, gerade zuvor eingeführten 
% Hilfsmakros \cs{tud@tut@pre} und \cs{tud@tut@post}, welche den gegebenen 
% Inhalt in die temporäre Datei \file{\string\tud@tut@temp.tex} schreiben. Die 
% im Dokument in den Umgebungen gesetzten Quelltextauszüge werden mit dem Makro
% \cs{tud@tut@append}~-- abhängig vom gegebenen Argument~-- zusätzlich für ein 
% Copy"~\&"~Paste"~Beispiel in \file{\string\tud@tut@temp-preamble.tex} oder
% \file{\string\tud@tut@temp-trunk.tex} gespeichert. Die damit gesammelten 
% Inhalte werden am Ende mit \cs{FinishTutorial} ausgegeben.
% \begin{environment}{Preamble}
% \changes{v2.02}{2014/11/02}{neu}^^A
% \begin{environment}{Preamble*}
% \changes{v2.02}{2014/11/03}{neu}^^A
% \begin{environment}{Preamble+}
% \changes{v2.02}{2014/11/03}{neu}^^A
% Die Umgebung \env{Preamble} dient für die Ausgabe von Quelltextauszügenen, 
% welche in einem \LaTeX-Dokument in der Präambel verwendet werden müssen oder
% sollten. Die in ihr gesetzten Inhalte werden für das Copy"~\&"~Paste-Beispiel
% vor den Inhalten aus der Umgebung \env{Trunk} ausgegeben. Die Sternversion
% führt den Inhalt zusätzlich im Dokument aus. Die Pluszechen"=Version fügt dem
% Ausgabestream ihren Inhalt hinzu, ohne das dieser ausgegeben oder ausgeführt
% wird.
% \ToDo{noindentafter?}[v2.07]
%    \begin{macrocode}
\newenvironment{Preamble}{\tud@tut@pre}{%
  \tud@tut@post%
  \tud@tut@append{preamble}%
  \gdef\@tempa{%
    \tud@tut@lst%
    \global\let\Code@Preamble\relax%
  }%
  \aftergroup\@tempa%
}
\newenvironment{Preamble*}{\tud@tut@pre}{%
  \tud@tut@post%
  \tud@tut@append{preamble}%
  \gdef\@tempa{%
    \tud@tut@lst%
    \tud@tut@input%
    \global\let\Code@Preamble\relax%
  }%
  \aftergroup\@tempa%
}
\newenvironment{Preamble+}{\tud@tut@pre}{%
  \tud@tut@post%
  \tud@tut@append{preamble}%
  \gdef\@tempa{%
    \global\let\Code@Preamble\relax%
  }%
  \aftergroup\@tempa%
}
%    \end{macrocode}
% \end{environment}^^A Preamble+
% \end{environment}^^A Preamble*
% \end{environment}^^A Preamble
% \begin{environment}{Trunk}
% \changes{v2.02}{2014/08/16}{neu}^^A
% \begin{environment}{Trunk*}
% \changes{v2.02}{2014/08/19}{neu}^^A
% \begin{environment}{Trunk+}
% \changes{v2.02}{2014/11/03}{neu}^^A
% \begin{environment}{Trunk!}
% \changes{v2.02}{2014/10/07}{neu}^^A
% Die Umgebung \env{Trunk} dient zur Ausgabe von exemplarischen Quelltexten, 
% welche in einem \LaTeX-Dokument innerhalb der \env{document}-Umgebung
% verwendet werden müssen oder sollten. Für das Copy"~\&"~Paste-Beispiel werden 
% die gegebenen Inhalte nach den Inhalten aus der Umgebung \env{Preamble} 
% ausgegeben. Die Sternversion der Umgebung führt ihren Inhalt zusätzlich im
% Dokument aus. Die Pluszeichen"=Version fügt dem Ausgabestream ihren Inhalt
% hinzu, ohne diesen auszugeben oder auszuführen. Die Ausrufezeichen"=Version
% fügt den Quelltext im Dokument ein und führt diesen zusätzlich in einer
% separaten Datei mit einem minimalen Dokumentkörper aus, um daraus eine
% PDF-Datei zu erzeugen, welche im Nachhinein mit \cs{IncludeStandalone} als
% Grafik eingebunden werden kann. Dies ist für Quelltextabschnitte gedacht,
% deren Ausgabe zu groß ist, um diese direkt anzuzeigen und dennoch dargestellt
% werden sollen.
% \ToDo{noindentafter?}[v2.07]
%    \begin{macrocode}
\newenvironment{Trunk}{\tud@tut@pre}{%
  \tud@tut@post%
  \tud@tut@append{trunk}%
  \gdef\@tempa{%
    \tud@tut@lst%
    \global\let\Code@Preamble\relax%
  }%
  \aftergroup\@tempa%
}
\newenvironment{Trunk*}{\tud@tut@pre}{%
  \tud@tut@post%
  \tud@tut@append{trunk}%
  \gdef\@tempa{%
    \tud@tut@lst%
    \tud@tut@input%
    \global\let\Code@Preamble\relax%
  }%
  \aftergroup\@tempa%
}
\newenvironment{Trunk+}{\tud@tut@pre}{%
  \tud@tut@post%
  \tud@tut@append{trunk}%
  \gdef\@tempa{%
    \global\let\Code@Preamble\relax%
  }%
  \aftergroup\@tempa%
}
\NewDocumentEnvironment{Trunk!}{m}{%
  \tud@tut@pre%
}{%
  \tud@tut@post%
  \tud@tut@append{trunk}%
  \gdef\@tempa{%
    \tud@tut@lst%
    \tud@tut@pdf{#1}%
    \global\let\Code@Preamble\relax%
  }%
  \aftergroup\@tempa%
}
%    \end{macrocode}
% \end{environment}^^A Trunk!
% \end{environment}^^A Trunk+
% \end{environment}^^A Trunk*
% \end{environment}^^A Trunk
% \begin{environment}{Hint}
% \changes{v2.02}{2014/09/16}{neu}^^A
% \begin{environment}{Hint*}
% \changes{v2.02}{2014/10/13}{neu}^^A
% \begin{environment}{Hint?}
% \changes{v2.02}{2014/12/09}{neu}^^A
% \begin{environment}{Hint!}
% \changes{v2.02}{2014/11/13}{neu}^^A
% Um Quelltextausschnitte zur weiterführenden Information anzugeben, wird die
% Umgebung \env{Hint} definiert. Der Inhalt wird ausgegben und~-- falls die
% Sternversion genutzt wurde~-- auch ausgeführt, allerdings nicht in das 
% Copy"~\&"~Paste"~Beispiel übernommen. Ansonsten entsprechen alle Umgebungen 
% in ihren Eigenschaften den äquivalenten \env{Trunk}-Umgebungen. Die Version 
% mit Fragezeichen ist für Quelltextauszüge gedacht, die ungeprüft \emph{vor}
% dessen Ausgabe ausgeführt werden sollen. 
% \ToDo{noindentafter?}[v2.07]
%    \begin{macrocode}
\newenvironment{Hint}{\tud@tut@pre}{%
  \tud@tut@post%
  \gdef\@tempa{%
    \tud@tut@lst%
    \global\let\Code@Preamble\relax%
  }%
  \aftergroup\@tempa%
}
\newenvironment{Hint*}{\tud@tut@pre}{%
  \tud@tut@post%
  \gdef\@tempa{%
    \tud@tut@lst%
    \tud@tut@input%
    \global\let\Code@Preamble\relax%
  }%
  \aftergroup\@tempa%
}
\newenvironment{Hint?}{\tud@tut@pre}{%
  \tud@tut@post%
  \gdef\@tempa{%
    \InputCode%
    \tud@tut@lst%
    \global\let\Code@Preamble\relax%
  }%
  \aftergroup\@tempa%
}
\NewDocumentEnvironment{Hint!}{m}{%
  \tud@tut@pre%
}{%
  \tud@tut@post%
  \gdef\@tempa{%
    \tud@tut@lst%
    \tud@tut@pdf{#1}%
    \global\let\Code@Preamble\relax%
  }%
  \aftergroup\@tempa%
}
%    \end{macrocode}
% \end{environment}^^A Hint!
% \end{environment}^^A Hint?
% \end{environment}^^A Hint*
% \end{environment}^^A Hint
% \begin{macro}{\tud@tut@lst}
% \changes{v2.02}{2014/10/07}{neu}^^A
% Damit wird der Quelltext eingezogen ausgegeben.
%    \begin{macrocode}
\newcommand*\tud@tut@lst{%
  \begin{quoting}[rightmargin=0pt]%
  \lstinputlisting[style=tudscr]{\tud@tut@temp.tex}%
  \end{quoting}%
}
%    \end{macrocode}
% \end{macro}^^A \tud@tut@lst
% \begin{macro}{\tud@tut@input}
% \changes{v2.02}{2014/10/13}{neu}^^A
% Für die Ausgabe des Quelltextergebnisses erfolgt ein linker Einzug. Außerdem 
% werden unter anderem abhängig von der Verwendung eines erklärenden Textes die 
% eingefügten vertikalen Abstände angepasst.
%    \begin{macrocode}
\newcommand*\tud@tut@input{%
%    \end{macrocode}
% Nach dem Ausführen des ersten Argumentes von \cs{@tempa} wird geprüft, ob
% dieses überhaupt eine sichtbare Ausgabe erzeugt hat. Nur für diesen Fall wird
% nach dieser vertikaler Leerraum eingefügt. Der Anfang entspricht prinzipiell
% dem Standardbefehl \cs{settoheight}, jedoch wird im Inneren zusätzlich eine
% \cs{vbox} verwendet, um damit auch mathematische Umgebungen testen zu können. 
% Das Ganze findet innerhalb einer Gruppierung statt, um keine Änderungen zu
% erzeugen.
%    \begin{macrocode}
  \def\@tempa##1##2{%
    ##1%
    \begingroup%
      ##2%
      \settoheight\@tempdima{\vbox{##1}}%
      \ifdim\@tempdima>\z@\relax%
        \endgraf%
        \medskip%
        \noindent\ignorespaces%
      \fi%
    \endgroup%
  }%
%    \end{macrocode}
% Da aufgrund der Verwendung der \env{filecontents}-Umgebung ein optionales
% Argument für alle Abwandlungen der Quelltextumgebungen nicht möglich ist,
% wird \cs{CodePreamble} bereitgestellt, womit der Ausgabe ein erläuternder
% Text vorangestellt werden kann.
%    \begin{macrocode}
  \@tempa{\Code@Preamble}{}%
  \tud@setdim\@tempdimc{\leftskip}%
  \tud@setdim\leftskip{\leftmargin}%
%    \end{macrocode}
% Durch die zweimalige Verwendung von \file{\string\tud@tut@temp.tex}~-- einmal 
% direkt und einmal innerhalb einer Box~-- können darin verwendete Befehle wie
% \cs{newcommand} zu Fehler führen. Mit dem Makro \cs{CodeHook} lassen sich 
% diese Konflikte durch eine lokale Redefinition ebensolcher Befehle auflösen
% (bspw. \cs{let}\cs{newcommand}\cs{renewcommand}).
%    \begin{macrocode}
  \@tempa{\input{\tud@tut@temp.tex}}{\Code@Hook}%
  \global\let\Code@Hook\relax%
  \tud@setdim\leftskip{\@tempdimc}%
  \noindent\ignorespaces%
}
%    \end{macrocode}
% \end{macro}^^A \tud@tut@input
% \begin{macro}{\InputCode}
% \changes{v2.02}{2014/10/21}{neu}^^A
% Mit \cs{InputCode} kann der Inhalt der letzen \env{Trunk}-Umgebung 
% direkt ausgeführt werden, ohne diesen zuvor mit \cs{tud@tut@input} zu prüfen 
% und zu formatieren.
%    \begin{macrocode}
\newcommand*\InputCode{\input{\tud@tut@temp.tex}}
%    \end{macrocode}
% \end{macro}^^A \InputCode
% \begin{macro}{\tud@tut@pdf}
% \changes{v2.02}{2014/10/22}{neu}^^A
% Die Umgebungen \env{Trunk!} und \env{Hint!} verwenden nach der Ausgabe des
% Quelltextes diesen abermals, um daraus eine PDF-Datei zu erzeugen. Dafür wird
% eine temporäre \LaTeX-Datei mithilfe einer \env{filecontents}-Umgebung 
% erzeugt. Diese bindet die mit \env{Trunk!} respektive \env{Hint!} erzeugte 
% Datei ein und wird anschließend via \cs{ShellEscape} kompiliert. Dabei sollte
% man sich nicht von der doppelten Verwendung von \cs{jobname} verwirren 
% lassen. Der Dateiname der temporär erzeugten \LaTeX-Datei ist abhängig vom
% gesetzten Tutorial. Beim Aufruf von \app{pdflatex} wird \cs{jobname} über den
% entsprechenden Kommandozeilenparameter angepasst (siehe \cs{tud@tut@pdf}).
%    \begin{macrocode}
\IfFileExists{\tud@tut@temp-standalone.tex}{\@tempswafalse}{\@tempswatrue}
\if@tempswa
\begin{filecontents*}[force,silent,nosearch]{\tud@tut@temp-standalone.tex}
\documentclass[english,ngerman]{tudscrreprt}
\iftutex
  \usepackage{fontspec}
\else
  \usepackage[T1]{fontenc}
  \usepackage[ngerman=ngerman-x-latest]{hyphsubst}
\fi
\usepackage{babel}
\usepackage{tudscrsupervisor}
\usepackage{isodate}
\usepackage{enumitem}
\setlist{noitemsep}
\begin{document}
\input{\jobname.tex}%
\end{document}
\end{filecontents*}
\fi
%    \end{macrocode}
% Der Quelltext der Umgebungen \env{Trunk!} und \env{Hint!} wird~-- wie bei
% allen anderen \env{Trunk}"~ und \env{Hint!}"~Derivaten~-- in der Datei
% \file{\string\tud@tut@temp.tex} gesichert. Diese wird für das Procederre 
% in \file{\string\jobname-standalone-\#1.tex} umbenannt. Anschließend wird 
% beim Aufruf von \app{pdflatex} durch die Nutzung des Kommandozeilenparameters
% \file{-jobname=\string\jobname-standalone-\#1} der Befehl \cs{jobname} in der 
% aufgerufenen Datei \file{\string\tud@tut@temp-standalone.tex} überschrieben
% und der Inhalt von \file{\string\jobname-standalone-\#1.tex} wie gewünscht
% eingebunden und kompiliert. Die so erstellte PDF"~Datei kann anschließend mit 
% \cs{IncludeStandalone} in das Tutorial eingebunden werden.
% \ToDo{Kompilieren mit \app{make}}[v2.07]
%    \begin{macrocode}
\newcommand*\tud@tut@pdf[1]{%
  \ifnum\pdf@shellescape=\@ne\relax%
    \filemodCmp{\jobname-standalone-#1.pdf}{\jobname.tex}{}{%
      \begingroup%
        \ShellEscape{%
          \ifwindows%
            copy%
          \else%
            cp%
          \fi%
          \space"\tud@tut@temp.tex"\space"\jobname-standalone-#1.tex"%
        }%
        \edef\@tempa{%
          \tud@latex@ext -jobname="\jobname-standalone-#1"\space%
          "\unexpanded{\noexpand\input}{\tud@tut@temp-standalone.tex}"%
        }%
        \ShellEscape{\@tempa}%
        \ShellEscape{\@tempa}%
        \ShellEscape{\@tempa}%
        \ShellEscape{%
          \ifwindows%
            del%
          \else%
            rm%
          \fi%
          \space"\jobname-standalone-#1.tex"%
        }%
      \endgroup%
    }%
  \fi%
}
%    \end{macrocode}
% \end{macro}^^A \tud@tut@pdf
% \begin{macro}{\IncludeStandalone}
% \changes{v2.02}{2014/09/10}{neu}^^A
% Der Befehl \cs{IncludeStandalone} bindet die mit den Umgebungen \env{Trunk!} 
% und \env{Hint!} generierten PDF"~Dateien ein. Das angehängte optionale 
% Argument dient zur Angabe der einzubindenden Seiten der PDF-Datei, wobei
% diese automatisch auf die passende Breite skaliert werden.
%    \begin{macrocode}
\NewDocumentCommand\IncludeStandalone{o m !O{1}}{%
  \IfFileExists{\jobname-standalone-#2.pdf}{%
    \@tempcnta\z@%
    \@for\@tempa:=#3\do{\advance\@tempcnta\@ne}%
    \ifnum\@tempcnta>\z@\relax%
      \tud@setdim\@tempdima{\textwidth}%
      \divide\@tempdima\@tempcnta%
      \advance\@tempcnta\m@ne%
      \multiply\@tempcnta 2%
      \tud@addtodim\@tempdima{-\@tempcnta\tabcolsep}%
      \@for\@tempa:=#3\do{%
        \advance\@tempcnta\m@ne%
        \edef\@tempb{%
          keepaspectratio,page=\@tempa,width=\the\@tempdima,%
          \IfValueT{#1}{#1}%
        }%
        \fbox{%
          \expandafter\includegraphics\expandafter[\@tempb]{%
            \jobname-standalone-#2.pdf%
          }%
        }%
        \ifnum\@tempcnta>\z@\relax\hfill\fi%
      }%
    \fi%
  }{%
    \tud@shellescape@wrn{\jobname-standalone-#2.pdf}%
  }%
}
%    \end{macrocode}
% \end{macro}^^A \IncludeStandalone
%
% \subsection{Automatische Erstellung von \pkg{pstricks}-Grafiken}
%
% Falls innerhalb eines Tutorials das Paket \pkg{pstricks} verwendet wird, muss
% dafür Sorge getragen werden, dass die automatische Kompilierung reibungslos
% mit \pkg{auto-pst-pdf} funktioniert.
%    \begin{macrocode}
\AfterPackage*{pstricks}{%
  \ifnum\pdf@shellescape=\@ne\relax%
    \filemodCmp{\jobname-pics.pdf}{\jobname.tex}{%
      \PassOptionsToPackage{off}{auto-pst-pdf}%
    }{}%
  \else%
    \PassOptionsToPackage{off}{auto-pst-pdf}%
  \fi%
  \RequirePackage{auto-pst-pdf}[2009/04/26]%
%    \end{macrocode}
% Nach dem Paket \pkg{auto-pst-pdf} seine Arbeit verrichtet hat, werden alle 
% etwaigen temporär erzeugten Dateien radikal gelöscht.
%    \begin{macrocode}
  \ifnum\pdf@shellescape=\@ne\relax%
    \edef\@tempa{\app@exe{\app@rm "*\app@suffix*"}}%
    \@tempa%
  \fi%
}
%    \end{macrocode}
%
% \iffalse
%</package>
%<*class>
% \fi
%
% \subsection{Debug-Traces für die Klasse \cls{tudscrmanual}}
%
% Ab und an ist es beim Erstellen des Handbuchs recht sinnvoll, verschiedene 
% Dinge direkt im Log-File zu überprüfen. Hierfür werden folgend einige Befehle 
% zur Ablaufkontrolle definiert.
%
% \begin{macro}{\tracinglabels}
% \changes{v2.05}{2015/10/29}{neu}^^A
% \changes{v2.07}{2019/09/19}{optionales Argument unterstützt mehrere Werte}^^A
% \begin{macro}{\tud@trace@lbl@types}
% \changes{v2.07}{2019/09/22}{neu}^^A
% \begin{macro}{\tud@trace@lbl@wlog}
% \changes{v2.07}{2019/09/19}{neu}^^A
% \begin{macro}{\tud@trace@lbl@add}
% \changes{v2.07}{2019/09/19}{neu}^^A
% \begin{macro}{\tud@trace@lbl@@add}
% \changes{v2.07}{2019/09/19}{neu}^^A
% \begin{macro}{\tud@trace@lbl@created@list}
% \changes{v2.05}{2015/10/29}{neu}^^A
% \begin{macro}{\tud@trace@lbl@matched@list}
% \changes{v2.07}{2019/09/19}{neu}^^A
% \begin{macro}{\tud@trace@lbl@ignored@list}
% \changes{v2.07}{2019/09/19}{neu}^^A
% \begin{macro}{\tud@trace@lbl@missing@list}
% \changes{v2.05}{2015/10/29}{neu}^^A
% \begin{macro}{\tud@trace@lbl@url@list}
% \changes{v2.07}{2019/09/19}{neu}^^A
% Mit \cs{tracinglabels} wird die Nachverfolgung aller erstellten Labels in der 
% Dokumentation aktiviert werden. Die Label werden zum einen direkt im Log-File
% ausgegeben und am Ende des selbigen in einer sortierten Liste ausgegeben. Die 
% Sternversion des Befehls erzeugt keine sortierte Liste. Über das optionale 
% Argument kann mit verschiedenen Schlüsseln zudem eingestellt werden, ob alle
% Label (\val{all}) oder nur die erstellten (\val{created}) beziehungsweise die
% fehlenden (\val{missing}) nachverfolgt werden sollen.
%    \begin{macrocode}
\newcommand*\tud@trace@lbl@wlog{\relax}
\AfterEndDocument{\tud@trace@lbl@wlog}
\newcommand*\tud@trace@lbl@types{}
\listadd\tud@trace@lbl@types{created}
\listadd\tud@trace@lbl@types{matched}
\listadd\tud@trace@lbl@types{ignored}
\listadd\tud@trace@lbl@types{missing}
\listadd\tud@trace@lbl@types{url}
\def\tud@res@a#1{%
  \expandafter\newcommand\csname tud@trace@lbl@#1@list\endcsname{}%
  \cslet{tud@trace@lbl@#1@list}\relax%
}
\forlistloop{\tud@res@a}{\tud@trace@lbl@types}
\NewDocumentCommand\tracinglabels{!s !D<>{} !O{missing}}{%
  \def\tud@res@a##1{\cslet{tud@trace@lbl@##1@list}\relax}%
  \forlistloop{\tud@res@a}{\tud@trace@lbl@types}%
  \let\tud@res@b\@empty%
  \in@{,all,}{,#3,}%
  \ifin@%
    \let\tud@res@b\tud@trace@lbl@types%
  \else%
    \def\tud@res@a##1{%
      \in@{,##1,}{,#3,}%
      \ifin@%
        \listadd\tud@res@b{##1}%
      \fi%
    }%
    \forlistloop{\tud@res@a}{\tud@trace@lbl@types}%
  \fi%
  \def\tud@trace@lbl@wlog{\relax}%
  \def\tud@res@a##1{%
    \cslet{tud@trace@lbl@##1@list}\@empty%
    \IfBooleanF{#1}{%
      \in@{,##1,}{,#2,}%
      \ifin@\else%
        \appto\tud@trace@lbl@wlog{%
          \ifcsvoid{tud@trace@lbl@##1@list}{%
            \wlog{+++++ no labels ##1 +++++}%
          }{%
            \wlog{+++++ labels ##1 (sorted) +++++}%
            \expandafter\tud@list@sort\csname tud@trace@lbl@##1@list\endcsname%
%    \end{macrocode}
% Damit der Befehl \cs{wlog} nicht mit jedem Schleifendurchlauf aufgerufen 
% werden muss, wird ein Hilfsmakro mit dem notwendigen Inhalt bestückt.
%    \begin{macrocode}
            \let\tud@res@c\@empty%
            \def\tud@res@a####1{\appto\tud@res@c{####1^^J}}%
            \forlistcsloop\tud@res@a{tud@trace@lbl@##1@list}%
            \@onelevel@sanitize\tud@res@c%
            \wlog{\tud@res@c}%
          }%
        }%
      \fi%
    }%
  }%
  \forlistloop{\tud@res@a}{\tud@res@b}%
}
\@onlypreamble\tracinglabels
%    \end{macrocode}
% Hiermit werden Labels aus der Liste im zweiten obligatorischen Argument der 
% Typliste im ersten obligatorischen Argument hinzugefügt. Das optionale 
% Argument dient als zusätzliche Angabe im Log-File.
%    \begin{macrocode}
\NewDocumentCommand\tud@trace@lbl@add{m o m}{%
  \ifcsundef{tud@trace@lbl@#1@list}{%
    \xifinlist{#1}{\tud@trace@lbl@types}{}{%
      \ClassError{tudscrmanual}{Undefined label type `#1'}{%
        The given tracing type was never defined.%
      }%
    }%
  }{%
    \begingroup%
      \protected@edef\tud@res@a{%
        \endgroup%
        \noexpand\tud@trace@lbl@@add{#1}{#2}{#3}%
      }%
    \tud@res@a%
  }%
}
\newcommand*\tud@trace@lbl@@add[3]{%
  \begingroup%
    \let\tud@res@b\@empty%
    \let\tud@res@c\@empty%
    \let\tud@res@d\m@ne%
%    \end{macrocode}
% Das optionale Argument dient für zusätzliche Angaben im Log-File für die 
% unterschiedlichen Typlisten, welche in \cs{tud@res@b} und \cs{tud@res@c}
% abgelegt werden.
%    \begin{macrocode}
    \IfValueT{#2}{%
      \TUD@set@numkey{}{tud@res@d}{%
        {url}{0},{matched}{1},{created}{2},{missing}{2},
      }{#1}%
      \ifx\FamilyKeyState\FamilyKeyStateProcessed%
        \ifcase\tud@res@d\relax%
          \def\tud@res@c{#2}%
        \or%
          \def\tud@res@b{\space(substituted)}%
          \def\tud@res@c{<-\space#2}%
        \or%
          \tud@trace@lbl@add{url}[{#2}]{#3}%
          \def\tud@res@c{->\space#2}%
        \fi%
      \else%
        \ClassWarning{tudscrmanual}{No specific label log `#1' defined}%
        \FamilyKeyStateProcessed%
      \fi%
    }%
%    \end{macrocode}
% Die Labels werden in einer Liste übergeben, welche hier verarbeitet wird.
%    \begin{macrocode}
    \let\tud@res@a\@empty%
    \def\do##1{%
      \begingroup%
        \ifnum\tud@res@d=\z@\relax% url
          \tud@if@lbl@exists{##1}{%
            \eappto\tud@res@c{\space<-\space##1}%
          }{%
            \eappto\tud@res@c{\space??\space##1}%
          }%
        \else%
          \protected@edef\tud@res@c{%
            ##1\ifx\tud@res@c\@empty\else\space\tud@res@c\fi%
          }%
        \fi%
        \@onelevel@sanitize\tud@res@c%
        \tud@unique@csxadd{tud@trace@lbl@#1@list}{\tud@res@c}%
      \endgroup%
%    \end{macrocode}
% In \cs{tud@res@a} werden alle Einträge für das Log-File gesammelt.
%    \begin{macrocode}
      \protected@eappto\tud@res@a{%
        ^^J\@spaces##1\ifx\tud@res@c\@empty\else^^J\@spaces\tud@res@c\fi%
      }%
    }%
    \dolistloop{#3}%
    \ifnum\tud@res@d=\z@\relax\else% !url
      \ifx\tud@res@a\@empty\else%
        \epreto\tud@res@a{+++++ label #1\tud@res@b\on@line\space+++++}%
        \@onelevel@sanitize\tud@res@a%
        \wlog{\tud@res@a}%
      \fi%
    \fi%
  \endgroup%
}
%    \end{macrocode}
% \end{macro}^^A \tud@trace@lbl@url@list
% \end{macro}^^A \tud@trace@lbl@missing@list
% \end{macro}^^A \tud@trace@lbl@ignored@list
% \end{macro}^^A \tud@trace@lbl@matched@list
% \end{macro}^^A \tud@trace@lbl@created@list
% \end{macro}^^A \tud@trace@lbl@@add
% \end{macro}^^A \tud@trace@lbl@add
% \end{macro}^^A \tud@trace@lbl@wlog
% \end{macro}^^A \tud@trace@lbl@types
% \end{macro}^^A \tracinglabels
% \begin{macro}{\tracingmarkup}
% \changes{v2.05}{2015/10/29}{neu}^^A
% \begin{macro}{\tud@trace@markup@types}
% \changes{v2.07}{2019/11/22}{neu}^^A
% \begin{macro}{\tud@trace@markup@add}
% \changes{v2.07}{2019/11/22}{neu}^^A
% \begin{macro}{\tud@trace@markup@declare@list}
% \changes{v2.07}{2019/11/22}{neu}^^A
% \begin{macro}{\tud@trace@markup@output@list}
% \changes{v2.07}{2019/11/22}{neu}^^A
% Mit \cs{tracingmarkup} wird die Nachverfolgung aller Aufrufe von
% \cs{Process@@MarkupDeclare} und \cs{Process@@MarkupInline} durch
% \cs{Process@Markup} inklusive all ihrer Argumente aktiviert. Dies wird 
% gegebenenfalls zur Kontrolle des erzeugten Markups genutzt.
%    \begin{macrocode}
\newcommand*\tud@trace@markup@types{}
\listadd\tud@trace@markup@types{declare}
\listadd\tud@trace@markup@types{output}
\def\tud@res@a#1{%
  \expandafter\newcommand\csname tud@trace@markup@#1@list\endcsname{}%
  \cslet{tud@trace@markup@#1@list}\relax%
}
\forlistloop{\tud@res@a}{\tud@trace@markup@types}
\NewDocumentCommand\tracingmarkup{!O{declare}}{%
  \def\tud@res@a##1{\cslet{tud@trace@markup@##1@list}\relax}%
  \forlistloop{\tud@res@a}{\tud@trace@markup@types}%
  \let\tud@res@b\@empty%
  \let\tud@res@c\@empty%
  \protected@edef\tud@res@a{#1}%
  \@for\tud@res@a:=\tud@res@a\do{%
    \trim@spaces@in\tud@res@a%
    \ifx\tud@res@a\@empty\else%
      \listeadd\tud@res@b{\tud@res@a}%
    \fi%
  }%
  \ifinlist{all}{\tud@res@b}{%
    \let\tud@res@c\tud@trace@markup@types%
  }{%
    \def\tud@res@a##1{\xifinlist{##1}{\tud@res@b}{\listeadd\tud@res@c{##1}}{}}%
    \forlistloop{\tud@res@a}{\tud@trace@markup@types}%
  }%
  \def\tud@res@a##1{\cslet{tud@trace@markup@##1@list}\@empty}%
  \forlistloop{\tud@res@a}{\tud@res@c}%
}
\@onlypreamble\tracingmarkup
\newcommand*\tud@trace@markup@add[2]{%
  \begingroup%
    \ifcsundef{tud@trace@markup@#1@list}{%
      \xifinlist{#1}{\tud@trace@markup@types}{}{%
        \ClassError{tudscrmanual}{Undefined markup type `#1'}{%
          The given tracing type was never defined.%
        }%
      }%
    }{%
      \protected@edef\tud@res@a{#2}%
      \@onelevel@sanitize\tud@res@a%
      \wlog{+++++ markup #1\on@line\space+++++^^J\@spaces\tud@res@a}%
      \tud@unique@csxadd{tud@trace@markup@#1@list}{\tud@res@a}%
    }%
  \endgroup%
}
%    \end{macrocode}
% \end{macro}^^A \tud@trace@markup@output@list
% \end{macro}^^A \tud@trace@markup@declare@list
% \end{macro}^^A \tud@trace@markup@add
% \end{macro}^^A \tud@trace@markup@types
% \end{macro}^^A \tracingmarkup
%
% \iffalse
%</class>
%</body>
%<*option>
% \fi
%
%
% \subsection{Optionen für die finale Ausgabe}
%
% \begin{option}{final}
% \begin{option}{print}
% \begin{macro}{\tudfinalflag}
% \begin{macro}{\tudprintflag}
% Diese beiden Optionen dienen zur finalen und/oder der unbunten Ausgabe.
%    \begin{macrocode}
\TUD@key{final}[true]{%
  \TUD@set@ifkey{final}{@tempswa}{#1}%
  \ifx\FamilyKeyState\FamilyKeyStateProcessed%
    \if@tempswa%
      \let\tudfinalflag\relax%
    \fi%
  \fi%
}
\TUD@key{print}[true]{%
  \TUD@set@ifkey{print}{@tempswa}{#1}%
  \ifx\FamilyKeyState\FamilyKeyStateProcessed%
    \if@tempswa%
      \let\tudprintflag\relax%
    \fi%
  \fi%
}
%    \end{macrocode}
% \end{macro}^^A \tudprintflag
% \end{macro}^^A \tudfinalflag
% \end{option}^^A print
% \end{option}^^A final
%
% Wurde eine oder beide der Optionen \opt{final} oder \opt{print} gesetzt bzw.
% vor einem externen \app{pdflatex}-Aufruf die Flags \cs{tudfinalflag} und/oder
% \cs{tudprintflag} definiert, werden die entsprechenden Einstellungen zur
% finalen Ausgabe und/oder unbunten Druck vorgenommen und anschließend die 
% entsprechenden Optionen unschädlich gemacht.
%    \begin{macrocode}
%<*class>
\AtEndOfClass%
%</class>
%<*package>
\AtEndOfPackage%
%</package>
{%
  \TUD@key@toolate{final}%
  \TUD@key@toolate{print}%
  \ifdef{\tudfinalflag}{%
    \TUDoptions{ToDo=false}%
    \TUD@key{ToDo}{\FamilyKeyStateProcessed}%
    \TUDoptions{indexnote=false}%
    \TUD@key{indexnote}{\FamilyKeyStateProcessed}%
  }{%
    \KOMAoptions{overfullrule}%
  }%
  \ifdef{\tudprintflag}{%
    \ifnum\tud@cd@num>\z@\relax%
      \TUDoptions{cd=true}%
    \fi%
    \ifundef{\hypersetup}{}{\hypersetup{hidelinks}}%
  }{}%
  \TUD@key@toolate{cd}%
}
%    \end{macrocode}
%
% \iffalse
%<*class>
% \fi
%
% \minisec{Standardoptionen der Klasse \cls{tudscrmanual}}
%
% Es werden einige Optionen für das Handbuch standardmäßig aktiviert. Dazu 
% werden diese an die entsprechende Elternklasse übergeben.
%    \begin{macrocode}
\PassOptionsToClass{%
  ttfont=roboto,%
  cd=color,%
  cdfoot=true,%
  chapterpage=true,%
  chapterprefix=true,%
  headings=optiontoheadandtoc,%
  captions=tableheading,%
  numbers=noenddot,%
}{\TUD@Class@Parent}
%    \end{macrocode}
%
% \iffalse
%</class>
%</option>
% \fi
%
%
% \PrintBackMatter
%
\endinput
